Index: arm-trusted-firmware.git/fdts/stm32mp15-ddr3-1x2Gb-1866-binF.dtsi
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp15-ddr3-1x2Gb-1866-binF.dtsi
@@ -0,0 +1,121 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2018, STMicroelectronics - All Rights Reserved
+ */
+/* STM32MP157C DK1/DK2 BOARD configuration
+ * 1x DDR3L 4Gb, 16-bit, 533MHz.
+ * Reference used NT5CC256M16DP-DI from NANYA
+ *
+ * DDR type / Platform	DDR3/3L
+ * freq		533MHz
+ * width	16
+ * datasheet	0  = MT41J256M16-187 / DDR3-1066 bin G
+ * DDR density	4
+ * timing mode	optimized
+ * Scheduling/QoS options : type = 2
+ * address mapping : RBC
+ * Tc > + 85C : N
+ */
+
+#define DDR_MEM_NAME "DDR3-1066/888 bin G 1x2Gb 533MHz v1.41"
+#define DDR_MEM_SPEED 533000
+#define DDR_MEM_SIZE 0x10000000
+
+#define DDR_MSTR 0x00041401
+#define DDR_MRCTRL0 0x00000010
+#define DDR_MRCTRL1 0x00000000
+#define DDR_DERATEEN 0x00000000
+#define DDR_DERATEINT 0x00800000
+#define DDR_PWRCTL 0x00000000
+#define DDR_PWRTMG 0x00400010
+#define DDR_HWLPCTL 0x00000000
+#define DDR_RFSHCTL0 0x00210000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x0081008B
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_DRAMTMG0 0x121B2414
+#define DDR_DRAMTMG1 0x000A041C
+#define DDR_DRAMTMG2 0x0608090F
+#define DDR_DRAMTMG3 0x0050400C
+#define DDR_DRAMTMG4 0x08040608
+#define DDR_DRAMTMG5 0x06060403
+#define DDR_DRAMTMG6 0x02020002
+#define DDR_DRAMTMG7 0x00000202
+#define DDR_DRAMTMG8 0x00001005
+#define DDR_DRAMTMG14 0x000000A0
+#define DDR_ZQCTL0 0xC2000040
+#define DDR_DFITMG0 0x02060105
+#define DDR_DFITMG1 0x00000202
+#define DDR_DFILPCFG0 0x07000000
+#define DDR_DFIUPD0 0xC0400003
+#define DDR_DFIUPD1 0x00000000
+#define DDR_DFIUPD2 0x00000000
+#define DDR_DFIPHYMSTR 0x00000000
+#define DDR_ADDRMAP1 0x00070707
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x1F000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x06060606
+#define DDR_ADDRMAP6 0x0F060606
+#define DDR_ADDRMAP9 0x00000000
+#define DDR_ADDRMAP10 0x00000000
+#define DDR_ADDRMAP11 0x00000000
+#define DDR_ODTCFG 0x06000600
+#define DDR_ODTMAP 0x00000001
+#define DDR_SCHED 0x00000C01
+#define DDR_SCHED1 0x00000000
+#define DDR_PERFHPR1 0x01000001
+#define DDR_PERFLPR1 0x08000200
+#define DDR_PERFWR1 0x08000400
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000010
+#define DDR_PCFGR_0 0x00010000
+#define DDR_PCFGW_0 0x00000000
+#define DDR_PCFGQOS0_0 0x02100C03
+#define DDR_PCFGQOS1_0 0x00800100
+#define DDR_PCFGWQOS0_0 0x01100C03
+#define DDR_PCFGWQOS1_0 0x01000200
+#define DDR_PCFGR_1 0x00010000
+#define DDR_PCFGW_1 0x00000000
+#define DDR_PCFGQOS0_1 0x02100C03
+#define DDR_PCFGQOS1_1 0x00800040
+#define DDR_PCFGWQOS0_1 0x01100C03
+#define DDR_PCFGWQOS1_1 0x01000200
+#define DDR_PGCR 0x01442E02
+#define DDR_PTR0 0x0022AA5B
+#define DDR_PTR1 0x04841104
+#define DDR_PTR2 0x042DA068
+#define DDR_ACIOCR 0x10400812
+#define DDR_DXCCR 0x00000C40
+#define DDR_DSGCR 0xF200001F
+#define DDR_DCR 0x0000000B
+#define DDR_DTPR0 0x38D488D0
+#define DDR_DTPR1 0x098B00D8
+#define DDR_DTPR2 0x10023600
+#define DDR_MR0 0x00000840
+#define DDR_MR1 0x00000000
+#define DDR_MR2 0x00000208
+#define DDR_MR3 0x00000000
+#define DDR_ODTCR 0x00010000
+#define DDR_ZQ0CR1 0x00000038
+#define DDR_DX0GCR 0x0000CE81
+#define DDR_DX0DLLCR 0x40000000
+#define DDR_DX0DQTR 0xFFFFFFFF
+#define DDR_DX0DQSTR 0x3DB02000
+#define DDR_DX1GCR 0x0000CE81
+#define DDR_DX1DLLCR 0x40000000
+#define DDR_DX1DQTR 0xFFFFFFFF
+#define DDR_DX1DQSTR 0x3DB02000
+#define DDR_DX2GCR 0x0000CE81
+#define DDR_DX2DLLCR 0x40000000
+#define DDR_DX2DQTR 0xFFFFFFFF
+#define DDR_DX2DQSTR 0x3DB02000
+#define DDR_DX3GCR 0x0000CE81
+#define DDR_DX3DLLCR 0x40000000
+#define DDR_DX3DQTR 0xFFFFFFFF
+#define DDR_DX3DQSTR 0x3DB02000
+
+#include "stm32mp15-ddr.dtsi"
Index: arm-trusted-firmware.git/fdts/stm32mp15-mx.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp15-mx.h
@@ -0,0 +1,115 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ *
+ * Copyright (C) 2015-2018, STMicroelectronics - All Rights Reserved
+ *
+ */
+
+/*
+ * File generated by STMicroelectronics STM32CubeMX DDR Tool for MPUs
+ * DDR type: DDR3 / DDR3L
+ * DDR width: 16bits
+ * System frequency: 533000Khz
+ * Relaxed Timing Mode: false
+ * Address mapping type: RBC
+ *
+ * Save Date: 2019.08.16, save Time: 17:02:41
+ */
+
+#define DDR_MEM_SPEED	533000
+
+#define DDR_MSTR 0x00041401
+#define DDR_MRCTRL0 0x00000010
+#define DDR_MRCTRL1 0x00000000
+#define DDR_DERATEEN 0x00000000
+#define DDR_DERATEINT 0x00800000
+#define DDR_PWRCTL 0x00000000
+#define DDR_PWRTMG 0x00400010
+#define DDR_HWLPCTL 0x00000000
+#define DDR_RFSHCTL0 0x00210000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x0081008B
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_DRAMTMG0 0x121B2414
+#define DDR_DRAMTMG1 0x000A041C
+#define DDR_DRAMTMG2 0x0608090F
+#define DDR_DRAMTMG3 0x0050400C
+#define DDR_DRAMTMG4 0x08040608
+#define DDR_DRAMTMG5 0x06060403
+#define DDR_DRAMTMG6 0x02020002
+#define DDR_DRAMTMG7 0x00000202
+#define DDR_DRAMTMG8 0x00001005
+#define DDR_DRAMTMG14 0x000000A0
+#define DDR_ZQCTL0 0xC2000040
+#define DDR_DFITMG0 0x02060105
+#define DDR_DFITMG1 0x00000202
+#define DDR_DFILPCFG0 0x07000000
+#define DDR_DFIUPD0 0xC0400003
+#define DDR_DFIUPD1 0x00000000
+#define DDR_DFIUPD2 0x00000000
+#define DDR_DFIPHYMSTR 0x00000000
+#define DDR_ODTCFG 0x06000600
+#define DDR_ODTMAP 0x00000001
+#define DDR_SCHED 0x00000C01
+#define DDR_SCHED1 0x00000000
+#define DDR_PERFHPR1 0x01000001
+#define DDR_PERFLPR1 0x08000200
+#define DDR_PERFWR1 0x08000400
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000010
+#define DDR_PCFGR_0 0x00010000
+#define DDR_PCFGW_0 0x00000000
+#define DDR_PCFGQOS0_0 0x02100C03
+#define DDR_PCFGQOS1_0 0x00800100
+#define DDR_PCFGWQOS0_0 0x01100C03
+#define DDR_PCFGWQOS1_0 0x01000200
+#define DDR_PCFGR_1 0x00010000
+#define DDR_PCFGW_1 0x00000000
+#define DDR_PCFGQOS0_1 0x02100C03
+#define DDR_PCFGQOS1_1 0x00800040
+#define DDR_PCFGWQOS0_1 0x01100C03
+#define DDR_PCFGWQOS1_1 0x01000200
+#define DDR_ADDRMAP1 0x00070707
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x1F000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x06060606
+
+#define DDR_ADDRMAP9 0x00000000
+#define DDR_ADDRMAP10 0x00000000
+#define DDR_ADDRMAP11 0x00000000
+#define DDR_PGCR 0x01442E02
+#define DDR_PTR0 0x0022AA5B
+#define DDR_PTR1 0x04841104
+#define DDR_PTR2 0x042DA068
+#define DDR_ACIOCR 0x10400812
+#define DDR_DXCCR 0x00000C40
+#define DDR_DSGCR 0xF200001F
+#define DDR_DCR 0x0000000B
+#define DDR_DTPR0 0x38D488D0
+#define DDR_DTPR1 0x098B00D8
+#define DDR_DTPR2 0x10023600
+#define DDR_MR0 0x00000840
+#define DDR_MR1 0x00000000
+#define DDR_MR2 0x00000208
+#define DDR_MR3 0x00000000
+#define DDR_ODTCR 0x00010000
+#define DDR_ZQ0CR1 0x00000038
+#define DDR_DX0GCR 0x0000CE81
+#define DDR_DX0DLLCR 0x40000000
+#define DDR_DX0DQTR 0x00050000
+#define DDR_DX0DQSTR 0x3DB02000
+#define DDR_DX1GCR 0x0000CE81
+#define DDR_DX1DLLCR 0x40000000
+#define DDR_DX1DQTR 0x05550A05
+#define DDR_DX1DQSTR 0x3D202000
+#define DDR_DX2GCR 0x0000C881
+#define DDR_DX2DLLCR 0x40000000
+#define DDR_DX2DQTR 0xFFFFFFFF
+#define DDR_DX2DQSTR 0x3DB02000
+#define DDR_DX3GCR 0x0000C881
+#define DDR_DX3DLLCR 0x40000000
+#define DDR_DX3DQTR 0xFFFFFFFF
+#define DDR_DX3DQSTR 0x3DB02000
Index: arm-trusted-firmware.git/fdts/stm32mp153a-txmp.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp153a-txmp.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ *
+ * Copyright (C) 2015-2018, STMicroelectronics - All Rights Reserved
+ *
+ */
+
+/*
+ * File generated by STMicroelectronics STM32CubeMX DDR Tool for MPUs
+ * DDR type: DDR3 / DDR3L
+ * DDR width: 16bits
+ * DDR density: 2Gb
+ * System frequency: 533000Khz
+ * Relaxed Timing Mode: false
+ * Address mapping type: RBC
+ *
+ * Save Date: 2019.08.16, save Time: 17:02:41
+ */
+
+#define DDR_MEM_NAME	"DDR3L-1066/777 bin F 1x2Gb 533MHz"
+#define DDR_MEM_SIZE	0x10000000
+#define DDR_ADDRMAP6	0x0F0F0606
+
+#include "stm32mp15-mx.h"
Index: arm-trusted-firmware.git/fdts/stm32mp157c-qsmp-1570.dts
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp157c-qsmp-1570.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: STM32CubeMX code generation for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-qsmp.h"
+#include "stm32mp15-qsmp.dtsi"
+
+/ {
+	model = "Ka-Ro electronics GmbH QSMP-1570 solder-in module";
+	compatible = "karo,stm32mp157c-qsmp-1570", "st,stm32mp157";
+};
Index: arm-trusted-firmware.git/fdts/stm32mp157c-qsmp.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp157c-qsmp.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ *
+ * Copyright (C) 2015-2018, STMicroelectronics - All Rights Reserved
+ *
+ */
+
+/*
+ * File generated by STMicroelectronics STM32CubeMX DDR Tool for MPUs
+ * DDR type: DDR3 / DDR3L
+ * DDR width: 16bits
+ * DDR density: 4Gb
+ * System frequency: 533000Khz
+ * Relaxed Timing Mode: false
+ * Address mapping type: RBC
+ *
+ * Save Date: 2019.09.19, save Time: 12:51:40
+ */
+
+#define DDR_MEM_NAME	"DDR3L-1066/777 bin F 1x4Gb 533MHz"
+#define DDR_MEM_SIZE	0x20000000
+#define DDR_ADDRMAP6	0x0F060606
+
+#include "stm32mp15-mx.h"
Index: arm-trusted-firmware.git/fdts/stm32mp153a-txmp-1530.dts
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp153a-txmp-1530.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: STM32CubeMX code generation for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp153a-txmp.h"
+#include "stm32mp15-txmp.dtsi"
+
+/ {
+	model = "Ka-Ro electronics GmbH TXMP-1530 module";
+	compatible = "karo,stm32mp153a-txmp-1530", "st,stm32mp153";
+};
Index: arm-trusted-firmware.git/fdts/stm32mp157c-txmp-1570.dts
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp157c-txmp-1570.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: STM32CubeMX code generation for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-txmp.h"
+#include "stm32mp15-txmp.dtsi"
+
+/ {
+	model = "Ka-Ro electronics GmbH TXMP-1570 module";
+	compatible = "karo,stm32mp157c-txmp-1570", "st,stm32mp153";
+};
Index: arm-trusted-firmware.git/fdts/stm32mp157c-txmp.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp157c-txmp.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ *
+ * Copyright (C) 2015-2018, STMicroelectronics - All Rights Reserved
+ *
+ */
+
+/*
+ * File generated by STMicroelectronics STM32CubeMX DDR Tool for MPUs
+ * DDR type: DDR3 / DDR3L
+ * DDR width: 16bits
+ * DDR density: 2Gb
+ * System frequency: 533000Khz
+ * Relaxed Timing Mode: false
+ * Address mapping type: RBC
+ *
+ * Save Date: 2019.08.16, save Time: 17:02:41
+ */
+
+#define DDR_MEM_NAME	"DDR3L-1066/777 bin F 1x4Gb 533MHz"
+#define DDR_MEM_SIZE	0x20000000
+#define DDR_ADDRMAP6	0x0F060606
+
+#include "stm32mp15-mx.h"
Index: arm-trusted-firmware.git/fdts/stm32mp15-karo.dtsi
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp15-karo.dtsi
@@ -0,0 +1,98 @@
+#include "stm32mp157c-security.dtsi"
+#include "stm32mp15-ddr.dtsi"
+#include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+
+/ {
+	aliases {
+		mmc0 = &sdmmc2;
+		serial0 = &uart4;
+		serial1 = &usart2;
+		serial2 = &usart3;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+	};
+
+	sram: sram@10050000 {
+		compatible = "mmio-sram";
+		reg = <0x10050000 0x10000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0x10050000 0x10000>;
+
+		dma_pool: dma_pool@0 {
+			reg = <0x0 0x10000>;
+			pool;
+		};
+	};
+};
+
+&bsec {
+	board_id: board_id@ec {
+		reg = <0xec 0x4>;
+		st,non-secure-otp;
+	};
+};
+
+&clk_lse {
+	status = "disabled";
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&nvmem_layout {
+	nvmem-cells = <&part_number_otp>,
+		      <&monotonic_otp>,
+		      <&nand_otp>,
+		      <&uid_otp>,
+		      <&package_otp>,
+		      <&hw2_otp>,
+		      <&board_id>;
+
+	nvmem-cell-names = "part_number_otp",
+			   "monotonic_otp",
+			   "nand_otp",
+			   "uid_otp",
+			   "package_otp",
+			   "hw2_otp",
+			   "board_id";
+};
+
+&rtc {
+	status = "okay";
+	secure-status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_mx>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	status = "okay";
+};
+
+&pinctrl {
+	uart4_pins_mx: uart4-pins-mx {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 11, AF6)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+};
Index: arm-trusted-firmware.git/fdts/stm32mp15-qsmp.dtsi
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp15-qsmp.dtsi
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) Lothar Waßmann <LW@KARO-electronics.de>
+ */
+
+#include "stm32mp157c.dtsi"
+#include "stm32mp157cac-pinctrl.dtsi"
+#include "stm32mp15-karo.dtsi"
+
+/ {
+	aliases {
+		mmc0 = &sdmmc2;
+		mmc1 = &sdmmc1;
+		mmc2 = &sdmmc3;
+		serial0 = &uart4;
+		serial1 = &usart2;
+		serial2 = &usart3;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+	};
+
+	sram: sram@10050000 {
+		compatible = "mmio-sram";
+		reg = <0x10050000 0x10000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0x10050000 0x10000>;
+
+		dma_pool: dma_pool@0 {
+			reg = <0x0 0x10000>;
+			pool;
+		};
+	};
+
+	usb_phy_tuning: usb-phy-tuning {
+		st,hs-dc-level = <2>;
+		st,fs-rftime-tuning;
+		st,hs-rftime-reduction;
+		st,hs-current-trim = <15>;
+		st,hs-impedance-trim = <1>;
+		st,squelch-level = <3>;
+		st,hs-rx-offset = <2>;
+		st,no-lsfs-sc;
+	};
+};
+
+&bsec {
+	status = "okay";
+	secure-status = "okay";
+};
+
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&rcc {
+	st,csi-cal;
+	st,hsi-cal;
+	st,cal-sec = <60>;
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_PLL12_HSE
+		CLK_PLL3_HSE
+		CLK_PLL4_HSE
+		CLK_RTC_LSI
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+	>;
+	st,clkdiv = <
+		1	/* MPU */
+		0	/* AXI */
+		0	/* MCU */
+		1	/* APB1 */
+		1	/* APB2 */
+		1	/* APB3 */
+		1	/* APB4 */
+		2	/* APB5 */
+		0	/* RTC */
+		0	/* MCO1 */
+		0	/* MCO2 */
+	>;
+	st,pkcs = <
+		CLK_CKPER_HSE
+		CLK_QSPI_ACLK
+		CLK_ETH_PLL4P
+		CLK_SDMMC12_HCLK6
+		CLK_STGEN_HSI
+		CLK_USBPHY_HSE
+		CLK_SPI2S1_DISABLED
+		CLK_SPI2S23_DISABLED
+		CLK_SPI45_HSI
+		CLK_SPI6_HSI
+		CLK_I2C46_PCLK5
+		CLK_SDMMC3_DISABLED
+		CLK_USBO_USBPHY
+		CLK_ADC_CKPER
+		CLK_CEC_DISABLED
+		CLK_I2C12_PCLK1
+		CLK_I2C35_PCLK1
+		CLK_UART1_DISABLED
+		CLK_UART24_HSI
+		CLK_UART35_HSI
+		CLK_UART6_DISABLED
+		CLK_UART78_DISABLED
+		CLK_SPDIF_DISABLED
+		CLK_FDCAN_HSE
+		CLK_SAI1_DISABLED
+		CLK_SAI2_PLL4Q
+		CLK_SAI3_DISABLED
+		CLK_SAI4_DISABLED
+		CLK_LPTIM1_PCLK1
+		CLK_LPTIM23_DISABLED
+		CLK_LPTIM45_DISABLED
+		CLK_RNG1_LSI
+	>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	secure-status = "okay";
+
+	st,pll@0 {
+		reg = <0>;
+		cfg = <2 80 0 1 1 1>;
+		frac = <2048>;
+	};
+
+	st,pll@1 {
+		reg = <1>;
+		cfg = <2 65 1 1 0 5>;
+		frac = <5120>;
+	};
+
+	st,pll@2 {
+		reg = <2>;
+		cfg = <1 33 1 16 36 1>;
+		frac = <6660>;
+	};
+
+	st,pll@3 {
+		reg = <3>;
+		cfg = <1 49 11 6 7 3>;
+	};
+};
+
+&rtc {
+	status = "okay";
+	secure-status = "okay";
+};
+
+&sdmmc2 {
+	/* eMMC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_pins_mx>;
+	bus-width = <4>;
+	no-sd;
+	no-sdio;
+//	st,neg-edge;
+	non-removable;
+	no-1-8-v;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_mx>;
+	status = "okay";
+};
+
+&usart2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart2_pins_mx>;
+	pinctrl-1 = <&usart2_sleep_pins_mx>;
+	status = "okay";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart3_pins_mx>;
+	pinctrl-1 = <&usart3_sleep_pins_mx>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	status = "okay";
+};
+
+&pwr {
+	system_suspend_supported_soc_modes = <
+		STM32_PM_CSLEEP_RUN
+		STM32_PM_CSTOP_ALLOW_LP_STOP
+		STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
+	>;
+	system_off_soc_mode = <STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF>;
+};
+
+&pinctrl {
+	sdmmc2_pins_mx: sdmmc2-pins-mx {
+		pins1 {
+			pinmux = <
+				  STM32_PINMUX('B', 14, AF9)	/* SDMMC2_D0 */
+				  STM32_PINMUX('B', 15, AF9)	/* SDMMC2_D1 */
+				  STM32_PINMUX('B', 3, AF9)	/* SDMMC2_D2 */
+				  STM32_PINMUX('B', 4, AF9)	/* SDMMC2_D3 */
+				  STM32_PINMUX('A', 8, AF9)	/* SDMMC2_D4 */
+				  STM32_PINMUX('B', 9, AF9)	/* SDMMC2_D5 */
+				  STM32_PINMUX('C', 6, AF9)	/* SDMMC2_D6 */
+				  STM32_PINMUX('C', 7, AF9)	/* SDMMC2_D7 */
+				  STM32_PINMUX('G', 6, AF10)	/* SDMMC2_CMD */
+			>;
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	uart4_pins_mx: uart4-pins-mx {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
+			bias-pull-up;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 11, AF6)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	usart2_pins_mx: usart2-pins-mx {
+		pins1 {
+			pinmux = <
+				  STM32_PINMUX('D', 3, AF7) /* USART2_CTS */
+				  STM32_PINMUX('D', 6, AF7) /* USART2_RX */
+			>;
+			bias-disable;
+		};
+
+		pins2 {
+			pinmux = <
+				  STM32_PINMUX('D', 4, AF7) /* USART2_RTS */
+				  STM32_PINMUX('D', 5, AF7) /* USART2_TX */
+			>;
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	usart2_sleep_pins_mx: usart2-sleep-pins-mx {
+		pins {
+			pinmux = <
+				  STM32_PINMUX('D', 3, ANALOG) /* USART2_CTS */
+				  STM32_PINMUX('D', 4, ANALOG) /* USART2_RTS */
+				  STM32_PINMUX('D', 5, ANALOG) /* USART2_TX */
+				  STM32_PINMUX('D', 6, ANALOG) /* USART2_RX */
+			>;
+		};
+	};
+
+	usart3_pins_mx: usart3-pins-mx {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 10, AF7)>; /* USART3_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 12, AF8)>; /* USART3_RX */
+			bias-disable;
+		};
+	};
+
+	usart3_sleep_pins_mx: usart3-sleep-pins-mx {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, ANALOG) /* USART3_TX */
+				  STM32_PINMUX('B', 12, ANALOG) /* USART3_RX */
+			>;
+		};
+	};
+};
Index: arm-trusted-firmware.git/fdts/stm32mp15-txmp.dtsi
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp15-txmp.dtsi
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) Lothar Waßmann <LW@KARO-electronics.de>
+ */
+
+#include "stm32mp157c.dtsi"
+#include "stm32mp157cab-pinctrl.dtsi"
+#include "stm32mp15-karo.dtsi"
+
+&rcc {
+	st,csi-cal;
+	st,hsi-cal;
+	st,cal-sec = <60>;
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_PLL12_HSE
+		CLK_PLL3_HSE
+		CLK_PLL4_HSE
+		CLK_RTC_LSI
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+	>;
+	st,clkdiv = <
+		1	/* MPU */
+		0	/* AXI */
+		0	/* MCU */
+		1	/* APB1 */
+		1	/* APB2 */
+		1	/* APB3 */
+		1	/* APB4 */
+		2	/* APB5 */
+		0	/* RTC */
+		0	/* MCO1 */
+		0	/* MCO2 */
+	>;
+	st,pkcs = <
+		CLK_CKPER_HSE
+		CLK_QSPI_ACLK
+		CLK_ETH_PLL4P
+		CLK_SDMMC12_HCLK6
+		CLK_STGEN_HSI
+		CLK_USBPHY_HSE
+		CLK_SPI2S1_DISABLED
+		CLK_SPI2S23_PLL4P
+		CLK_SPI45_DISABLED
+		CLK_SPI6_DISABLED
+		CLK_I2C46_PCLK5
+		CLK_SDMMC3_HCLK2
+		CLK_USBO_USBPHY
+		CLK_ADC_CKPER
+		CLK_CEC_DISABLED
+		CLK_I2C12_DISABLED
+		CLK_I2C35_PCLK1
+		CLK_UART1_DISABLED
+		CLK_UART24_HSI
+		CLK_UART35_HSI
+		CLK_UART6_DISABLED
+		CLK_UART78_HSI
+		CLK_SPDIF_DISABLED
+		CLK_FDCAN_HSE
+		CLK_SAI1_DISABLED
+		CLK_SAI2_PLL4Q
+		CLK_SAI3_DISABLED
+		CLK_SAI4_DISABLED
+		CLK_LPTIM1_PLL4P
+		CLK_LPTIM23_DISABLED
+		CLK_LPTIM45_DISABLED
+		CLK_RNG1_LSI
+	>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	secure-status = "okay";
+
+	st,pll@0 {
+		reg = <0>;
+		cfg = <2 80 0 1 1 1>;
+		frac = <2048>;
+	};
+
+	st,pll@1 {
+		reg = <1>;
+		cfg = <2 65 1 1 0 5>;
+		frac = <5120>;
+	};
+
+	st,pll@2 {
+		reg = <2>;
+		cfg = <1 33 1 16 36 1>;
+		frac = <6660>;
+	};
+
+	st,pll@3 {
+		reg = <3>;
+		cfg = <1 49 11 6 7 3>;
+	};
+};
+
+&sdmmc2 {
+	/* eMMC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_pins_mx>;
+	bus-width = <4>;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	non-removable;
+	status = "okay";
+};
+
+&pinctrl {
+	sdmmc2_pins_mx: sdmmc2-pins-mx {
+		pins1 {
+			pinmux = <
+				  STM32_PINMUX('B', 3, AF9)	/* SDMMC2_D2 */
+				  STM32_PINMUX('B', 4, AF9)	/* SDMMC2_D3 */
+				  STM32_PINMUX('B', 14, AF9)	/* SDMMC2_D0 */
+				  STM32_PINMUX('B', 15, AF9)	/* SDMMC2_D1 */
+				  STM32_PINMUX('G', 6, AF10)	/* SDMMC2_CMD */
+			>;
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+};
Index: arm-trusted-firmware.git/fdts/stm32mp151a-qsmp-1510.dts
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp151a-qsmp-1510.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: STM32CubeMX code generation for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp151a-qsmp.h"
+#include "stm32mp15-qsmp.dtsi"
+
+/ {
+	model = "Ka-Ro electronics GmbH QSMP-1510 solder-in module";
+	compatible = "st,stm32mp157c-qsmp-1510", "st,stm32mp151";
+};
+
+&sdmmc2 {
+	status = "disabled";
+};
Index: arm-trusted-firmware.git/fdts/stm32mp151a-qsmp.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp151a-qsmp.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ *
+ * Copyright (C) 2015-2018, STMicroelectronics - All Rights Reserved
+ *
+ */
+
+/*
+ * File generated by STMicroelectronics STM32CubeMX DDR Tool for MPUs
+ * DDR type: DDR3 / DDR3L
+ * DDR width: 16bits
+ * DDR density: 2Gb
+ * System frequency: 533000Khz
+ * Relaxed Timing Mode: false
+ * Address mapping type: RBC
+ *
+ * Save Date: 2019.08.16, save Time: 17:02:41
+ */
+
+#define DDR_MEM_NAME	"DDR3L-1066/777 bin F 1x2Gb 533MHz"
+#define DDR_MEM_SIZE	0x10000000
+#define DDR_ADDRMAP6	0x0F0F0606
+
+#include "stm32mp15-mx.h"
Index: arm-trusted-firmware.git/plat/karo/txmp/bl2_plat_setup.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/bl2_plat_setup.c
@@ -0,0 +1,602 @@
+/*
+ * Copyright (c) 2015-2020, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <assert.h>
+#include <bl_common.h>
+#include <boot_api.h>
+#include <bsec.h>
+#include <debug.h>
+#include <delay_timer.h>
+#include <desc_image_load.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/reset/stm32mp1-resets.h>
+#include <errno.h>
+#include <generic_delay_timer.h>
+#include <mmio.h>
+#include <optee_utils.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <stm32_console.h>
+#include <stm32_gpio.h>
+#include <stm32_iwdg.h>
+#include <stm32mp_auth.h>
+#include <stm32mp_clkfunc.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp_reset.h>
+#include <stm32mp1xx_hal_uart.h>
+#include <stm32mp1_clk.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_dbgmcu.h>
+#include <stm32mp1_private.h>
+#include <stm32mp1_pwr.h>
+#include <stm32mp1_ram.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+#include <stpmic1.h>
+#include <string.h>
+#include <xlat_tables_v2.h>
+
+#define PWRLP_TEMPO_5_HSI	5
+
+static struct console_stm32 console;
+static enum boot_device_e boot_device = BOOT_DEVICE_BOARD;
+static struct auth_ops stm32mp_auth_ops;
+static bool wakeup_standby;
+
+static void print_reset_reason(void)
+{
+	uint32_t rstsr = mmio_read_32(stm32mp_rcc_base() + RCC_MP_RSTSCLRR);
+
+	if (rstsr == 0U) {
+		WARN("Reset reason unknown\n");
+		return;
+	}
+
+	INFO("Reset reason (0x%x):\n", rstsr);
+
+	if ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) == 0U) {
+		if ((rstsr & RCC_MP_RSTSCLRR_STDBYRSTF) != 0U) {
+			INFO("System exits from STANDBY\n");
+			return;
+		}
+
+		if ((rstsr & RCC_MP_RSTSCLRR_CSTDBYRSTF) != 0U) {
+			INFO("MPU exits from CSTANDBY\n");
+			return;
+		}
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_PORRSTF) != 0U) {
+		INFO("  Power-on Reset (rst_por)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_BORRSTF) != 0U) {
+		INFO("  Brownout Reset (rst_bor)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_MCSYSRSTF) != 0U) {
+		if ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) != 0U)
+			INFO("  System reset generated by MCU (MCSYSRST)\n");
+		else
+			INFO("  Local reset generated by MCU (MCSYSRST)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_MPSYSRSTF) != 0U) {
+		INFO("  System reset generated by MPU (MPSYSRST)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_HCSSRSTF) != 0U) {
+		INFO("  Reset due to a clock failure on HSE\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_IWDG1RSTF) != 0U) {
+		INFO("  IWDG1 Reset (rst_iwdg1)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_IWDG2RSTF) != 0U) {
+		INFO("  IWDG2 Reset (rst_iwdg2)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_MPUP0RSTF) != 0U) {
+		INFO("  MPU Processor 0 Reset\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_MPUP1RSTF) != 0U) {
+		INFO("  MPU Processor 1 Reset\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) != 0U) {
+		INFO("  Pad Reset from NRST\n");
+		return;
+	}
+
+	if ((rstsr & RCC_MP_RSTSCLRR_VCORERSTF) != 0U) {
+		INFO("  Reset due to a failure of VDD_CORE\n");
+		return;
+	}
+
+	ERROR("  Unidentified reset reason\n");
+}
+
+enum boot_device_e get_boot_device(void)
+{
+	return boot_device;
+}
+
+void bl2_el3_early_platform_setup(u_register_t arg0,
+				  u_register_t arg1 __unused,
+				  u_register_t arg2 __unused,
+				  u_register_t arg3 __unused)
+{
+	stm32mp_save_boot_ctx_address(arg0);
+}
+
+void bl2_platform_setup(void)
+{
+	int ret;
+
+	/*
+	 * Map DDR non cacheable during its initialisation to avoid
+	 * speculative loads before accesses are fully setup.
+	 */
+	mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
+				STM32MP_DDR_MAX_SIZE,
+				MT_NON_CACHEABLE | MT_RW | MT_NS);
+
+	ret = stm32mp1_ddr_probe();
+	if (ret < 0) {
+		ERROR("Invalid DDR init: error %d\n", ret);
+		panic();
+	}
+
+	mmap_remove_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_MAX_SIZE);
+
+#ifdef AARCH32_SP_OPTEE
+	INFO("BL2 runs OP-TEE setup\n");
+
+	/* Map non secure DDR for BL33 load, now with cacheable attribute */
+	mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
+				dt_get_ddr_size()  - STM32MP_DDR_S_SIZE -
+				STM32MP_DDR_SHMEM_SIZE,
+				MT_MEMORY | MT_RW | MT_NS);
+
+	mmap_add_dynamic_region(STM32MP_DDR_BASE + dt_get_ddr_size() -
+				STM32MP_DDR_S_SIZE - STM32MP_DDR_SHMEM_SIZE,
+				STM32MP_DDR_BASE + dt_get_ddr_size() -
+				STM32MP_DDR_S_SIZE - STM32MP_DDR_SHMEM_SIZE,
+				STM32MP_DDR_S_SIZE,
+				MT_MEMORY | MT_RW | MT_SECURE);
+
+	/* Initialize tzc400 after DDR initialization */
+	stm32mp1_security_setup();
+#else
+	INFO("BL2 runs SP_MIN setup\n");
+
+	/* Map non secure DDR for BL33 load, now with cacheable attribute */
+	mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
+				dt_get_ddr_size(),
+				MT_MEMORY | MT_RW | MT_NS);
+#endif
+}
+
+static void update_monotonic_counter(void)
+{
+	uint32_t version;
+	uint32_t otp;
+
+	CASSERT(STM32_TF_VERSION <= MAX_MONOTONIC_VALUE,
+		assert_stm32mp1_monotonic_counter_reach_max);
+
+	/* Check if monotonic counter needs to be incremented */
+	if (stm32_get_otp_index(MONOTONIC_OTP, &otp, NULL) != 0) {
+		panic();
+	}
+
+	if (stm32_get_otp_value(MONOTONIC_OTP, &version) != 0) {
+		panic();
+	}
+
+	if ((version + 1U) < BIT(STM32_TF_VERSION)) {
+		uint32_t result;
+
+		/* Need to increment the monotonic counter */
+		version = BIT(STM32_TF_VERSION) - 1U;
+
+		result = bsec_program_otp(version, otp);
+		if (result != BSEC_OK) {
+			ERROR("BSEC: MONOTONIC_OTP program Error %i\n",
+			      result);
+			panic();
+		}
+		INFO("Monotonic counter has been incremented value 0x%x\n",
+		     version);
+	}
+}
+
+static void initialize_clock(void)
+{
+	uint32_t voltage_mv = 0U;
+	uint32_t freq_khz = 0U;
+	int ret;
+
+	if (wakeup_standby) {
+		stm32_get_pll1_settings_from_context();
+	}
+
+	/*
+	 * If no pre-defined PLL1 settings in DT, find the highest frequency
+	 * in the OPP table (in DT, compatible with plaform capabilities, or
+	 * in structure restored in RAM), and set related VDDCORE voltage.
+	 * If PLL1 settings found in DT, we consider VDDCORE voltage in DT is
+	 * consistent with it.
+	 */
+	if (!fdt_is_pll1_predefined()) {
+		if (wakeup_standby) {
+			ret = stm32mp1_clk_get_maxfreq_opp(&freq_khz,
+							   &voltage_mv);
+		} else {
+			ret = dt_get_max_opp_freqvolt(&freq_khz, &voltage_mv);
+		}
+
+		if (ret != 0) {
+			panic();
+		}
+	}
+
+	if (stm32mp1_clk_init(freq_khz) < 0) {
+		panic();
+	}
+}
+
+void bl2_el3_plat_arch_setup(void)
+{
+	int32_t result;
+	struct dt_node_info dt_uart_info;
+	const char *board_model;
+	boot_api_context_t *boot_context = stm32mp_get_boot_ctx_address();
+	uint32_t clk_rate;
+	uintptr_t pwr_base;
+	uintptr_t rcc_base;
+	uint32_t bkpr_core1_magic =
+		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+	uint32_t bkpr_core1_addr =
+		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+#if SEPARATE_CODE_AND_RODATA
+	mmap_add_region(BL_RO_DATA_BASE, BL_RO_DATA_BASE,
+			BL_RO_DATA_LIMIT - BL_RO_DATA_BASE,
+			MT_RO_DATA | MT_SECURE);
+#endif
+
+#ifdef AARCH32_SP_OPTEE
+	mmap_add_region(STM32MP_OPTEE_BASE, STM32MP_OPTEE_BASE,
+			STM32MP_OPTEE_SIZE,
+			MT_MEMORY | MT_RW | MT_SECURE);
+#else
+	/* Prevent corruption of preloaded BL32 */
+	mmap_add_region(BL32_BASE, BL32_BASE,
+			BL32_LIMIT - BL32_BASE,
+			MT_RO_DATA | MT_SECURE);
+#endif
+	/* Prevent corruption of preloaded Device Tree */
+	mmap_add_region(DTB_BASE, DTB_BASE,
+			DTB_LIMIT - DTB_BASE,
+			MT_RO_DATA | MT_SECURE);
+
+	configure_mmu();
+
+	if (dt_open_and_check() < 0) {
+		panic();
+	}
+
+	pwr_base = stm32mp_pwr_base();
+	rcc_base = stm32mp_rcc_base();
+
+	/* Clear Stop Request bits to correctly manage low-power exit */
+	mmio_write_32(rcc_base + RCC_MP_SREQCLRR,
+		      RCC_MP_SREQCLRR_STPREQ_P0 | RCC_MP_SREQCLRR_STPREQ_P1);
+
+	/*
+	 * Disable the backup domain write protection.
+	 * The protection is enable at each reset by hardware
+	 * and must be disabled by software.
+	 */
+	mmio_setbits_32(pwr_base + PWR_CR1, PWR_CR1_DBP);
+
+	while ((mmio_read_32(pwr_base + PWR_CR1) & PWR_CR1_DBP) == 0U) {
+		;
+	}
+
+	/*
+	 * Configure Standby mode available for MCU by default
+	 * and allow to switch in standby SoC in all case
+	 */
+	mmio_setbits_32(pwr_base + PWR_MCUCR, PWR_MCUCR_PDDS);
+
+	if (bsec_probe() != 0) {
+		panic();
+	}
+
+	/* Reset backup domain on cold boot cases */
+	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCSRC_MASK) == 0U) {
+		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+
+		while (!(mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_VSWRST)) {
+			;
+		}
+
+		mmio_clrbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+	}
+
+	/* Wait 5 HSI periods before re-enabling PLLs after STOP modes */
+	mmio_clrsetbits_32(rcc_base + RCC_PWRLPDLYCR,
+			   RCC_PWRLPDLYCR_PWRLP_DLY_MASK,
+			   PWRLP_TEMPO_5_HSI);
+
+	/* Disable retention and backup RAM content after standby */
+	mmio_clrbits_32(pwr_base + PWR_CR2, PWR_CR2_BREN | PWR_CR2_RREN);
+
+	/* Disable MCKPROT */
+	mmio_clrbits_32(rcc_base + RCC_TZCR, RCC_TZCR_MCKPROT);
+
+	/* Enable BKP Register protection */
+	mmio_write_32(TAMP_SMCR,
+		      TAMP_BKP_SEC_NUMBER << TAMP_BKP_SEC_WDPROT_SHIFT |
+		      TAMP_BKP_SEC_NUMBER << TAMP_BKP_SEC_RWDPROT_SHIFT);
+
+	if ((boot_context->boot_action !=
+	     BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY) &&
+	    (boot_context->boot_action !=
+	     BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY)) {
+		mmio_write_32(bkpr_core1_addr, 0);
+		mmio_write_32(bkpr_core1_magic, 0);
+	}
+
+	wakeup_standby = (mmio_read_32(bkpr_core1_addr) != 0U);
+
+	generic_delay_timer_init();
+
+#ifdef STM32MP_USB
+	if (boot_context->boot_interface_selected ==
+	    BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB) {
+		boot_device = BOOT_DEVICE_USB;
+	}
+#endif
+
+#if STM32MP_UART_PROGRAMMER
+	/* Disable programmer UART before changing clock tree */
+	if (boot_context->boot_interface_selected ==
+	    BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) {
+		uintptr_t uart_prog_addr =
+			get_uart_address(boot_context->boot_interface_instance);
+
+		((USART_TypeDef *)uart_prog_addr)->CR1 &= ~USART_CR1_UE;
+	}
+#endif
+
+	if (stm32mp1_clk_probe() < 0) {
+		panic();
+	}
+
+	initialize_clock();
+
+	stm32mp1_syscfg_init();
+
+	result = dt_get_stdout_uart_info(&dt_uart_info);
+
+	if ((result <= 0) ||
+	    (dt_uart_info.status == 0U) ||
+#if STM32MP_UART_PROGRAMMER
+	    ((boot_context->boot_interface_selected ==
+	      BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) &&
+	     (get_uart_address(boot_context->boot_interface_instance) ==
+	      dt_uart_info.base)) ||
+#endif
+	    (dt_uart_info.clock < 0) ||
+	    (dt_uart_info.reset < 0)) {
+		goto skip_console_init;
+	}
+
+	if (dt_set_stdout_pinctrl() != 0) {
+		goto skip_console_init;
+	}
+
+	if (dt_uart_info.status == DT_DISABLED) {
+		panic();
+	} else if (dt_uart_info.status == DT_SECURE) {
+		stm32mp_register_secure_periph_iomem(dt_uart_info.base);
+	} else {
+		stm32mp_register_non_secure_periph_iomem(dt_uart_info.base);
+	}
+
+	stm32mp_clk_enable((unsigned long)dt_uart_info.clock);
+
+	stm32mp_reset_assert((uint32_t)dt_uart_info.reset);
+	udelay(2);
+	stm32mp_reset_deassert((uint32_t)dt_uart_info.reset);
+	mdelay(1);
+
+	clk_rate = stm32mp_clk_get_rate((unsigned long)dt_uart_info.clock);
+
+	if (console_stm32_register(dt_uart_info.base, clk_rate,
+				   STM32MP_UART_BAUDRATE, &console) == 0) {
+		panic();
+	}
+
+	stm32mp_print_cpuinfo();
+	board_model = dt_get_board_model();
+	if (board_model != NULL) {
+		NOTICE("Model: %s\n", board_model);
+	}
+	stm32mp_print_boardinfo();
+
+	if (boot_context->auth_status != BOOT_API_CTX_AUTH_NO) {
+		NOTICE("%s\n", (boot_context->auth_status ==
+				BOOT_API_CTX_AUTH_FAILED) ?
+		       "Boot authentication Failed" :
+		       "Boot authentication Success");
+	}
+
+skip_console_init:
+
+	/* Initialize IWDG Status, no startup */
+	if (stm32_iwdg_init() < 0) {
+		panic();
+	}
+
+	/* Reload watchdog */
+	stm32_iwdg_refresh(IWDG2_INST);
+
+	result = stm32mp1_dbgmcu_freeze_iwdg2();
+	if (result != 0) {
+		INFO("IWDG2 freeze error : %i\n", result);
+	}
+
+	if (stm32_save_boot_interface(boot_context->boot_interface_selected,
+				      boot_context->boot_interface_instance)) {
+		ERROR("Cannot save boot interface\n");
+	}
+
+	stm32mp_auth_ops.check_key =
+		boot_context->p_bootrom_ext_service_ecdsa_check_key;
+	stm32mp_auth_ops.verify_signature =
+		boot_context->p_bootrom_ext_service_ecdsa_verify_signature;
+
+	stm32mp_init_auth(&stm32mp_auth_ops);
+
+	stm32mp1_arch_security_setup();
+
+	print_reset_reason();
+
+	update_monotonic_counter();
+
+	stm32mp_io_setup();
+}
+
+#if defined(AARCH32_SP_OPTEE)
+static void set_mem_params_info(entry_point_info_t *ep_info,
+				image_info_t *unpaged, image_info_t *paged)
+{
+	uintptr_t bl32_ep = 0;
+
+	/* Use the default dram setup if no valid ep found */
+	if (get_optee_header_ep(ep_info, &bl32_ep) &&
+	    (bl32_ep >= STM32MP_OPTEE_BASE) &&
+	    (bl32_ep < (STM32MP_OPTEE_BASE + STM32MP_OPTEE_SIZE))) {
+		assert((STM32MP_OPTEE_BASE >= BL2_LIMIT) ||
+		       ((STM32MP_OPTEE_BASE + STM32MP_OPTEE_SIZE) <= BL2_BASE));
+
+		unpaged->image_base = STM32MP_OPTEE_BASE;
+		unpaged->image_max_size = STM32MP_OPTEE_SIZE;
+	} else {
+		unpaged->image_base = STM32MP_DDR_BASE + dt_get_ddr_size() -
+				      STM32MP_DDR_S_SIZE -
+				      STM32MP_DDR_SHMEM_SIZE;
+		unpaged->image_max_size = STM32MP_DDR_S_SIZE;
+	}
+	paged->image_base = STM32MP_DDR_BASE + dt_get_ddr_size() -
+			    STM32MP_DDR_S_SIZE - STM32MP_DDR_SHMEM_SIZE;
+	paged->image_max_size = STM32MP_DDR_S_SIZE;
+}
+#endif
+
+/*******************************************************************************
+ * This function can be used by the platforms to update/use image
+ * information for given `image_id`.
+ ******************************************************************************/
+int bl2_plat_handle_post_image_load(unsigned int image_id)
+{
+	int err = 0;
+	bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(image_id);
+#if defined(AARCH32_SP_OPTEE)
+	bl_mem_params_node_t *bl32_mem_params;
+	bl_mem_params_node_t *pager_mem_params;
+	bl_mem_params_node_t *paged_mem_params;
+#endif
+
+	assert(bl_mem_params != NULL);
+
+	switch (image_id) {
+	case BL32_IMAGE_ID:
+#if defined(AARCH32_SP_OPTEE)
+		pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+		assert(pager_mem_params);
+
+		paged_mem_params = get_bl_mem_params_node(BL32_EXTRA2_IMAGE_ID);
+		assert(paged_mem_params);
+
+		bl_mem_params->ep_info.pc =
+					bl_mem_params->image_info.image_base;
+
+		set_mem_params_info(&bl_mem_params->ep_info,
+				    &pager_mem_params->image_info,
+				    &paged_mem_params->image_info);
+
+		err = parse_optee_header(&bl_mem_params->ep_info,
+					 &pager_mem_params->image_info,
+					 &paged_mem_params->image_info);
+		if (err) {
+			ERROR("OPTEE header parse error.\n");
+			panic();
+		}
+
+		/* Set optee boot info from parsed header data */
+		bl_mem_params->ep_info.pc =
+				pager_mem_params->image_info.image_base;
+		bl_mem_params->ep_info.args.arg0 =
+				paged_mem_params->image_info.image_base;
+		bl_mem_params->ep_info.args.arg1 = 0; /* Unused */
+		bl_mem_params->ep_info.args.arg2 = 0; /* No DT supported */
+#endif
+		break;
+
+	case BL33_IMAGE_ID:
+#ifdef AARCH32_SP_OPTEE
+		bl32_mem_params = get_bl_mem_params_node(BL32_IMAGE_ID);
+		assert(bl32_mem_params);
+		bl32_mem_params->ep_info.lr_svc = bl_mem_params->ep_info.pc;
+#else
+		/* BL33 expects to receive : TBD */
+		bl_mem_params->ep_info.args.arg0 = 0;
+		bl_mem_params->ep_info.spsr =
+			SPSR_MODE32(MODE32_svc, SPSR_T_ARM, SPSR_E_LITTLE,
+				    DISABLE_ALL_EXCEPTIONS);
+#endif
+		flush_dcache_range(bl_mem_params->image_info.image_base,
+				   bl_mem_params->image_info.image_max_size);
+		break;
+
+#ifdef AARCH32_SP_OPTEE
+	case BL32_EXTRA1_IMAGE_ID:
+	case BL32_EXTRA2_IMAGE_ID:
+		clean_dcache_range(bl_mem_params->image_info.image_base,
+				   bl_mem_params->image_info.image_max_size);
+		break;
+#endif
+
+	default:
+		err = -1;
+		break;
+	}
+
+	return err;
+}
+
Index: arm-trusted-firmware.git/plat/karo/txmp/include/boot_api.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/boot_api.h
@@ -0,0 +1,632 @@
+/*
+ * Copyright (c) 2017-2018, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BOOT_API_H
+#define BOOT_API_H
+
+#include <stdint.h>
+#include <stdio.h>
+
+/*
+ * Exported constants
+ */
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Possible value of boot context field 'boot_action'
+ */
+/* Boot action is Process Cold Boot */
+#define BOOT_API_CTX_BOOT_ACTION_COLD_BOOT_PROCESS		0x09U
+/* Boot action is Process Wakeup from CSTANDBY */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY		0x0AU
+/* Boot action is Process Wakeup from STANDBY  */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY			0x0BU
+/* Boot action is Process Engineering Boot */
+#define BOOT_API_CTX_BOOT_ACTION_ENGI_BOOT			0x0CU
+
+#define BOOT_API_CTX_BOOT_ACTION_MPU_CORE0_RESET_PROCESS	0x0F
+
+/*
+ * Possible value of boot context field 'stby_exit_status'
+ */
+
+/* The boot reason is not a STANDBY Exit reason */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_NO_STANDBY                0x00
+
+/* STANDBY Exit with MPU_BEN=1, MCU_BEN=0 */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MPU_ONLY             0x01
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MPU will go for cold boot
+ * MCU restarted by bootROM
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES            0x02
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MPU will go for cold boot
+ * but MCU restart aborted (code integrity check) : have not been restarted
+ * by bootROM
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES_MCU_ABT    0x03
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MPU gone to CSTANDBY,
+ * MCU restarted correctly by bootROM
+ * This value should never be read by FSBL, because not executed in that case
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY             0x04
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MCU restart aborted
+ * due code integrity check, then MPU will go for cold boot despite
+ * was not planned initially
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY_MCU_ABT     0x05
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MCU restart aborted
+ * due to MCU security perimeter issue
+ */
+#define \
+BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES_MCU_ABT_SEC_PERIMETER_ISSUE 0x06
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MCU restart aborted
+ * due to MCU security perimeter issue, then MPU will go for cold boot
+ * despite was not planned initially
+ */
+#define \
+BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY_MCU_ABT_SEC_PERIMETER_ISSUE	0x07
+
+/*
+ * Possible value of boot context field 'cstby_exit_status'
+ */
+/* The boot reason is not a CSTANDBY Exit reason */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_NO_CSTBY			0x00
+/* CSTANDBY Exit with MCU detected as Not running */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_MCU_NOT_RUNNING		0x01
+/* CSTANDBY Exit with MCU detected as Running  */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_MCU_RUNNING		0x02
+
+/*
+ * Possible value of boot context field 'auth_status'
+ */
+ /* No authentication done */
+#define BOOT_API_CTX_AUTH_NO					0x00
+ /* Authentication done and failed */
+#define BOOT_API_CTX_AUTH_FAILED				0x01
+ /* Authentication done and success */
+#define BOOT_API_CTX_AUTH_SUCCESS				0x02
+
+/*
+ * Possible value of boot context field 'boot_interface_sel'
+ */
+
+/* Value of field 'boot_interface_sel' when no boot occurred */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_NO			0x0U
+
+/* Boot occurred on SD */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_SD		0x1U
+
+/* Boot occurred on EMMC */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC		0x2U
+
+/* boot occurred on NAND FMC */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC		0x3U
+
+/* boot occurred on QSPI NOR */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI		0x4U
+
+/* boot occurred on UART  */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART		0x5U
+
+/* boot occurred on USB */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB		0x6U
+
+/* boot occurred on NAND QSPI */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI		0x7U
+
+/**
+ * @brief  Possible value of boot context field 'EmmcXferStatus'
+ */
+/*
+ * Possible value of boot context field 'emmc_xfer_status'
+ */
+#define BOOT_API_CTX_EMMC_XFER_STATUS_NOT_STARTED			0x0U
+#define BOOT_API_CTX_EMMC_XFER_STATUS_DATAEND_DETECTED			0x1U
+#define BOOT_API_CTX_EMMC_XFER_STATUS_XFER_OVERALL_TIMEOUT_DETECTED	0x2U
+#define BOOT_API_CTX_EMMC_XFER_STATUS_XFER_DATA_TIMEOUT			0x3U
+
+/*
+ * Possible value of boot context field 'emmc_error_status'
+ */
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_NONE                     0x0U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_CMD_TIMEOUT              0x1U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_ACK_TIMEOUT              0x2U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_DATA_CRC_FAIL            0x3U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_NOT_ENOUGH_BOOT_DATA_RX  0x4U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_NOT_FOUND         0x5U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_SIZE_ZERO         0x6U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_IMAGE_NOT_COMPLETE       0x7U
+
+/* Definitions relative to 'p_rom_version_info->platform_type_ver' field */
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_IC_EMU_FPGA           0xAA
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_FPGA_ONLY             0xBB
+
+/* Image Header related definitions */
+
+/* Definition of header version */
+#define BOOT_API_HEADER_VERSION					0x00010000U
+
+/*
+ * Magic number used to detect header in memory
+ * Its value must be 'S' 'T' 'M' 0x32, i.e 0x324D5453 as field
+ * 'bootapi_image_header_t.magic'
+ * This identifies the start of a boot image.
+ */
+#define BOOT_API_IMAGE_HEADER_MAGIC_NB				0x324D5453U
+
+/* Definitions related to Authentication used in image header structure */
+#define BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES			64
+#define BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES			64
+#define BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES			32
+
+/* Possible values of the field 'boot_api_image_header_t.ecc_algo_type' */
+#define BOOT_API_ECDSA_ALGO_TYPE_P256NIST			1
+#define BOOT_API_ECDSA_ALGO_TYPE_BRAINPOOL256			2
+
+/*
+ * Cores secure magic numbers
+ * Constant to be stored in bakcup register
+ * BOOT_API_MAGIC_NUMBER_TAMP_BCK_REG_IDX
+ */
+#define BOOT_API_A7_CORE0_MAGIC_NUMBER				0xCA7FACE0U
+#define BOOT_API_A7_CORE1_MAGIC_NUMBER				0xCA7FACE1U
+
+/*
+ * MCU Code Integrity Check related definitions
+ */
+
+/*
+ * Defines to identify RTC backup registers to be used for MCU code integrity
+ * check
+ */
+
+/*
+ * TAMP_BCK0R contains two bits
+ * bit 0 : wanted value of 'RCC_TZCR.TZEN'
+ * bit 1 : wanted value of 'RCC_TZCR.MCKPROT'
+ */
+
+/*
+ * TAMP_BCK0R bit position coding wanted value of 'RCC_TZCR.TZEN'
+ * trustZone aware domain enabling/disabling
+ */
+#define BOOT_API_MCIC_MCU_SECURITY_PERIMETER_TZEN_BIT			0
+
+/*
+ * TAMP_BCK0R bit position coding wanted value of 'RCC_TZCR.MCKPROT'
+ * ability of MCU to modify some clock settings in RCC
+ */
+#define BOOT_API_MCIC_MCU_SECURITY_PERIMETER_MCKPROT_BIT		1
+
+/* TAMP_BCK0R register index */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_TZEN_MCKPROT_TAMP_BCK_REG_IDX	0
+
+/*
+ * TAMP_BCK1R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR1'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR1_TAMP_BCK_REG_IDX	1
+
+/*
+ * TAMP_BCK2R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR2'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR2_TAMP_BCK_REG_IDX	2
+
+/*
+ * TAMP_BCK3R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR3'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR3_TAMP_BCK_REG_IDX	3
+
+/*
+ * TAMP_BCK4R register index
+ * This register is used to write a Magic Number in order to restart
+ * Cortex A7 Core 1 and make it execute @ branch address from TAMP_BCK5R
+ */
+#define BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX		4U
+
+/*
+ * TAMP_BCK5R register index
+ * This register is used to contain the branch address of
+ * Cortex A7 Core 1 when restarted by a TAMP_BCK4R magic number writing
+ */
+#define BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX		5U
+
+/*
+ * TAMP_BCK22R register index
+ * This register contains offset in bytes of code to Hash in RETRAM region
+ * Note : offset is intended as relative value from start of RETRAM
+ */
+#define \
+BOOT_API_MCIC_OFFSET_IN_BYTES_CODE_TO_HASH_RETRAM_TAMP_BCK_REG_IDX	22
+
+/*
+ * TAMP_BCK23R register index
+ * This register contains the size in bytes of the single consecutive region
+ * of MCU Firmware in RETRAM (Retention RAM) to hash (by SHA-256)
+ * Note : This is required as a MCU firmware Code Integrity Check (aka : MCIC)
+ * to avoid bootROM restarting MCU on a corrupted firmware
+ */
+#define \
+BOOT_API_MCIC_RETRAM_REGION_TO_HASH_IN_BYTES_TAMP_BCK_REG_IDX		23
+
+/*
+ * TAMP_BCK24R to TAMP_BCK31R register indexes
+ * Those registers contains SHA-256 digest of RETRAM MCU Firmware code between
+ * [(RETRAM_start + offset) -- (RETRAM_start + offset + size_to_hash)]
+ * in this order
+ * This is the MCU Code Integrity Check MCU Firmware signature
+ * value on 256 bits
+ */
+
+/* First TAMP_BKP index of MCU Firmware signature : ie TAMP_BCK24R */
+#define BOOT_API_MCIC_SHA_DIGEST_FIRST_TAMP_BCK_REG_IDX			24
+
+/* Last TAMP_BKP index of MCU Firmware signature : ie TAMP_BCK31R */
+#define BOOT_API_MCIC_SHA_DIGEST_LAST_TAMP_BCK_REG_IDX			31
+
+/*
+ * Possible value of boot context field 'hse_clock_value_in_hz'
+ */
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_UNDEFINED			0U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_24_MHZ			24000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_25_MHZ			25000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_26_MHZ			26000000U
+
+/*
+ * Possible value of boot context field 'boot_partition_used_toboot'
+ */
+#define BOOT_API_CTX_BOOT_PARTITION_UNDEFINED			0U
+
+/* Used FSBL1 to boot */
+#define BOOT_API_CTX_BOOT_PARTITION_FSBL1			1U
+
+/* Used FSBL2 to boot */
+#define BOOT_API_CTX_BOOT_PARTITION_FSBL2			2U
+
+/* OTP_CFG0 */
+#define BOOT_API_OTP_MODE_WORD_NB				0
+/* Closed = OTP_CFG0[6] */
+#define BOOT_API_OTP_MODE_CLOSED_BIT_POS			6
+
+/* Mapping of OTP Word and OTP bits managing SSP and useful to FSBL-SSP */
+/* OTP_CFG8 */
+#define BOOT_API_OTP_SSP_WORD_NB				8U
+/* SSP_REQ = OTP_CFG8[8] */
+#define BOOT_API_OTP_SSP_REQ_BIT_POS				8
+/* SSP_SUCCESS = OTP_CFG8[9] */
+#define BOOT_API_OTP_SSP_SUCCESS_BIT_POS			9
+
+/*
+ * Possible values of boot context field
+ * 'ssp_config_ptr_in->ssp_cmd'
+ */
+/* 'K' 'B' 'U' 'P' -.> 'PUBK' */
+#define BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK             0x4B425550
+
+/*
+ * Exported types
+ */
+
+/* SSP Configuration structure */
+typedef struct {
+	/* SSP Command*/
+	uint32_t ssp_cmd;
+	uint8_t	reserved[20];
+} boot_api_ssp_config_t;
+
+/*
+ * bootROM version information structure definition
+ * Total size = 24 bytes = 6 uint32_t
+ */
+typedef struct {
+	/* Chip Version */
+	uint32_t chip_ver;
+
+	/* Cut version within a fixed chip version */
+	uint32_t cut_ver;
+
+	/* Version of ROM Mask within a fixed cut version */
+	uint32_t rom_mask_ver;
+
+	/* Internal Version of bootROM code */
+	uint32_t bootrom_ver;
+
+	/* Version of bootROM adapted */
+	uint32_t for_chip_design_rtl_ver;
+
+	/* Restriction on compiled platform when it applies */
+	uint32_t platform_type_ver;
+
+} boot_api_rom_version_info_t;
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Boot core boot configuration structure
+ * Specifies all items of the cold boot configuration
+ * Memory and peripheral part.
+ */
+typedef struct {
+	/*
+	 * Boot interface used to boot : take values from defines
+	 * BOOT_API_CTX_BOOT_INTERFACE_SEL_XXX above
+	 */
+	uint16_t boot_interface_selected;
+	uint16_t boot_interface_instance;
+	uint32_t reserved1;
+	uint32_t nand_data_width;
+	uint32_t nand_block_size;
+	uint32_t nand_page_size;
+	uint32_t reserved2;
+	uint32_t nand_ecc_bits;
+	uint32_t nand_block_nb;
+	uint32_t reserved3[4];
+	uint32_t nor_isdual;
+	uint32_t usb_context;
+	uint32_t otp_afmux_values[3];
+	uint32_t reserved[2];
+	/*
+	 * Log to boot context, what was the kind of boot action
+	 * takes values from defines BOOT_API_BOOT_ACTION_XXX above
+	 */
+	uint32_t boot_action;
+	/*
+	 * STANDBY Exit status to be checked by FSBL in case
+	 * field 'boot_action' == BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY
+	 * take values from defines above 'BOOT_API_CTX_STBY_EXIT_STATUS_XXX'
+	 * depending on encountered situation
+	 */
+	uint32_t stby_exit_status;
+	/*
+	 * CSTANDBY Exit status to be checked by FSBL in case
+	 * boot_action == BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY
+	 * take values from defines above 'BOOT_API_CTX_CSTBY_EXIT_STATUS_XXX'
+	 * depending on encountered situation
+	 */
+	uint32_t cstby_exit_status;
+	/*
+	 * Returned authentication status : take values from defines
+	 * BOOT_API_CTX_AUTH_XXX above
+	 */
+	uint32_t auth_status;
+
+	/*
+	 *******************************************************
+	 * Pointers to bootROM External Secure Services
+	 * External Secure Services offered by bootROM
+	 * - ECDSA check key
+	 * - ECDSA verify signature
+	 * - ECDSA verify signature and go
+	 *******************************************************
+	 */
+	/*
+	 * Check if hash of p_pub_key_in is equal to hash by SHA-256
+	 * of OEM public key from OTP
+	 *
+	 *	    If no: => infinite loop in bootROM : boot failed
+	 *
+	 *          else: copy p_pub_key_in to p_pub_key_out if
+	 *          p_pub_key_out not NULL.
+	 *                and return to caller.
+	 *
+	 * @param[in]       p_pub_key_in    points to an ECDSA public key :
+	 *                  Very Important : address alignment constraint :
+	 *                  This address should be multiple of 4 bytes only.
+	 * @param[in/out]   p_pub_key_out   points to area where to store copy
+	 *                               of public key.
+	 *                  Very Important : address alignment constraint :
+	 *                  This address should be multiple of 4 bytes only.
+	 * @retval  STD_OK (0x77) or STD_NOT_OK (0x66)
+	 */
+	uint32_t (*p_bootrom_ext_service_ecdsa_check_key)
+		(uint8_t *p_pub_key_in,
+		 uint8_t *p_pub_key_out);
+	/*
+	 * verify ECDSA signature
+	 *
+	 *          Decrypt EDCSA signature from 'p_signature'
+	 *          using public key passed in parameter 'p_pub_key_in'
+	 *          Then compare it to hash from 'p_hash_in' (SHA-256)
+	 *
+	 *          If no match: => infinite loop in bootROM
+	 *
+	 *          else: return to caller
+	 *
+	 * @param[in]    p_hash_in : points on hash in (SHA-256)
+	 *               Very Important : address alignment constraint :
+	 *               This address should be multiple of 4 bytes only.
+	 * @param[in]    p_pub_key_in : points to an ECDSA public key
+	 *               Very Important : address alignment constraint :
+	 *               This address should be multiple of 4 bytes only.
+	 * @param[in]    p_signature : points to an EDCSA signature.
+	 *               Very Important : address alignment constraint :
+	 *               This address should be multiple of 4 bytes only.
+	 * @param[in]    ecc_algo : Ecc algorithm to be used P256 NIST or
+	 *                         Brain_pool 256.
+	 *
+	 * @retval  STD_OK (0x77) or STD_NOT_OK (0x66)
+	 */
+	uint32_t (*p_bootrom_ext_service_ecdsa_verify_signature)
+		(uint8_t *p_hash_in, uint8_t *p_pub_key_in,
+		 uint8_t *p_signature, uint32_t ecc_algo);
+	/*
+	 * verify ECDSA signature and branch to entry point if match
+	 *
+	 *          Decrypt EDCSA signature from 'p_signature'
+	 *          using public key passed in parameter 'p_pub_key_in'
+	 *          Then compare it to hash from 'p_hash_in' (SHA-256)
+	 *
+	 *          If no match: => infinite loop in bootROM
+	 *
+	 *          else: branch CA7-0 to branch address 'p_entry_in'
+	 *
+	 * @param[in]    p_hash_in : points on hash in (SHA-256)
+	 *               Very Important : address alignment constraint :
+	 *               This address should be multiple of 4 bytes only.
+	 * @param[in]    p_pub_key_in : points to an ECDSA public key
+	 *               Very Important : address alignment constraint :
+	 *               This address should be multiple of 4 bytes only.
+	 * @param[in]    p_signature : points to an EDCSA signature.
+	 *               Very Important : address alignment constraint :
+	 *               This address should be multiple of 4 bytes only.
+	 * @param[in]    ecc_algo : Ecc algorithm to be used P256 NIST or
+	 *                         Brain_pool 256.
+	 * @param[in]    p_entry_in : points to branch entry point.
+	 *
+	 * @retval  STD_NOT_OK (0x66)
+	 */
+	uint32_t (*p_bootrom_ext_service_ecdsa_verify_and_go)
+		(uint8_t *p_hash_in, uint8_t *p_pub_key_in,
+		 uint8_t *p_signature_in, uint32_t ecc_algo,
+		 uint32_t *p_entry_in);
+
+	/*
+	 * Information specific to an SD boot
+	 * Updated each time an SD boot is at least attempted,
+	 * even if not successful
+	 * Note : This is useful to understand why an SD boot failed
+	 * in particular
+	 */
+	uint32_t sd_err_internal_timeout_cnt;
+	uint32_t sd_err_dcrc_fail_cnt;
+	uint32_t sd_err_dtimeout_cnt;
+	uint32_t sd_err_ctimeout_cnt;
+	uint32_t sd_err_ccrc_fail_cnt;
+	uint32_t sd_overall_retry_cnt;
+	/*
+	 * Information specific to an eMMC boot
+	 * Updated each time an eMMC boot is at least attempted,
+	 * even if not successful
+	 * Note : This is useful to understand why an eMMC boot failed
+	 * in particular
+	 */
+	uint32_t emmc_xfer_status;
+	uint32_t emmc_error_status;
+	uint32_t emmc_nbbytes_rxcopied_tosysram_download_area;
+	uint32_t hse_clock_value_in_hz;
+	/*
+	 * Boot partition :
+	 * ie FSBL partition on which the boot was successful
+	 */
+	uint32_t boot_partition_used_toboot;
+	/*
+	 * Address of SSP configuration structure :
+	 * given and defined by bootROM
+	 * and used by FSBL. The structure is of type
+	 * 'boot_api_ssp_config_t'
+	 */
+	boot_api_ssp_config_t *p_ssp_config;
+	/*
+	 * boot context field containing bootROM updated SSP Status
+	 * Values can be of type BOOT_API_CTX_SSP_STATUS_XXX
+	 */
+	uint32_t	ssp_status;
+
+	/* Pointer on ROM constant containing ROM information */
+	const boot_api_rom_version_info_t *p_rom_version_info;
+
+} __packed boot_api_context_t;
+
+/*
+ * Image Header related definitions
+ */
+
+/*
+ * Structure used to define the common Header format used for FSBL, xloader,
+ * ... and in particular used by bootROM for FSBL header readout.
+ * FSBL header size is 256 Bytes = 0x100
+ */
+typedef struct {
+	/* BOOT_API_IMAGE_HEADER_MAGIC_NB */
+	uint32_t magic;
+	uint8_t image_signature[BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES];
+	/*
+	 * Checksum of payload
+	 * 32-bit sum all all payload bytes considered as 8 bit unigned numbers,
+	 * discarding any overflow bits.
+	 * Use to check UART/USB downloaded image integrity when signature
+	 * is not used (i.e bit 0 : 'No_sig_check' = 1 in option flags)
+	 */
+	uint32_t payload_checksum;
+	/* Image header version : should have value BOOT_API_HEADER_VERSION */
+	uint32_t header_version;
+	/* Image length in bytes */
+	uint32_t image_length;
+	/*
+	 * Image Entry point address : should be in the SYSRAM area
+	 * and at least within the download area range
+	 */
+	uint32_t image_entry_point;
+	/* Reserved */
+	uint32_t reserved1;
+	/*
+	 * Image load address : not used by bootROM but to be consistent
+	 * with header format for other packages (xloader, ...)
+	 */
+	uint32_t load_address;
+	/* Reserved */
+	uint32_t reserved2;
+	/* Image version to be compared by bootROM with monotonic
+	 * counter value in OTP_CFG4 prior executing the downloaded image
+	 */
+	uint32_t image_version;
+	/*
+	 * Option flags:
+	 * Bit 0 : No signature check request : 'No_sig_check'
+	 *      value 1 : for No signature check request
+	 *      value 0 : No request to bypass the signature check
+	 * Note : No signature check is never allowed on a Secured chip
+	 */
+	uint32_t option_flags;
+	/*
+	 * Type of ECC algorithm to use  :
+	 * value 1 : for P-256 NIST algorithm
+	 * value 2 : for Brainpool 256 algorithm
+	 * See definitions 'BOOT_API_ECDSA_ALGO_TYPE_XXX' above.
+	 */
+	uint32_t ecc_algo_type;
+	/*
+	 * OEM ECC Public Key (aka Root pubk) provided in header on 512 bits.
+	 * The SHA-256 hash of the OEM ECC pubk must match the one stored
+	 * in OTP cells.
+	 */
+	uint8_t ecc_pubk[BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES];
+	/* Pad up to 256 byte total size */
+	uint8_t pad[83];
+	/* Add binary type information */
+	uint8_t binary_type;
+} __packed boot_api_image_header_t;
+
+#endif /* BOOT_API_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/platform_def.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/platform_def.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 2015-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLATFORM_DEF_H
+#define PLATFORM_DEF_H
+
+#include <arch.h>
+#include <common_def.h>
+#include <gic_common.h>
+#include <utils_def.h>
+#include "../stm32mp1_def.h"
+
+/*******************************************************************************
+ * Generic platform constants
+ ******************************************************************************/
+
+/* Size of cacheable stacks */
+#if defined(IMAGE_BL32)
+#define PLATFORM_STACK_SIZE		0x600
+#else
+#define PLATFORM_STACK_SIZE		0xC00
+#endif
+
+#ifdef AARCH32_SP_OPTEE
+#define OPTEE_HEADER_IMAGE_NAME		"teeh"
+#define OPTEE_PAGED_IMAGE_NAME		"teed"
+#define OPTEE_PAGER_IMAGE_NAME		"teex"
+#define OPTEE_HEADER_BINARY_TYPE	U(0x20)
+#define OPTEE_PAGER_BINARY_TYPE		U(0x21)
+#define OPTEE_PAGED_BINARY_TYPE		U(0x22)
+#endif
+
+/* SSBL = second stage boot loader */
+#define BL33_IMAGE_NAME			"ssbl"
+#define BL33_BINARY_TYPE		U(0x0)
+
+#define STM32MP_PRIMARY_CPU		U(0x0)
+#define STM32MP_SECONDARY_CPU		U(0x1)
+
+#define PLATFORM_CLUSTER_COUNT		ULL(1)
+#define PLATFORM_CLUSTER0_CORE_COUNT	U(2)
+#define PLATFORM_CLUSTER1_CORE_COUNT	U(0)
+#define PLATFORM_CORE_COUNT		(PLATFORM_CLUSTER1_CORE_COUNT + \
+					 PLATFORM_CLUSTER0_CORE_COUNT)
+#define PLATFORM_MAX_CPUS_PER_CLUSTER	2
+
+#define MAX_IO_DEVICES			U(4)
+#define MAX_IO_HANDLES			U(4)
+#define MAX_IO_BLOCK_DEVICES		U(1)
+
+/*******************************************************************************
+ * BL2 specific defines.
+ ******************************************************************************/
+/*
+ * Put BL2 just below BL3-1. BL2_BASE is calculated using the current BL2 debug
+ * size plus a little space for growth.
+ */
+#define BL2_BASE		STM32MP_BL2_BASE
+#define BL2_LIMIT		(STM32MP_BL2_BASE + STM32MP_BL2_SIZE)
+
+/*******************************************************************************
+ * BL32 specific defines.
+ ******************************************************************************/
+#ifndef AARCH32_SP_OPTEE
+#define BL32_BASE			STM32MP_BL32_BASE
+#define BL32_LIMIT			(STM32MP_BL32_BASE + \
+					 STM32MP_BL32_SIZE)
+#endif
+
+/*******************************************************************************
+ * BL33 specific defines.
+ ******************************************************************************/
+#define BL33_BASE			STM32MP_BL33_BASE
+
+/*
+ * Load address of BL33 for this platform port
+ */
+#define PLAT_STM32MP_NS_IMAGE_OFFSET	BL33_BASE
+
+/* need by flash programmer */
+#define FLASHLAYOUT_BASE		STM32MP_DDR_BASE
+#define FLASHLAYOUT_LIMIT		STM32MP_BL33_BASE
+
+/*******************************************************************************
+ * DTB specific defines.
+ ******************************************************************************/
+#define DTB_BASE			STM32MP_DTB_BASE
+#define DTB_LIMIT			(STM32MP_DTB_BASE + \
+					 STM32MP_DTB_SIZE)
+
+/*******************************************************************************
+ * Platform specific page table and MMU setup constants
+ ******************************************************************************/
+#define PLAT_PHY_ADDR_SPACE_SIZE	(ULL(1) << 32)
+#define PLAT_VIRT_ADDR_SPACE_SIZE	(ULL(1) << 32)
+
+/*******************************************************************************
+ * Declarations and constants to access the mailboxes safely. Each mailbox is
+ * aligned on the biggest cache line size in the platform. This is known only
+ * to the platform as it might have a combination of integrated and external
+ * caches. Such alignment ensures that two maiboxes do not sit on the same cache
+ * line at any cache level. They could belong to different cpus/clusters &
+ * get written while being protected by different locks causing corruption of
+ * a valid mailbox address.
+ ******************************************************************************/
+#define CACHE_WRITEBACK_SHIFT		6
+#define CACHE_WRITEBACK_GRANULE		(U(1) << CACHE_WRITEBACK_SHIFT)
+
+/*
+ * Secure Interrupt: based on the standard ARM mapping
+ */
+#define ARM_IRQ_SEC_PHY_TIMER		U(29)
+
+#define ARM_IRQ_NON_SEC_SGI_0		U(0)
+
+#define ARM_IRQ_SEC_SGI_0		U(8)
+#define ARM_IRQ_SEC_SGI_1		U(9)
+#define ARM_IRQ_SEC_SGI_2		U(10)
+#define ARM_IRQ_SEC_SGI_3		U(11)
+#define ARM_IRQ_SEC_SGI_4		U(12)
+#define ARM_IRQ_SEC_SGI_5		U(13)
+#define ARM_IRQ_SEC_SGI_6		U(14)
+#define ARM_IRQ_SEC_SGI_7		U(15)
+
+/* Platform IRQ Priority */
+#define STM32MP1_IRQ_RCC_SEC_PRIO	U(0x6)
+#define STM32MP1_IRQ_SEC_SPI_PRIO	U(0x10)
+
+#define STM32MP1_IRQ_TZC400		U(36)
+#define STM32MP1_IRQ_MCU_SEV		U(176)
+#define STM32MP1_IRQ_RCC_WAKEUP		U(177)
+#define STM32MP1_IRQ_IWDG1		U(182)
+#define STM32MP1_IRQ_IWDG2		U(183)
+#define STM32MP1_IRQ_TAMPSERRS		U(229)
+#define STM32MP1_IRQ_AXIERRIRQ		U(244)
+
+/*
+ * Define a list of Group 1 Secure and Group 0 interrupts as per GICv3
+ * terminology. On a GICv2 system or mode, the lists will be merged and treated
+ * as Group 0 interrupts.
+ */
+#define PLATFORM_G1S_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_PHY_TIMER,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_LEVEL),	\
+	INTR_PROP_DESC(STM32MP1_IRQ_AXIERRIRQ,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_LEVEL),	\
+	INTR_PROP_DESC(STM32MP1_IRQ_TZC400,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_LEVEL),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_1,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE),		\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_2,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE),		\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_3,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE),		\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_4,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE),		\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_5,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE),		\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_7,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE)
+
+#define PLATFORM_G0_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_0,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE),		\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_6,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       grp, GIC_INTR_CFG_EDGE)
+
+/*
+ * Power
+ */
+#define PLAT_MAX_PWR_LVL	U(1)
+
+/* Local power state for power domains in Run state. */
+#define ARM_LOCAL_STATE_RUN	U(0)
+/* Local power state for retention. Valid only for CPU power domains */
+#define ARM_LOCAL_STATE_RET	U(1)
+/* Local power state for power-down. Valid for CPU and cluster power domains */
+#define ARM_LOCAL_STATE_OFF	U(2)
+/*
+ * This macro defines the deepest retention state possible.
+ * A higher state id will represent an invalid or a power down state.
+ */
+#define PLAT_MAX_RET_STATE		ARM_LOCAL_STATE_RET
+/*
+ * This macro defines the deepest power down states possible. Any state ID
+ * higher than this is invalid.
+ */
+#define PLAT_MAX_OFF_STATE		ARM_LOCAL_STATE_OFF
+
+/*******************************************************************************
+ * Size of the per-cpu data in bytes that should be reserved in the generic
+ * per-cpu data structure for the FVP port.
+ ******************************************************************************/
+#define PLAT_PCPU_DATA_SIZE	2
+
+#endif /* PLATFORM_DEF_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_context.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_context.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2017-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_CONTEXT_H
+#define STM32MP1_CONTEXT_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#define DDR_CRC_GRANULE		32
+
+void stm32_clean_context(void);
+int stm32_save_context(uint32_t zq0cr0_zdata);
+int stm32_restore_context(void);
+unsigned long long stm32_get_stgen_from_context(void);
+int stm32_restore_backup_reg(void);
+uint32_t stm32_get_zdata_from_context(void);
+void stm32_get_pll1_settings_from_context(void);
+bool stm32_are_pll1_settings_valid_in_context(void);
+int stm32_save_boot_interface(uint32_t interface, uint32_t instance);
+int stm32_get_boot_interface(uint32_t *interface, uint32_t *instance);
+void stm32_save_ddr_training_area(void);
+void stm32_restore_ddr_training_area(void);
+uint32_t stm32_pm_get_optee_ep(void);
+
+#endif /* STM32MP1_CONTEXT_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_dbgmcu.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_dbgmcu.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __PLAT_DBGMCU_H__
+#define __PLAT_DBGMCU_H__
+
+#include <stdint.h>
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+#define VERBOSE_HEXDUMP8(buf, len) stm32mp1_dbgmcu_hexdump8(buf, len)
+#define VERBOSE_HEXDUMP32(buf, len) stm32mp1_dbgmcu_hexdump32(buf, len)
+#else
+#define VERBOSE_HEXDUMP8(buf, len)
+#define VERBOSE_HEXDUMP32(buf, len)
+#endif
+#define HEXDUMP8(buf, len) stm32mp1_dbgmcu_hexdump8(buf, len)
+#define HEXDUMP32(buf, len) stm32mp1_dbgmcu_hexdump32(buf, len)
+
+int stm32mp1_dbgmcu_get_chip_version(uint32_t *chip_version);
+int stm32mp1_dbgmcu_get_chip_dev_id(uint32_t *chip_dev_id);
+int stm32mp1_dbgmcu_freeze_iwdg2(void);
+int stm32mp1_dbgmcu_boot_debug_info(void);
+void stm32mp1_dbgmcu_clear_boot_info(void);
+bool stm32mp1_dbgmcu_is_debug_on(void);
+void stm32mp1_dbgmcu_hexdump8(const void *buf, uint32_t len);
+void stm32mp1_dbgmcu_hexdump32(const void *buf, uint32_t len);
+
+#endif /* __PLAT_DBGMCU_H__ */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_low_power.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_low_power.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_LOW_POWER_H
+#define STM32MP1_LOW_POWER_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+void stm32_rcc_wakeup_update(bool state);
+void stm32_apply_pmic_suspend_config(uint32_t mode);
+void stm32_apply_pmic_resume_config(void);
+void stm32_exit_cstop(void);
+void stm32_pwr_down_wfi(void);
+void stm32_enter_low_power(uint32_t mode, uint32_t nsec_addr);
+
+#endif /* STM32MP1_LOW_POWER_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_power_config.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_power_config.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2017-2018, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_POWER_CONFIG_H
+#define STM32MP1_POWER_CONFIG_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#define PSCI_MODE_SYSTEM_SUSPEND	0
+#define PSCI_MODE_SYSTEM_OFF		1
+
+enum stm32mp1_pm_domain {
+	STM32MP1_PD_VSW,
+	STM32MP1_PD_CORE_RET,
+	STM32MP1_PD_CORE,
+	STM32MP1_PD_MAX_PM_DOMAIN
+};
+
+void stm32mp1_init_lp_states(void);
+int stm32mp1_set_pm_domain_state(enum stm32mp1_pm_domain domain, bool status);
+uint32_t stm32mp1_get_lp_soc_mode(uint32_t psci_mode);
+int stm32mp1_set_lp_deepest_soc_mode(uint32_t psci_mode, uint32_t soc_mode);
+
+#endif /* STM32MP1_POWER_CONFIG_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_private.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_private.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_PRIVATE_H
+#define STM32MP1_PRIVATE_H
+
+#include <bl_common.h>
+#include <boot_api.h>
+#include <stdbool.h>
+
+enum boot_device_e {
+	BOOT_DEVICE_USB,
+	BOOT_DEVICE_BOARD
+};
+
+void configure_mmu(void);
+
+void stm32mp_mask_timer(void);
+void __dead2 stm32mp_wait_cpu_reset(void);
+
+void stm32mp1_arch_security_setup(void);
+void stm32mp1_security_setup(void);
+void stm32mp1_sp_min_security_setup(void);
+
+enum boot_device_e get_boot_device(void);
+
+#if STM32MP_UART_PROGRAMMER
+uintptr_t get_uart_address(uint32_t instance_nb);
+#endif
+
+void stm32mp1_gic_pcpu_init(void);
+void stm32mp1_gic_init(void);
+
+enum etzpc_decprot_attributes stm32mp_etzpc_binding2decprot(uint32_t mode);
+
+void stm32mp1_syscfg_init(void);
+void stm32mp1_syscfg_enable_io_compensation(void);
+void stm32mp1_syscfg_disable_io_compensation(void);
+
+#endif /* STM32MP1_PRIVATE_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_shared_resources.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_shared_resources.h
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright (c) 2017-2018, STMicroelectronics
+ */
+
+#ifndef STM32MP1_SHARED_RESOURCES_H
+#define STM32MP1_SHARED_RESOURCES_H
+
+#include <debug.h>
+#include <etzpc.h>
+#include <stdbool.h>
+
+void stm32mp_clk_enable(unsigned long id);
+void stm32mp_clk_disable(unsigned long id);
+
+#define STM32MP1_SHRES_GPIOZ(i)		(STM32MP1_SHRES_GPIOZ_0 + i)
+
+enum stm32mp_shres {
+	STM32MP1_SHRES_GPIOZ_0 = 0,
+	STM32MP1_SHRES_GPIOZ_1,
+	STM32MP1_SHRES_GPIOZ_2,
+	STM32MP1_SHRES_GPIOZ_3,
+	STM32MP1_SHRES_GPIOZ_4,
+	STM32MP1_SHRES_GPIOZ_5,
+	STM32MP1_SHRES_GPIOZ_6,
+	STM32MP1_SHRES_GPIOZ_7,
+	STM32MP1_SHRES_IWDG1,
+	STM32MP1_SHRES_USART1,
+	STM32MP1_SHRES_SPI6,
+	STM32MP1_SHRES_I2C4,
+	STM32MP1_SHRES_RNG1,
+	STM32MP1_SHRES_HASH1,
+	STM32MP1_SHRES_CRYP1,
+	STM32MP1_SHRES_I2C6,
+	STM32MP1_SHRES_RTC,
+	STM32MP1_SHRES_MCU,
+	STM32MP1_SHRES_HSI,
+	STM32MP1_SHRES_LSI,
+	STM32MP1_SHRES_HSE,
+	STM32MP1_SHRES_LSE,
+	STM32MP1_SHRES_CSI,
+	STM32MP1_SHRES_PLL1,
+	STM32MP1_SHRES_PLL1_P,
+	STM32MP1_SHRES_PLL1_Q,
+	STM32MP1_SHRES_PLL1_R,
+	STM32MP1_SHRES_PLL2,
+	STM32MP1_SHRES_PLL2_P,
+	STM32MP1_SHRES_PLL2_Q,
+	STM32MP1_SHRES_PLL2_R,
+	STM32MP1_SHRES_PLL3,
+	STM32MP1_SHRES_PLL3_P,
+	STM32MP1_SHRES_PLL3_Q,
+	STM32MP1_SHRES_PLL3_R,
+
+	STM32MP1_SHRES_COUNT
+};
+
+void stm32mp1_register_secure_periph(unsigned int id);
+void stm32mp1_register_shared_periph(unsigned int id);
+void stm32mp1_register_non_secure_periph(unsigned int id);
+void stm32mp_register_secure_periph_iomem(uintptr_t base);
+void stm32mp_register_non_secure_periph_iomem(uintptr_t base);
+void stm32mp_register_secure_gpio(unsigned int bank, unsigned int pin);
+void stm32mp_register_non_secure_gpio(unsigned int bank, unsigned int pin);
+void stm32mp1_register_etzpc_decprot(unsigned int id,
+				     enum etzpc_decprot_attributes attr);
+
+bool stm32mp1_periph_is_shared(unsigned long id);
+bool stm32mp1_periph_is_non_secure(unsigned long id);
+bool stm32mp1_periph_is_secure(unsigned long id);
+bool stm32mp1_periph_is_unregistered(unsigned long id);
+
+bool stm32mp_gpio_bank_is_shared(unsigned int bank);
+bool stm32mp_gpio_bank_is_non_secure(unsigned int bank);
+bool stm32mp_gpio_bank_is_secure(unsigned int bank);
+
+bool stm32mp1_clock_is_shareable(unsigned long clock_id);
+bool stm32mp1_clock_is_shared(unsigned long clock_id);
+bool stm32mp1_clock_is_non_secure(unsigned long clock_id);
+
+void stm32mp1_driver_init_late(void);
+
+#endif /* STM32MP1_SHARED_RESOURCES_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_smc.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_smc.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2016-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_SMC_H
+#define STM32MP1_SMC_H
+
+#include <platform_def.h>
+
+/* SMC service generic return codes */
+#define STM32_SMC_OK			0x00000000U
+#define STM32_SMC_NOT_SUPPORTED		0xFFFFFFFFU
+#define STM32_SMC_FAILED		0xFFFFFFFEU
+#define STM32_SMC_INVALID_PARAMS	0xFFFFFFFDU
+
+/*
+ * SMC function IDs for STM32 Service queries.
+ * STM32 SMC services use the space between 0x82000000 and 0x8200FFFF
+ * like this is defined in SMC calling Convention by ARM
+ * for SiP (silicon Partner).
+ * https://developer.arm.com/docs/den0028/latest
+ */
+
+/* Secure Service access from Non-secure */
+
+/*
+ * SMC function STM32_SMC_RCC.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_RCC			0x82001000
+
+/*
+ * SMC function STM32_SMC_PWR.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_PWR			0x82001001
+
+/*
+ * SMC functions STM32_SMC_RCC_CAL.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Clock ID (from DT clock bindings).
+ */
+#define STM32_SMC_RCC_CAL		0x82001002
+
+/*
+ * SMC functions STM32_SMC_BSEC.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_READ_xxx/_PROG_xxx/_WRITE_xxx).
+ *		(output) OTP read value, if applicable.
+ * Argument a2: (input) OTP index.
+ * Argument a3: (input) OTP value if applicable.
+ */
+#define STM32_SMC_BSEC			0x82001003
+
+/* Low Power services */
+
+/*
+ * SIP function STM32_SMC_PD_DOMAIN.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a2: (index) ID of target power domain to be enabled/disabled.
+ * Argument a3: (input) 0 to disable, 1 to enable target domain.
+ */
+#define STM32_SMC_PD_DOMAIN		0x82001008
+
+/*
+ * SIP function STM32_SMC_RCC_OPP.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_RCC_OPP_xxx).
+ *		(output) Rounded frequency, if applicable.
+ * Argument a2: (input) Requested frequency.
+ */
+#define STM32_SMC_RCC_OPP		0x82001009
+
+/* SMC function IDs for SiP Service queries */
+
+/*
+ * SIP function STM32_SIP_SVC_CALL_COUNT.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Dummy value 0.
+ */
+#define STM32_SIP_SVC_CALL_COUNT	0x8200ff00
+
+/*
+ * SIP function STM32_SIP_SVC_UID.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Lowest 32bit of the stm32mp1 SIP service UUID.
+ * Argument a1: (output) Next 32bit of the stm32mp1 SIP service UUID.
+ * Argument a2: (output) Next 32bit of the stm32mp1 SIP service UUID.
+ * Argument a3: (output) Last 32bit of the stm32mp1 SIP service UUID.
+ */
+#define STM32_SIP_SVC_UID		0x8200ff01
+
+/* 0x8200ff02 is reserved */
+
+/*
+ * SIP function STM32_SIP_SVC_VERSION.
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) STM32 SIP service major.
+ * Argument a1: (output) STM32 SIP service minor.
+ */
+#define STM32_SIP_SVC_VERSION		0x8200ff03
+
+/* Service ID for STM32_SMC_RCC/_PWR */
+#define STM32_SMC_REG_READ		0x0
+#define STM32_SMC_REG_WRITE		0x1
+#define STM32_SMC_REG_SET		0x2
+#define STM32_SMC_REG_CLEAR		0x3
+
+/* Service ID for STM32_SMC_BSEC */
+#define STM32_SMC_READ_SHADOW		0x01
+#define STM32_SMC_PROG_OTP		0x02
+#define STM32_SMC_WRITE_SHADOW		0x03
+#define STM32_SMC_READ_OTP		0x04
+#define STM32_SMC_READ_ALL		0x05
+#define STM32_SMC_WRITE_ALL		0x06
+#define STM32_SMC_WRLOCK_OTP		0x07
+
+/* Service ID for STM32_SMC_RCC_OPP */
+#define STM32_SMC_RCC_OPP_SET		0x0
+#define STM32_SMC_RCC_OPP_ROUND		0x1
+
+/* STM32 SiP Service Calls version numbers */
+#define STM32_SIP_SVC_VERSION_MAJOR	0x0
+#define STM32_SIP_SVC_VERSION_MINOR	0x1
+
+/* Number of STM32 SiP Calls implemented */
+#define STM32_COMMON_SIP_NUM_CALLS	11
+
+#endif /* STM32MP1_SMC_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_usb_desc.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/stm32mp1_usb_desc.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2015-2017, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __USBD_DESC_H
+#define __USBD_DESC_H
+
+#include <usb_core.h>
+
+/* Max DFU Packet Size = 1024 bytes */
+#define USBD_DFU_XFER_SIZE	1024
+
+#define TRANSFER_SIZE_BYTES(size) \
+	((uint8_t)((size) & 0xFF)), /* XFERSIZEB0 */\
+	((uint8_t)((size) >> 8))    /* XFERSIZEB1 */
+
+/* Descriptor of DFU interface 0 Alternate setting n */
+#define USBD_DFU_IF_DESC(n)	0x09, /* Interface Descriptor size */\
+				USB_DESC_TYPE_INTERFACE, /* descriptor type */\
+				0x00, /* Number of Interface */\
+				(n), /* Alternate setting */\
+				0x00, /* bNumEndpoints*/\
+				0xFE, /* Application Specific Class Code */\
+				0x01, /* Device Firmware Upgrade Code */\
+				0x02, /* DFU mode protocol */ \
+				USBD_IDX_INTERFACE_STR + (n) + 1 /* iInterface:
+								  * Index of
+								  * string
+								  * descriptor
+								  */
+/* DFU1.1 Standard only supported */
+#define USB_DFU_VERSION			0x0110
+#define USBD_DESC_MAX_ITF_NUM		0x6
+#define USB_DFU_CONFIG_DESC_SIZ		72
+#define USB_DFU_DESC_SIZ		9
+/*  String size (1 byte) + type (1 byte) + 24 UTF16 characters */
+/*  (2 bytes per character) */
+#define USB_SIZ_STRING_SERIAL		(1 + 1 + (24 * 2))
+#define USBD_MAX_STR_DESC_SIZ		0x100
+#define USBD_VID			0x0483
+#define USBD_PID			0xDF11
+#define USBD_LANGID_STRING		0x409
+#define USBD_MANUFACTURER_STRING	"STMicroelectronics"
+#define USBD_PRODUCT_HS_STRING		"DFU in HS Mode @Device ID /0x500, @Revision ID /0x0000"
+#define USBD_PRODUCT_FS_STRING		"DFU in FS Mode @Device ID /0x500, @Revision ID /0x0000"
+#define USBD_CONFIGURATION_HS_STRING	"DFU Config"
+#define USBD_INTERFACE_HS_STRING	"DFU Interface"
+#define USBD_CONFIGURATION_FS_STRING	"DFU Config"
+#define USBD_INTERFACE_FS_STRING	"DFU Interface"
+
+void stm32mp_usb_init_desc(usb_handle_t *pdev);
+
+#endif /* __USBD_DESC_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/include/usb_ctx.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/include/usb_ctx.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2015-2017, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __USB_CTX_H
+#define __USB_CTX_H
+
+#include <usb_core.h>
+
+struct usb_ctx {
+	usb_handle_t *pusbd_device_ctx;
+	pcd_handle_t *phpcd_ctx;
+};
+
+#endif /* __USB_CTX_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/plat_bl2_mem_params_desc.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/plat_bl2_mem_params_desc.c
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2016-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <bl_common.h>
+#include <desc_image_load.h>
+#include <platform.h>
+#include <platform_def.h>
+
+/*******************************************************************************
+ * Following descriptor provides BL image/ep information that gets used
+ * by BL2 to load the images and also subset of this information is
+ * passed to next BL image. The image loading sequence is managed by
+ * populating the images in required loading order. The image execution
+ * sequence is managed by populating the `next_handoff_image_id` with
+ * the next executable image id.
+ ******************************************************************************/
+static bl_mem_params_node_t bl2_mem_params_descs[] = {
+	/* Fill BL32 related information */
+	{
+		.image_id = BL32_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | EXECUTABLE | EP_FIRST_EXE),
+
+#if !defined(AARCH32_SP_OPTEE)
+		.ep_info.pc = BL32_BASE,
+#endif
+		.ep_info.spsr = SPSR_MODE32(MODE32_svc, SPSR_T_ARM,
+					    SPSR_E_LITTLE,
+					    DISABLE_ALL_EXCEPTIONS),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_PLAT_SETUP),
+#if defined(AARCH32_SP_OPTEE)
+		/* optee header is loaded is SYSRAM above BL2 */
+		.image_info.image_base = STM32MP_OPTEE_BASE,
+		.image_info.image_max_size = STM32MP_OPTEE_SIZE,
+#else
+		.image_info.image_base = BL32_BASE,
+		.image_info.image_max_size = BL32_LIMIT - BL32_BASE,
+#endif
+		.next_handoff_image_id = BL33_IMAGE_ID,
+	},
+
+#if defined(AARCH32_SP_OPTEE)
+	/* Fill BL32 external 1 image related information */
+	{
+		.image_id = BL32_EXTRA1_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+	/* Fill BL32 external 2 image related information */
+	{
+		.image_id = BL32_EXTRA2_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+#endif /* AARCH32_SP_OPTEE */
+
+	/* Fill BL33 related information */
+	{
+		.image_id = BL33_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      NON_SECURE | EXECUTABLE),
+
+		.ep_info.pc = PLAT_STM32MP_NS_IMAGE_OFFSET,
+		.ep_info.spsr = SPSR_MODE32(MODE32_svc, SPSR_T_ARM,
+					    SPSR_E_LITTLE,
+					    DISABLE_ALL_EXCEPTIONS),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t, 0),
+
+		.image_info.image_base = PLAT_STM32MP_NS_IMAGE_OFFSET,
+		.image_info.image_max_size = STM32MP_DDR_MAX_SIZE -
+			(PLAT_STM32MP_NS_IMAGE_OFFSET - STM32MP_DDR_BASE),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	}
+};
+
+REGISTER_BL_IMAGE_DESCS(bl2_mem_params_descs)
Index: arm-trusted-firmware.git/plat/karo/txmp/plat_image_load.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/plat_image_load.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2016-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <bl_common.h>
+#include <boot_api.h>
+#include <bsec.h>
+#include <debug.h>
+#include <desc_image_load.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <mmio.h>
+#include <platform.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_private.h>
+#include <stm32mp1_pwr.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+#include <utils_def.h>
+
+/*******************************************************************************
+ * This function flushes the data structures so that they are visible
+ * in memory for the next BL image.
+ ******************************************************************************/
+void plat_flush_next_bl_params(void)
+{
+	flush_bl_params_desc();
+}
+
+#ifdef AARCH32_SP_OPTEE
+static bool addr_inside_backupsram(uintptr_t addr)
+{
+	return (addr >= STM32MP_BACKUP_RAM_BASE) &&
+		(addr < (STM32MP_BACKUP_RAM_BASE + STM32MP_BACKUP_RAM_SIZE));
+}
+#endif
+
+/*******************************************************************************
+ * This function returns the list of loadable images.
+ ******************************************************************************/
+bl_load_info_t *plat_get_bl_image_load_info(void)
+{
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+#ifdef AARCH32_SP_OPTEE
+	bl_mem_params_node_t *bl32 = get_bl_mem_params_node(BL32_IMAGE_ID);
+#endif
+	bl_mem_params_node_t *bl33 = get_bl_mem_params_node(BL33_IMAGE_ID);
+	uint32_t rstsr = mmio_read_32(stm32mp_rcc_base() + RCC_MP_RSTSCLRR);
+	uint32_t bkpr_core1_addr =
+		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+	uintptr_t pwr_base = stm32mp_pwr_base();
+
+	/*
+	 * If going back from CSTANDBY / STANDBY and DDR was in Self-Refresh,
+	 * BL33 must not be loaded as it would overwrite the code already
+	 * in DDR. For this, the BL33 part of the bl_mem_params_desc_ptr
+	 * struct should be modified to skip its loading
+	 */
+	if (((boot_context->boot_action ==
+	      BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY) ||
+	     (boot_context->boot_action ==
+	      BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY)) &&
+	    ((mmio_read_32(pwr_base + PWR_CR3) & PWR_CR3_DDRSREN) != 0U) &&
+	    ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) == 0U)) {
+		stm32mp_clk_enable(RTCAPB);
+
+		if (mmio_read_32(bkpr_core1_addr) != 0U) {
+			bl33->image_info.h.attr |= IMAGE_ATTRIB_SKIP_LOADING;
+
+#ifdef AARCH32_SP_OPTEE
+			bl32->image_info.h.attr |= IMAGE_ATTRIB_SKIP_LOADING;
+			bl32->ep_info.pc = stm32_pm_get_optee_ep();
+
+			if (addr_inside_backupsram(bl32->ep_info.pc)) {
+				stm32mp_clk_enable(BKPSRAM);
+			}
+#else
+			/*
+			 * Set ep_info PC to 0, to inform BL32 it is a reset
+			 * after STANDBY
+			 */
+			bl33->ep_info.pc = 0;
+#endif
+		}
+
+		stm32mp_clk_disable(RTCAPB);
+	}
+
+	/* Max size is non-secure DDR end address minus image_base */
+	bl33->image_info.image_max_size = dt_get_ddr_size() -
+#ifdef AARCH32_SP_OPTEE
+					  STM32MP_DDR_S_SIZE -
+					  STM32MP_DDR_SHMEM_SIZE -
+#endif
+					  bl33->image_info.image_base;
+
+	return get_bl_load_info_from_mem_params_desc();
+}
+
+/*******************************************************************************
+ * This function returns the list of executable images.
+ ******************************************************************************/
+bl_params_t *plat_get_next_bl_params(void)
+{
+	return get_next_bl_params_from_mem_params_desc();
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/platform.mk
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/platform.mk
@@ -0,0 +1,282 @@
+#
+# Copyright (c) 2015-2020, ARM Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+ARM_CORTEX_A7		:=	yes
+ARM_WITH_NEON		:=	yes
+BL2_AT_EL3		:=	1
+USE_COHERENT_MEM	:=	0
+MULTI_CONSOLE_API	:=	1
+
+# Add specific ST version
+ST_VERSION 		:=	r3.0
+VERSION_STRING		:=	v${VERSION_MAJOR}.${VERSION_MINOR}-${ST_VERSION}(${BUILD_TYPE}):${BUILD_STRING}
+
+# Please don't increment this value without good understanding of
+# the monotonic counter
+STM32_TF_VERSION	?=	0
+$(eval $(call add_define_val,STM32_TF_VERSION,${STM32_TF_VERSION}))
+
+# Enable dynamic memory mapping
+PLAT_XLAT_TABLES_DYNAMIC :=	1
+$(eval $(call assert_boolean,PLAT_XLAT_TABLES_DYNAMIC))
+$(eval $(call add_define,PLAT_XLAT_TABLES_DYNAMIC))
+
+# Enable software PMIC programming in case of debug purpose
+STM32MP1_DEBUG_ENABLE	?=	1
+$(eval $(call add_define_val,STM32MP1_DEBUG_ENABLE,${STM32MP1_DEBUG_ENABLE}))
+
+# Not needed for Cortex-A7
+WORKAROUND_CVE_2017_5715:=	0
+
+# Specific modification for reset halt workaround
+STM32MP1_RESET_HALT_WORKAROUND 	?= 	1
+$(eval $(call add_define,STM32MP1_RESET_HALT_WORKAROUND))
+
+AARCH32_EXCEPTION_DEBUG	:=	1
+
+ifeq ($(AARCH32_SP),optee)
+$(eval $(call add_define,AARCH32_SP_OPTEE))
+endif
+
+# Number of TF-A copies in the device
+STM32_TF_A_COPIES		:=	2
+$(eval $(call add_define,STM32_TF_A_COPIES))
+ifeq ($(AARCH32_SP),optee)
+PLAT_PARTITION_MAX_ENTRIES	:=	$(shell echo $$(($(STM32_TF_A_COPIES) + 4)))
+else
+PLAT_PARTITION_MAX_ENTRIES	:=	$(shell echo $$(($(STM32_TF_A_COPIES) + 1)))
+endif
+$(eval $(call add_define,PLAT_PARTITION_MAX_ENTRIES))
+
+STM32MP_BOOT_ONLY		?=	0
+STM32MP_FLASHLOADER_ONLY	?=	0
+
+ifeq (${STM32MP_BOOT_ONLY},1)
+ifeq (${STM32MP_FLASHLOADER_ONLY},1)
+$(error "You cannot choose both STM32MP_BOOT_ONLY and STM32MP_FLASHLOADER_ONLY")
+endif
+STM32MP_BOOT_DEVICES		=	1
+STM32MP_FLASHLOADER		=	0
+endif
+ifeq (${STM32MP_FLASHLOADER_ONLY},1)
+STM32MP_BOOT_DEVICES		=	0
+STM32MP_FLASHLOADER		=	1
+endif
+
+STM32MP_BOOT_DEVICES		?=	1
+STM32MP_FLASHLOADER		?=	1
+
+ifeq (${STM32MP_BOOT_DEVICES},1)
+# Boot devices
+STM32MP1_QSPI_NOR	:=	1
+$(eval $(call add_define,STM32MP1_QSPI_NOR))
+STM32MP_FMC_NAND	:=	1
+$(eval $(call add_define,STM32MP_FMC_NAND))
+STM32MP_EMMC		:=	1
+$(eval $(call add_define,STM32MP_EMMC))
+STM32MP_SDMMC		:=	1
+$(eval $(call add_define,STM32MP_SDMMC))
+STM32MP1_QSPI_NAND	:=	1
+$(eval $(call add_define,STM32MP1_QSPI_NAND))
+
+ifeq ($(filter 1,${STM32MP1_QSPI_NOR} ${STM32MP_FMC_NAND} ${STM32MP_EMMC} ${STM32MP_SDMMC}),)
+$(error "No boot device driver is enabled")
+endif
+endif #STM32MP_BOOT_DEVICES
+
+ifeq (${STM32MP_FLASHLOADER},1)
+STM32MP_USB		:=	1
+$(eval $(call add_define,STM32MP_USB))
+
+STM32MP_UART_PROGRAMMER	:=	1
+$(eval $(call add_define,STM32MP_UART_PROGRAMMER))
+endif #STM32MP_FLASHLOADER
+
+PLAT_INCLUDES		:=	-Iinclude/common/tbbr
+PLAT_INCLUDES		+=	-Iinclude/drivers/partition
+PLAT_INCLUDES		+=	-Iinclude/drivers/st
+PLAT_INCLUDES		+=	-Iplat/st/common/include/
+PLAT_INCLUDES		+=	-Iplat/$(VENDOR)/$(PLAT)/include/
+
+PLAT_INCLUDES		+=	-Iinclude/lib/usb
+
+# Device tree
+DTB_FILE_NAME		?=	stm32mp153a-txmp.dtb
+FDT_SOURCES		:=	$(addprefix fdts/, $(patsubst %.dtb,%.dts,$(DTB_FILE_NAME)))
+DTC_FLAGS		+=	-Wno-unit_address_vs_reg
+
+include lib/libfdt/libfdt.mk
+
+PLAT_BL_COMMON_SOURCES	:=	plat/st/common/stm32mp_common.c				\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_private.c
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/console/aarch32/console.S			\
+				drivers/st/uart/aarch32/stm32_console.S
+
+ifneq (${ENABLE_STACK_PROTECTOR},0)
+PLAT_BL_COMMON_SOURCES	+=	plat/$(VENDOR)/$(PLAT)/stm32mp1_stack_protector.c
+endif
+
+include lib/xlat_tables_v2/xlat_tables.mk
+PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
+
+PLAT_BL_COMMON_SOURCES	+=	lib/cpus/aarch32/cortex_a7.S
+
+PLAT_BL_COMMON_SOURCES	+=	${LIBFDT_SRCS}						\
+				drivers/arm/tzc/tzc400.c				\
+				drivers/delay_timer/delay_timer.c			\
+				drivers/delay_timer/generic_delay_timer.c		\
+				drivers/st/bsec/bsec.c					\
+				drivers/st/clk/stm32mp_clkfunc.c			\
+				drivers/st/clk/stm32mp1_clk.c				\
+				drivers/st/clk/stm32mp1_clkfunc.c			\
+				drivers/st/ddr/stm32mp1_ddr_helpers.c			\
+				drivers/st/gpio/stm32_gpio.c				\
+				drivers/st/i2c/stm32_i2c.c				\
+				drivers/st/iwdg/stm32_iwdg.c				\
+				drivers/st/regulator/stm32mp_dummy_regulator.c		\
+				drivers/st/regulator/stm32mp_regulator.c		\
+				drivers/st/reset/stm32mp1_reset.c			\
+				plat/st/common/stm32mp_dt.c				\
+				plat/st/common/stm32mp_shres_helpers.c			\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_context.c		\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_dbgmcu.c		\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_helper.S		\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_security.c		\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_shared_resources.c	\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_syscfg.c
+
+BL2_SOURCES		+=	drivers/io/io_block.c					\
+				drivers/io/io_dummy.c					\
+				drivers/io/io_storage.c					\
+				drivers/st/hash/hash_sec.c				\
+				drivers/st/io/io_stm32image.c				\
+				plat/st/common/bl2_io_storage.c				\
+				plat/st/common/stm32mp_auth.c				\
+				plat/$(VENDOR)/$(PLAT)/bl2_plat_setup.c
+
+ifeq (${STM32MP1_QSPI_NOR},1)
+BL2_SOURCES		+=	drivers/st/qspi/io_qspi.c
+endif
+
+ifeq (${STM32MP_FMC_NAND},1)
+BL2_SOURCES		+=	drivers/st/nand/io_nand.c				\
+				drivers/st/nand/nand.c
+endif
+
+ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
+BL2_SOURCES		+=	drivers/mmc/mmc.c					\
+				drivers/partition/gpt.c					\
+				drivers/partition/partition.c				\
+				drivers/st/io/io_mmc.c					\
+				drivers/st/mmc/stm32_sdmmc2.c
+endif
+
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/st/uart/io_programmer_uart.c			\
+				drivers/st/uart/stm32mp1xx_hal_uart.c
+endif
+
+BL2_SOURCES		+=	drivers/st/ddr/stm32mp1_ddr.c				\
+				drivers/st/ddr/stm32mp1_ram.c
+
+BL2_SOURCES		+=	common/desc_image_load.c				\
+				plat/$(VENDOR)/$(PLAT)/plat_bl2_mem_params_desc.c	\
+				plat/$(VENDOR)/$(PLAT)/plat_image_load.c
+
+ifeq (${STM32MP_USB},1)
+BL2_SOURCES		+=	drivers/st/io/io_programmer_st_usb.c			\
+				drivers/st/usb_dwc2/usb_dwc2.c				\
+				lib/usb/usb_core.c					\
+				lib/usb/usb_st_dfu.c					\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_usb_desc.c
+endif
+
+ifeq ($(AARCH32_SP),optee)
+BL2_SOURCES		+=	lib/optee/optee_utils.c
+endif
+
+ifeq (${STM32MP1_RESET_HALT_WORKAROUND},1)
+BL2_SOURCES		+=	plat/$(VENDOR)/$(PLAT)/stm32mp1_helper_dbg.S
+endif
+
+# Do not use neon in TF-A code, it leads to issues in low-power functions
+TF_CFLAGS		+=	-mfloat-abi=soft
+
+# Macros and rules to build TF binary
+STM32_TF_ELF_LDFLAGS	:=	--hash-style=gnu --as-needed
+STM32_DT_BASENAME	:=	$(DTB_FILE_NAME:.dtb=)
+STM32_TF_STM32		:=	${BUILD_PLAT}/tf-a-${STM32_DT_BASENAME}.stm32
+STM32_TF_BINARY		:=	$(STM32_TF_STM32:.stm32=.bin)
+STM32_TF_MAPFILE	:=	$(STM32_TF_STM32:.stm32=.map)
+STM32_TF_LINKERFILE	:=	$(STM32_TF_STM32:.stm32=.ld)
+STM32_TF_ELF		:=	$(STM32_TF_STM32:.stm32=.elf)
+STM32_TF_DTBFILE	:=      ${BUILD_PLAT}/fdts/${DTB_FILE_NAME}
+STM32_TF_OBJS		:=	${BUILD_PLAT}/stm32mp1.o
+
+# Variables for use with stm32image
+STM32IMAGEPATH		?= tools/stm32image
+STM32IMAGE		?= ${STM32IMAGEPATH}/stm32image${BIN_EXT}
+
+.PHONY: check_dtc_version stm32image clean_stm32image
+.SUFFIXES:
+
+all: check_dtc_version stm32image ${STM32_TF_STM32}
+
+ifeq ($(AARCH32_SP),sp_min)
+# BL32 is built only if using SP_MIN
+BL32_DEP		:= bl32
+BL32_PATH		:= -DBL32_BIN_PATH=\"${BUILD_PLAT}/bl32.bin\"
+endif
+
+distclean realclean clean: clean_stm32image
+
+stm32image: ${STM32IMAGE}
+
+${STM32IMAGE}:
+	${Q}${MAKE} CPPFLAGS="" --no-print-directory -C ${STM32IMAGEPATH}
+
+clean_stm32image:
+	${Q}${MAKE} --no-print-directory -C ${STM32IMAGEPATH} clean
+
+check_dtc_version:
+	$(eval DTC_V = $(shell $(DTC) -v | awk '{print $$NF}'))
+	$(eval DTC_VERSION = $(shell printf "%d" $(shell echo ${DTC_V} | cut -d- -f1 | sed "s/\./0/g")))
+	@if [ ${DTC_VERSION} -lt 10404 ]; then \
+		echo "dtc version too old (${DTC_V}), you need at least version 1.4.4"; \
+		false; \
+	fi
+
+
+${STM32_TF_OBJS}:	plat/$(VENDOR)/$(PLAT)/stm32mp1.S bl2 ${BL32_DEP} ${STM32_TF_DTBFILE}
+			@echo "  AS      $<"
+			${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
+				${BL32_PATH} \
+				-DBL2_BIN_PATH=\"${BUILD_PLAT}/bl2.bin\" \
+				-DDTB_BIN_PATH=\"${STM32_TF_DTBFILE}\" \
+				-c plat/$(VENDOR)/$(PLAT)/stm32mp1.S -o $@
+
+${STM32_TF_LINKERFILE}:	plat/$(VENDOR)/$(PLAT)/stm32mp1.ld.S ${BUILD_PLAT}
+			@echo "  LDS     $<"
+			${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} -P -E $< -o $@
+
+${STM32_TF_ELF}:	${STM32_TF_OBJS} ${STM32_TF_LINKERFILE}
+			@echo "  LDS     $<"
+			${Q}${LD} -o $@ ${STM32_TF_ELF_LDFLAGS} -Map=${STM32_TF_MAPFILE} --script ${STM32_TF_LINKERFILE} ${STM32_TF_OBJS}
+
+${STM32_TF_BINARY}:	${STM32_TF_ELF}
+			${Q}${OC} -O binary ${STM32_TF_ELF} $@
+			@echo
+			@echo "Built $@ successfully"
+			@echo
+
+${STM32_TF_STM32}:	${STM32IMAGE} ${STM32_TF_BINARY}
+			@echo
+			@echo "Generated $@"
+			$(eval LOADADDR =  $(shell cat ${STM32_TF_MAPFILE} | grep RAM | awk '{print $$2}'))
+			$(eval ENTRY =  $(shell cat ${STM32_TF_MAPFILE} | grep "__BL2_IMAGE_START" | awk '{print $$1}'))
+			${STM32IMAGE} -s ${STM32_TF_BINARY} -d $@ -l $(LOADADDR) -e ${ENTRY} -v ${STM32_TF_VERSION}
+			@echo
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_context.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_context.c
@@ -0,0 +1,317 @@
+/*
+ * Copyright (c) 2017-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <boot_api.h>
+#include <context.h>
+#include <context_mgmt.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <errno.h>
+#include <mmio.h>
+#include <platform_def.h>
+#include <smccc_helpers.h>
+#include <stm32_rtc.h>
+#include <stm32mp1_clk.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_ddr_regs.h>
+#include <stm32mp1_shared_resources.h>
+#include <string.h>
+#include <utils.h>
+
+#define TAMP_BOOT_ITF_BACKUP_REG_ID	U(20)
+#define TAMP_BOOT_ITF_MASK		U(0x0000FF00)
+#define TAMP_BOOT_ITF_SHIFT		8
+
+#define TRAINING_AREA_SIZE		64
+
+#ifdef AARCH32_SP_OPTEE
+/*
+ * OPTEE_MAILBOX_MAGIC relates to struct backup_data_s as defined
+ *
+ * OPTEE_MAILBOX_MAGIC_V1:
+ * Context provides magic, resume entry, zq0cr0 zdata and DDR training buffer.
+ *
+ * OPTEE_MAILBOX_MAGIC_V2:
+ * Context provides magic, resume entry, zq0cr0 zdata, DDR training buffer
+ * and PLL1 dual OPP settings structure (86 bytes).
+ */
+#define OPTEE_MAILBOX_MAGIC_V1		(0x0001 << 16)
+#define OPTEE_MAILBOX_MAGIC_V2		(0x0002 << 16)
+#define OPTEE_MAILBOX_MAGIC		(OPTEE_MAILBOX_MAGIC_V2 | \
+					 TRAINING_AREA_SIZE)
+
+#if (PLAT_MAX_OPP_NB != 2) || (PLAT_MAX_PLLCFG_NB != 6)
+#error OPTEE_MAILBOX_MAGIC_V1 does not support expected PLL1 settings
+#endif
+#endif
+
+/* pll_settings structure size definitions (reference to clock driver) */
+#define PLL1_SETTINGS_SIZE		(((PLAT_MAX_OPP_NB * \
+					  (PLAT_MAX_PLLCFG_NB + 3)) + 1) * \
+					 sizeof(uint32_t))
+
+struct backup_data_s {
+#ifdef AARCH32_SP_OPTEE
+	uint32_t magic;
+	uint32_t core0_resume_hint;
+	uint32_t zq0cr0_zdata;
+	uint8_t ddr_training_backup[TRAINING_AREA_SIZE];
+	uint8_t pll1_settings[PLL1_SETTINGS_SIZE];
+#else
+	smc_ctx_t saved_smc_context[PLATFORM_CORE_COUNT];
+	cpu_context_t saved_cpu_context[PLATFORM_CORE_COUNT];
+	uint32_t zq0cr0_zdata;
+	struct stm32_rtc_calendar rtc;
+	uint8_t ddr_training_backup[TRAINING_AREA_SIZE];
+	uint8_t pll1_settings[PLL1_SETTINGS_SIZE];
+	unsigned long long stgen;
+#endif
+};
+
+#ifdef AARCH32_SP_OPTEE
+uint32_t stm32_pm_get_optee_ep(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t ep;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	/* Context & Data to be saved at the beginning of Backup SRAM */
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	if (backup_data->magic != OPTEE_MAILBOX_MAGIC) {
+		panic();
+	}
+
+	ep = backup_data->core0_resume_hint;
+
+	stm32mp_clk_disable(BKPSRAM);
+
+	return ep;
+}
+#else /*AARCH32_SP_OPTEE*/
+void stm32_clean_context(void)
+{
+	stm32mp_clk_enable(BKPSRAM);
+
+	zeromem((void *)STM32MP_BACKUP_RAM_BASE, sizeof(struct backup_data_s));
+
+	stm32mp_clk_disable(BKPSRAM);
+}
+
+int stm32_save_context(uint32_t zq0cr0_zdata)
+{
+	void *smc_context;
+	void *cpu_context;
+	struct backup_data_s *backup_data;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	/* Context & Data to be saved at the beginning of Backup SRAM */
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	/* Retrieve smc context struct address */
+	smc_context = smc_get_ctx(NON_SECURE);
+
+	/* Retrieve smc context struct address */
+	cpu_context = cm_get_context(NON_SECURE);
+
+	/* Save context in Backup SRAM */
+	memcpy(&backup_data->saved_smc_context[0], smc_context,
+	       sizeof(smc_ctx_t) * PLATFORM_CORE_COUNT);
+	memcpy(&backup_data->saved_cpu_context[0], cpu_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+	backup_data->zq0cr0_zdata = zq0cr0_zdata;
+
+	stm32_rtc_get_calendar(&backup_data->rtc);
+	backup_data->stgen = stm32mp1_stgen_get_counter();
+
+	stm32mp1_clk_lp_save_opp_pll1_settings(backup_data->pll1_settings,
+					sizeof(backup_data->pll1_settings));
+
+	stm32mp_clk_disable(BKPSRAM);
+
+	return 0;
+}
+
+int stm32_restore_context(void)
+{
+	void *smc_context;
+	void *cpu_context;
+	struct backup_data_s *backup_data;
+	struct stm32_rtc_calendar current_calendar;
+	unsigned long long stdby_time_in_ms;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	/* Context & Data to be saved at the beginning of Backup SRAM */
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	/* Retrieve smc context struct address */
+	smc_context = smc_get_ctx(NON_SECURE);
+
+	/* Retrieve smc context struct address */
+	cpu_context = cm_get_context(NON_SECURE);
+
+	/* Restore data from Backup SRAM */
+	memcpy(smc_context, backup_data->saved_smc_context,
+	       sizeof(smc_ctx_t) * PLATFORM_CORE_COUNT);
+	memcpy(cpu_context, backup_data->saved_cpu_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+	/* Restore STGEN counter with standby mode length */
+	stm32_rtc_get_calendar(&current_calendar);
+	stdby_time_in_ms = stm32_rtc_diff_calendar(&current_calendar,
+						   &backup_data->rtc);
+	stm32mp1_stgen_restore_counter(backup_data->stgen, stdby_time_in_ms);
+
+	stm32mp1_clk_lp_load_opp_pll1_settings(backup_data->pll1_settings,
+					sizeof(backup_data->pll1_settings));
+
+	stm32mp_clk_disable(BKPSRAM);
+
+	return 0;
+}
+
+unsigned long long stm32_get_stgen_from_context(void)
+{
+	struct backup_data_s *backup_data;
+	unsigned long long stgen_cnt;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	stgen_cnt = backup_data->stgen;
+
+	stm32mp_clk_disable(BKPSRAM);
+
+	return stgen_cnt;
+}
+#endif /*AARCH32_SP_OPTEE*/
+
+uint32_t stm32_get_zdata_from_context(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t zdata;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	zdata = (backup_data->zq0cr0_zdata >> DDRPHYC_ZQ0CRN_ZDATA_SHIFT) &
+		DDRPHYC_ZQ0CRN_ZDATA_MASK;
+
+	stm32mp_clk_disable(BKPSRAM);
+
+	return zdata;
+}
+
+void stm32_get_pll1_settings_from_context(void)
+{
+	struct backup_data_s *backup_data;
+	uint8_t *data;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	data = (uint8_t *)backup_data->pll1_settings;
+	stm32mp1_clk_lp_load_opp_pll1_settings(data,
+					sizeof(backup_data->pll1_settings));
+
+	stm32mp_clk_disable(BKPSRAM);
+}
+
+bool stm32_are_pll1_settings_valid_in_context(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t *data;
+	bool is_valid;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+	data = (uint32_t *)backup_data->pll1_settings;
+
+	is_valid = (data[0] == PLL1_SETTINGS_VALID_ID);
+
+	stm32mp_clk_disable(BKPSRAM);
+
+	return is_valid;
+}
+
+int stm32_save_boot_interface(uint32_t interface, uint32_t instance)
+{
+	uint32_t bkpr_itf_idx = tamp_bkpr(TAMP_BOOT_ITF_BACKUP_REG_ID);
+
+	stm32mp_clk_enable(RTCAPB);
+
+	mmio_clrsetbits_32(bkpr_itf_idx,
+			   TAMP_BOOT_ITF_MASK,
+			   ((interface << 4) | (instance & 0xFU)) <<
+			   TAMP_BOOT_ITF_SHIFT);
+
+	stm32mp_clk_disable(RTCAPB);
+
+	return 0;
+}
+
+int stm32_get_boot_interface(uint32_t *interface, uint32_t *instance)
+{
+	uint32_t backup_reg_itf;
+	uint32_t bkpr_itf_idx = tamp_bkpr(TAMP_BOOT_ITF_BACKUP_REG_ID);
+
+	stm32mp_clk_enable(RTCAPB);
+
+	backup_reg_itf = (mmio_read_32(bkpr_itf_idx) &
+			  TAMP_BOOT_ITF_MASK) >> TAMP_BOOT_ITF_SHIFT;
+
+	stm32mp_clk_disable(RTCAPB);
+
+	*interface = backup_reg_itf >> 4;
+	*instance = backup_reg_itf & 0xFU;
+
+	return 0;
+}
+
+/*
+ * When returning from STANDBY, the 64 first bytes of DDR will be overwritten
+ * during DDR DQS training. This area must then be saved before going to
+ * standby, and will be restored after
+ */
+void stm32_save_ddr_training_area(void)
+{
+	struct backup_data_s *backup_data;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	memcpy(&backup_data->ddr_training_backup,
+	       (const uint32_t *)STM32MP_DDR_BASE,
+	       TRAINING_AREA_SIZE);
+	dsb();
+
+	stm32mp_clk_disable(BKPSRAM);
+}
+
+void stm32_restore_ddr_training_area(void)
+{
+	struct backup_data_s *backup_data;
+
+	stm32mp_clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	memcpy((uint32_t *)STM32MP_DDR_BASE,
+	       &backup_data->ddr_training_backup,
+	       TRAINING_AREA_SIZE);
+	dsb();
+
+	stm32mp_clk_disable(BKPSRAM);
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_dbgmcu.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_dbgmcu.c
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2016-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#undef LOG_LEVEL
+#define LOG_LEVEL LOG_LEVEL_VERBOSE
+
+#include <assert.h>
+#include <bsec.h>
+#include <debug.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <errno.h>
+#include <mmio.h>
+#include <platform_def.h>
+#include <stm32mp1_dbgmcu.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+#include <utils_def.h>
+
+#define DBGMCU_IDC		0x0U
+#define DBGMCU_APB4FZ1		0x2CU
+
+#define DBGMCU_IDC_DEV_ID_MASK	GENMASK(11, 0)
+#define DBGMCU_IDC_REV_ID_MASK	GENMASK(31, 16)
+#define DBGMCU_IDC_REV_ID_SHIFT	16
+
+#define DBGMCU_APB4FZ1_IWDG2	BIT(2)
+
+#define TAMP_DBG_BACKUP_REG_ID	20
+#define TAMP_DBG_DEBUG		BIT(16)
+
+static uintptr_t get_rcc_base(void)
+{
+	/* This is called before stm32mp_rcc_base() is available */
+	return RCC_BASE;
+}
+
+static int stm32mp1_dbgmcu_init(void)
+{
+	uint32_t dbg_conf;
+	uintptr_t rcc_base = get_rcc_base();
+
+	dbg_conf = bsec_read_debug_conf();
+
+	if ((dbg_conf & BSEC_DBGSWGEN) == 0U) {
+		uint32_t result = bsec_write_debug_conf(dbg_conf |
+							BSEC_DBGSWGEN);
+
+		if (result != BSEC_OK) {
+			ERROR("Error enabling DBGSWGEN\n");
+			return (int)result;
+		}
+	}
+
+	if ((mmio_read_32(rcc_base + RCC_DBGCFGR) & RCC_DBGCFGR_DBGCKEN) ==
+	    0U) {
+		mmio_setbits_32(rcc_base + RCC_DBGCFGR, RCC_DBGCFGR_DBGCKEN);
+	}
+
+	return 0;
+}
+
+#if STM32MP1_DEBUG_ENABLE
+/*
+ * @brief  Get debug mode information from backup registers.
+ * @retval 1 if debug mode is enabled, 0 otherwise.
+ */
+int stm32mp1_dbgmcu_boot_debug_info(void)
+{
+	uint32_t backup_reg_dbg;
+
+	stm32mp_clk_enable(RTCAPB);
+
+	backup_reg_dbg = (mmio_read_32(tamp_bkpr(TAMP_DBG_BACKUP_REG_ID))
+			  & TAMP_DBG_DEBUG);
+
+	stm32mp_clk_disable(RTCAPB);
+
+	if (backup_reg_dbg != 0U) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Clear debug mode information in backup registers.
+ * @retval None.
+ */
+void stm32mp1_dbgmcu_clear_boot_info(void)
+{
+	stm32mp_clk_enable(RTCAPB);
+
+	mmio_clrbits_32(tamp_bkpr(TAMP_DBG_BACKUP_REG_ID),
+			TAMP_DBG_DEBUG);
+
+	stm32mp_clk_disable(RTCAPB);
+}
+
+/*
+ * @brief  Get DBGMCU debug mode in BSEC registers.
+ * @retval True if debug mode enabled, false otherwise.
+ */
+bool stm32mp1_dbgmcu_is_debug_on(void)
+{
+	uint32_t dbg_conf;
+
+	dbg_conf = bsec_read_debug_conf();
+
+	return (dbg_conf & (BSEC_SPIDEN | BSEC_SPINDEN)) != 0U;
+}
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+/*
+ * @brief  Dump 8-bits buffer content in hexadecimal.
+ * @param  buf: Pointer to the 8-bits buffer.
+ * @parma  len: Length in bytes of the dump.
+ * @retval None.
+ */
+void stm32mp1_dbgmcu_hexdump32(const void *_buf, uint32_t len)
+{
+	const uint32_t *buf = _buf;
+	uint32_t i;
+	uint32_t wc = (len + 3) / 4;
+
+	if (len == 0)
+		return;
+
+	printf("%p:", buf);
+	for (i = 0; i < wc; i++) {
+		printf(" %08x", buf[i]);
+		if (((i + 1) % 8) == 0) {
+			if ((i + 1) < wc) {
+				printf("\n");
+				printf("%p:", &buf[i + 1]);
+			}
+		} else if (((i + 1) % 4) == 0) {
+			printf(" ");
+		}
+	}
+	printf("\n");
+}
+
+void stm32mp1_dbgmcu_hexdump8(const void *_buf, uint32_t len)
+{
+	const uint8_t *buf = _buf;
+	uint32_t i;
+
+	if (len == 0)
+		return;
+
+	printf("%p:", buf);
+	for (i = 0; i < len; i++) {
+		printf(" %02x", buf[i]);
+		if (((i + 1) % 16) == 0) {
+			if ((i + 1) < len) {
+				printf("\n");
+				printf("%p:", &buf[i + 1]);
+			}
+		} else if (((i + 1) % 8) == 0) {
+			printf(" ");
+		}
+	}
+	printf("\n");
+}
+#endif
+#endif
+
+/*
+ * @brief  Get silicon revision from DBGMCU registers.
+ * @param  chip_version: pointer to the read value.
+ * @retval 0 on success, negative value on failure.
+ */
+int stm32mp1_dbgmcu_get_chip_version(uint32_t *chip_version)
+{
+	assert(chip_version != NULL);
+
+	if (stm32mp1_dbgmcu_init() != 0) {
+		return -EPERM;
+	}
+
+	*chip_version = (mmio_read_32(DBGMCU_BASE + DBGMCU_IDC) &
+			 DBGMCU_IDC_REV_ID_MASK) >> DBGMCU_IDC_REV_ID_SHIFT;
+
+	return 0;
+}
+
+/*
+ * @brief  Get device ID from DBGMCU registers.
+ * @param  chip_version: pointer to the read value.
+ * @retval 0 on success, negative value on failure.
+ */
+int stm32mp1_dbgmcu_get_chip_dev_id(uint32_t *chip_dev_id)
+{
+	assert(chip_dev_id != NULL);
+
+	if (stm32mp1_dbgmcu_init() != 0) {
+		return -EPERM;
+	}
+
+	*chip_dev_id = mmio_read_32(DBGMCU_BASE + DBGMCU_IDC) &
+		       DBGMCU_IDC_DEV_ID_MASK;
+
+	return 0;
+}
+
+/*
+ * @brief  Freeze IWDG2 in debug mode.
+ * @retval None.
+ */
+int stm32mp1_dbgmcu_freeze_iwdg2(void)
+{
+	if (stm32mp1_dbgmcu_init() == 0) {
+		uint32_t dbg_conf = bsec_read_debug_conf();
+
+		if (((dbg_conf & BSEC_SPIDEN) != 0U) ||
+		    ((dbg_conf & BSEC_SPINDEN) != 0U)) {
+			mmio_setbits_32(DBGMCU_BASE + DBGMCU_APB4FZ1,
+					DBGMCU_APB4FZ1_IWDG2);
+		}
+
+		return 0;
+	}
+
+	return -EPERM;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_def.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_def.h
@@ -0,0 +1,567 @@
+/*
+ * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_DEF_H
+#define STM32MP1_DEF_H
+
+#ifndef __ASSEMBLY__
+#include <boot_api.h>
+#include <bsec.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include <dt-bindings/reset/stm32mp1-resets.h>
+#include <dt-bindings/soc/st,stm32-etzpc.h>
+#include <etzpc.h>
+#include <stm32mp_auth.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp_shres_helpers.h>
+#include <stm32mp1_calib.h>
+#include <stm32mp1_clkfunc.h>
+#include <stm32mp1_clk.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_dbgmcu.h>
+#include <stm32mp1_ddr.h>
+#include <stm32mp1_ddr_helpers.h>
+#include <stm32mp1_ddr_regs.h>
+#include <stm32mp1_private.h>
+#include <stm32mp1_pwr.h>
+#include <stm32mp1_ram.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+#include <stm32mp1_usb_desc.h>
+#include <stm32mp1xx_hal_uart.h>
+#include <usb_ctx.h>
+#endif
+#include <tbbr_img_def.h>
+#include <utils_def.h>
+#include <xlat_tables_defs.h>
+
+#define AUTHENTICATE_BL33
+
+/*******************************************************************************
+ * CHIP ID
+ ******************************************************************************/
+#define STM32MP157C_PART_NB	U(0x05000000)
+#define STM32MP157A_PART_NB	U(0x05000001)
+#define STM32MP153C_PART_NB	U(0x05000024)
+#define STM32MP153A_PART_NB	U(0x05000025)
+#define STM32MP151C_PART_NB	U(0x0500002E)
+#define STM32MP151A_PART_NB	U(0x0500002F)
+#define STM32MP157F_PART_NB	U(0x05000080)
+#define STM32MP157D_PART_NB	U(0x05000081)
+#define STM32MP153F_PART_NB	U(0x050000A4)
+#define STM32MP153D_PART_NB	U(0x050000A5)
+#define STM32MP151F_PART_NB	U(0x050000AE)
+#define STM32MP151D_PART_NB	U(0x050000AF)
+
+#define STM32MP1_REV_A		U(0x1000)
+#define STM32MP1_REV_B		U(0x2000)
+#define STM32MP1_REV_Z		U(0x2001)
+
+/*******************************************************************************
+ * PACKAGE ID
+ ******************************************************************************/
+#define PKG_AA_LBGA448		U(4)
+#define PKG_AB_LBGA354		U(3)
+#define PKG_AC_TFBGA361		U(2)
+#define PKG_AD_TFBGA257		U(1)
+
+/*******************************************************************************
+ * BOOT PARAM
+ ******************************************************************************/
+#define BOOT_PARAM_ADDR			U(0x2FFC0078)
+
+/*******************************************************************************
+ * STM32MP1 memory map related constants
+ ******************************************************************************/
+#define STM32MP_ROM_BASE		U(0x00000000)
+#define STM32MP_ROM_SIZE		U(0x00020000)
+
+#define STM32MP_SYSRAM_BASE		U(0x2FFC0000)
+#define STM32MP_SYSRAM_SIZE		U(0x00040000)
+
+/* 384 Ko (128 x 3) Non secure from MCU available for TF*/
+#define STM32MP_SRAM_MCU_BASE		U(0x30000000)
+#define STM32MP_SRAM_MCU_SIZE		U(0x00060000)
+
+#define STM32MP_RETRAM_BASE		U(0x38000000)
+#define STM32MP_RETRAM_SIZE		U(0x00010000)
+
+#define STM32MP_BACKUP_RAM_BASE		U(0x54000000)
+#define STM32MP_BACKUP_RAM_SIZE		U(0x00001000)
+
+/* DDR configuration */
+#define STM32MP_DDR_BASE		U(0xC0000000)
+#define STM32MP_DDR_MAX_SIZE		U(0x40000000)	/* Max 1GB */
+#ifdef AARCH32_SP_OPTEE
+#define STM32MP_DDR_S_SIZE		U(0x01E00000)	/* 30 MB */
+#define STM32MP_DDR_SHMEM_SIZE		U(0x00200000)	/* 2 MB */
+#else
+#define STM32MP_DDR_S_SIZE		U(0)		/* DDR is non secure */
+#endif
+
+/* DDR power initializations */
+#ifndef __ASSEMBLY__
+enum ddr_type {
+	STM32MP_DDR3,
+	STM32MP_LPDDR2,
+	STM32MP_LPDDR3,
+};
+#endif
+
+/* Section used inside TF binaries */
+#define STM32MP_PARAM_LOAD_SIZE		U(0x00002400)	/* 9 Ko for param */
+/* 256 Octets reserved for header */
+#define STM32MP_HEADER_SIZE		U(0x00000100)
+
+#define STM32MP_BINARY_BASE		(STM32MP_SYSRAM_BASE +		\
+					 STM32MP_PARAM_LOAD_SIZE +	\
+					 STM32MP_HEADER_SIZE)
+
+#define STM32MP_BINARY_SIZE		(STM32MP_SYSRAM_SIZE -		\
+					 (STM32MP_PARAM_LOAD_SIZE +	\
+					  STM32MP_HEADER_SIZE))
+
+#ifdef AARCH32_SP_OPTEE
+#define STM32MP_BL32_SIZE		U(0)
+
+#define STM32MP_OPTEE_BASE		STM32MP_SYSRAM_BASE
+
+#define STM32MP_OPTEE_SIZE		(STM32MP_DTB_BASE -  \
+					 STM32MP_OPTEE_BASE)
+#else
+#if STACK_PROTECTOR_ENABLED
+#define STM32MP_BL32_SIZE		U(0x00012000)	/* 72 Ko for BL32 */
+#else
+#define STM32MP_BL32_SIZE		U(0x00011000)	/* 68 Ko for BL32 */
+#endif
+#endif
+
+#define STM32MP_BL32_BASE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_SYSRAM_SIZE - \
+					 STM32MP_BL32_SIZE)
+
+#ifdef AARCH32_SP_OPTEE
+#if STACK_PROTECTOR_ENABLED
+#define STM32MP_BL2_SIZE		U(0x0001A000)	/* 104 Ko for BL2 */
+#else
+#define STM32MP_BL2_SIZE		U(0x00018000)	/* 96 Ko for BL2 */
+#endif
+#else
+#if STACK_PROTECTOR_ENABLED
+#define STM32MP_BL2_SIZE		U(0x00019000)	/* 100 Ko for BL2 */
+#else
+#define STM32MP_BL2_SIZE		U(0x00017000)	/* 92 Ko for BL2 */
+#endif
+#endif
+
+#define STM32MP_BL2_BASE		(STM32MP_BL32_BASE - \
+					 STM32MP_BL2_SIZE)
+
+#if defined(STM32MP_USB)
+/* BL2 and BL32/sp_min require 5 finer granularity tables */
+ #define MAX_XLAT_TABLES			U(5)		/* 20 Ko for mapping */
+#else
+/* BL2 and BL32/sp_min require 4 finer granularity tables */
+ #define MAX_XLAT_TABLES			U(4)		/* 16 Ko for mapping */
+#endif
+
+/*
+ * MAX_MMAP_REGIONS is usually:
+ * BL stm32mp1_mmap size + mmap regions in *_plat_arch_setup
+ */
+#if defined(IMAGE_BL2)
+ #if defined(STM32MP_USB)
+  #define MAX_MMAP_REGIONS		12
+ #else
+  #define MAX_MMAP_REGIONS		11
+ #endif
+#endif
+#if defined(IMAGE_BL32)
+   #define MAX_MMAP_REGIONS		6
+#endif
+
+#define XLAT_TABLE_OCTETSIZE		U(0x1000)
+#define PLAT_XLAT_SIZE			(MAX_XLAT_TABLES *	\
+					 XLAT_TABLE_OCTETSIZE)
+
+#define PLAT_XLAT_BASE			(STM32MP_BL2_BASE -	\
+					 PLAT_XLAT_SIZE)
+
+/*
+ * Uncomment this to get the xlat tables back in each binary image
+ * (xlat_table sections in .lds)
+ *
+ * #undef PLAT_XLAT_BASE
+ */
+
+/* DTB initialization value */
+#define STM32MP_DTB_SIZE		U(0x00005000)	/* 20Ko for DTB */
+
+#define STM32MP_DTB_BASE		(PLAT_XLAT_BASE -	\
+					 STM32MP_DTB_SIZE)
+
+#define STM32MP_BL33_BASE		(STM32MP_DDR_BASE + U(0x100000))
+
+/* Define Temporary Stack size use during low power mode */
+#define STM32MP_INT_STACK_SIZE		0x400
+
+/*******************************************************************************
+ * STM32MP1 RAW partition offset for MTD devices
+ ******************************************************************************/
+#define STM32MP_NOR_BL33_OFFSET		U(0x00080000)
+#ifdef AARCH32_SP_OPTEE
+#define STM32MP_NOR_TEEH_OFFSET		U(0x00280000)
+#define STM32MP_NOR_TEED_OFFSET		U(0x002C0000)
+#define STM32MP_NOR_TEEX_OFFSET		U(0x00300000)
+#endif
+
+#define STM32MP_NAND_BL33_OFFSET	U(0x00200000)
+#ifdef AARCH32_SP_OPTEE
+#define STM32MP_NAND_TEEH_OFFSET	U(0x00600000)
+#define STM32MP_NAND_TEED_OFFSET	U(0x00680000)
+#define STM32MP_NAND_TEEX_OFFSET	U(0x00700000)
+#endif
+
+/*******************************************************************************
+ * STM32MP1 device/io map related constants (used for MMU)
+ ******************************************************************************/
+#define STM32MP1_DEVICE1_BASE		U(0x40000000)
+#define STM32MP1_DEVICE1_SIZE		U(0x40000000)
+
+#define STM32MP1_DEVICE2_BASE		U(0x80000000)
+#define STM32MP1_DEVICE2_SIZE		U(0x40000000)
+
+/*******************************************************************************
+ * STM32MP1 RCC
+ ******************************************************************************/
+#define RCC_BASE			U(0x50000000)
+
+/*******************************************************************************
+ * STM32MP1 PWR
+ ******************************************************************************/
+#define PWR_BASE			U(0x50001000)
+
+/*******************************************************************************
+ * STM32MP1 EXTI
+ ******************************************************************************/
+#define EXTI_BASE			U(0x5000D000)
+#define EXTI_TZENR1			U(0x14)
+#define EXTI_RPR3			U(0x4C)
+#define EXTI_FPR3			U(0x50)
+#define EXTI_C1IMR1			U(0x80)
+#define EXTI_C2IMR1			U(0xC0)
+#define EXTI_C2IMR2			U(0xD0)
+#define EXTI_C2IMR3			U(0xE0)
+#define EXTI_TZENR1_TZEN18		BIT(18)
+#define EXTI_IMR1_IM18			BIT(18)
+#define EXTI_RPR3_RPIF65		BIT(1)
+#define EXTI_FPR3_FPIF65		BIT(1)
+
+/*******************************************************************************
+ * STM32MP1 RTC
+ ******************************************************************************/
+#define RTC_BASE			U(0x5C004000)
+
+/*******************************************************************************
+ * STM32MP1 GPIO
+ ******************************************************************************/
+#define GPIOA_BASE			U(0x50002000)
+#define GPIOB_BASE			U(0x50003000)
+#define GPIOC_BASE			U(0x50004000)
+#define GPIOD_BASE			U(0x50005000)
+#define GPIOE_BASE			U(0x50006000)
+#define GPIOF_BASE			U(0x50007000)
+#define GPIOG_BASE			U(0x50008000)
+#define GPIOH_BASE			U(0x50009000)
+#define GPIOI_BASE			U(0x5000A000)
+#define GPIOJ_BASE			U(0x5000B000)
+#define GPIOK_BASE			U(0x5000C000)
+#define GPIOZ_BASE			U(0x54004000)
+#define GPIO_BANK_OFFSET		U(0x1000)
+
+/* Bank IDs used in GPIO driver API */
+#define GPIO_BANK_A			U(0)
+#define GPIO_BANK_B			U(1)
+#define GPIO_BANK_C			U(2)
+#define GPIO_BANK_D			U(3)
+#define GPIO_BANK_E			U(4)
+#define GPIO_BANK_F			U(5)
+#define GPIO_BANK_G			U(6)
+#define GPIO_BANK_H			U(7)
+#define GPIO_BANK_I			U(8)
+#define GPIO_BANK_J			U(9)
+#define GPIO_BANK_K			U(10)
+#define GPIO_BANK_Z			U(25)
+
+#define STM32MP_GPIOZ_PIN_MAX_COUNT	8
+
+/*******************************************************************************
+ * STM32MP1 UART
+ ******************************************************************************/
+#define USART1_BASE			U(0x5C000000)
+#define USART2_BASE			U(0x4000E000)
+#define USART3_BASE			U(0x4000F000)
+#define UART4_BASE			U(0x40010000)
+#define UART5_BASE			U(0x40011000)
+#define USART6_BASE			U(0x44003000)
+#define UART7_BASE			U(0x40018000)
+#define UART8_BASE			U(0x40019000)
+#define STM32MP_UART_BAUDRATE		U(115200)
+
+/* For UART crash console */
+#define STM32MP_DEBUG_USART_BASE	UART4_BASE
+/* UART4 on HSI@64MHz, TX on GPIOG11 Alternate 6 */
+#define STM32MP_DEBUG_USART_CLK_FRQ	64000000
+#define DEBUG_UART_TX_GPIO_BANK_ADDRESS	GPIOG_BASE
+#define DEBUG_UART_TX_GPIO_BANK_CLK_REG	RCC_MP_AHB4ENSETR
+#define DEBUG_UART_TX_GPIO_BANK_CLK_EN	RCC_MP_AHB4ENSETR_GPIOGEN
+#define DEBUG_UART_TX_GPIO_PORT		11
+#define DEBUG_UART_TX_GPIO_ALTERNATE	6
+#define DEBUG_UART_TX_CLKSRC_REG	RCC_UART24CKSELR
+#define DEBUG_UART_TX_CLKSRC		RCC_UART24CKSELR_HSI
+#define DEBUG_UART_TX_EN_REG		RCC_MP_APB1ENSETR
+#define DEBUG_UART_TX_EN		RCC_MP_APB1ENSETR_UART4EN
+
+/*******************************************************************************
+ * STM32MP1 TZPC
+ ******************************************************************************/
+#define STM32MP1_ETZPC_BASE		U(0x5C007000)
+#define STM32MP1_ETZPC_SIZE		U(0x000003FF)
+
+#define STM32MP1_ETZPC_TZMA_ROM_ID	U(0)
+/*SYSRAM internal RAM*/
+#define STM32MP1_ETZPC_TZMA_RAM_ID	U(1)
+
+/*******************************************************************************
+ * STM32MP1 TZC (TZ400)
+ ******************************************************************************/
+#define STM32MP1_TZC_BASE		U(0x5C006000)
+
+#define STM32MP1_TZC_A7_ID		U(0)
+#define STM32MP1_TZC_M4_ID		U(1)
+#define STM32MP1_TZC_LCD_ID		U(3)
+#define STM32MP1_TZC_GPU_ID		U(4)
+#define STM32MP1_TZC_MDMA_ID		U(5)
+#define STM32MP1_TZC_DMA_ID		U(6)
+#define STM32MP1_TZC_USB_HOST_ID	U(7)
+#define STM32MP1_TZC_USB_OTG_ID		U(8)
+#define STM32MP1_TZC_SDMMC_ID		U(9)
+#define STM32MP1_TZC_ETH_ID		U(10)
+#define STM32MP1_TZC_DAP_ID		U(15)
+
+#define STM32MP1_FILTER_BIT_ALL		U(3)
+
+/*******************************************************************************
+ * STM32MP1 SDMMC
+ ******************************************************************************/
+#define STM32MP_SDMMC1_BASE		U(0x58005000)
+#define STM32MP_SDMMC2_BASE		U(0x58007000)
+#define STM32MP_SDMMC3_BASE		U(0x48004000)
+
+#define STM32MP_MMC_INIT_FREQ			U(400000)	/*400 KHz*/
+#define STM32MP_SD_NORMAL_SPEED_MAX_FREQ	U(25000000)	/*25 MHz*/
+#define STM32MP_SD_HIGH_SPEED_MAX_FREQ		U(50000000)	/*50 MHz*/
+#define STM32MP_EMMC_NORMAL_SPEED_MAX_FREQ	U(26000000)	/*26 MHz*/
+#define STM32MP_EMMC_HIGH_SPEED_MAX_FREQ	U(52000000)	/*52 MHz*/
+
+/*******************************************************************************
+ * STM32MP1 QSPI
+ ******************************************************************************/
+#define STM32MP1_QSPI1_BASE		U(0x58003000)
+
+/*******************************************************************************
+ * STM32MP1 BSEC / OTP
+ ******************************************************************************/
+#define STM32MP1_BSEC_BASE		U(0x5C005000)
+#define STM32MP1_OTP_MAX_ID		0x5FU
+#define STM32MP1_UPPER_OTP_START	0x20U
+
+#define OTP_MAX_SIZE			(STM32MP1_OTP_MAX_ID + 1U)
+
+/* OTP labels */
+#define PART_NUMBER_OTP			"part_number_otp"
+#define PACKAGE_OTP			"package_otp"
+#define HW2_OTP				"hw2_otp"
+#define NAND_OTP			"nand_otp"
+#define MONOTONIC_OTP			"monotonic_otp"
+#define UID_OTP				"uid_otp"
+#define BOARD_ID_OTP			"board_id"
+
+/* OTP mask */
+/* PART NUMBER */
+#define PART_SHIFT			0
+#define PART_MASK			GENMASK_32(7, 0)
+
+/* PACKAGE */
+#define PKG_SHIFT			27
+#define PKG_MASK			GENMASK_32(29, 27)
+
+/* IWDG OTP */
+#define IWDG_HW_POS			3
+#define IWDG_FZ_STOP_POS		5
+#define IWDG_FZ_STANDBY_POS		7
+
+/* HW2 OTP */
+#define HW2_OTP_PRODUCT_BELOW_2V5	BIT(13)
+
+/* NAND OTP */
+/* NAND parameter storage flag */
+#define NAND_PARAM_STORED_IN_OTP	U(0x80000000)
+
+/* NAND page size in bytes */
+#define NAND_PAGE_SIZE_OFFSET		29
+#define NAND_PAGE_SIZE_MASK		U(0x60000000)
+#define NAND_PAGE_SIZE_2K		0
+#define NAND_PAGE_SIZE_4K		1
+#define NAND_PAGE_SIZE_8K		2
+
+/* NAND block size in pages */
+#define NAND_BLOCK_SIZE_OFFSET		27
+#define NAND_BLOCK_SIZE_MASK		U(0x18000000)
+#define NAND_BLOCK_SIZE_64_PAGES	0
+#define NAND_BLOCK_SIZE_128_PAGES	1
+#define NAND_BLOCK_SIZE_256_PAGES	2
+
+/* NAND number of block (in unit of 256 blocs) */
+#define NAND_BLOCK_NB_OFFSET		19
+#define NAND_BLOCK_NB_MASK		U(0x07F80000)
+#define NAND_BLOCK_NB_UNIT		U(256)
+
+/* NAND bus width in bits */
+#define NAND_WIDTH_OFFSET		18
+#define NAND_WIDTH_MASK			0x00040000
+
+/* NAND number of ECC bits per 512 bytes */
+#define NAND_ECC_BIT_NB_OFFSET		16
+#define NAND_ECC_BIT_NB_MASK		U(0x00030000)
+#define NAND_ECC_BIT_NB_UNSET		0
+#define NAND_ECC_BIT_NB_1_BITS		1
+#define NAND_ECC_BIT_NB_4_BITS		2
+#define NAND_ECC_BIT_NB_8_BITS		3
+
+/* MONOTONIC OTP */
+#define MAX_MONOTONIC_VALUE		32
+
+/* UID OTP */
+#define UID_WORD_NB			3
+
+/*******************************************************************************
+ * STM32MP1 FMC
+ ******************************************************************************/
+#define STM32MP_FMC_BASE		U(0x58002000)
+
+/*******************************************************************************
+ * STM32MP1 HASH
+ ******************************************************************************/
+#define HASH1_BASE			U(0x54002000)
+#define HASH_BASE			HASH1_BASE
+
+/*******************************************************************************
+ * STM32MP1 TAMP
+ ******************************************************************************/
+#define PLAT_MAX_TAMP_INT		U(5)
+#define PLAT_MAX_TAMP_EXT		U(3)
+#define TAMP_BASE			U(0x5C00A000)
+#define TAMP_SMCR			(TAMP_BASE + U(0x20))
+#define TAMP_BKP_REGISTER_BASE		(TAMP_BASE + U(0x100))
+#define TAMP_BKP_SEC_NUMBER		U(10)
+#define TAMP_BKP_SEC_WDPROT_SHIFT	U(16)
+#define TAMP_BKP_SEC_RWDPROT_SHIFT	U(0)
+
+
+#if !(defined(__LINKER__) || defined(__ASSEMBLY__))
+static inline uint32_t tamp_bkpr(uint32_t idx)
+{
+	return TAMP_BKP_REGISTER_BASE + (idx << 2);
+}
+#endif
+/*******************************************************************************
+ * STM32MP1 USB
+ ******************************************************************************/
+#define USB_OTG_BASE			U(0x49000000)
+
+/*******************************************************************************
+ * STM32MP1 DDRCTRL
+ ******************************************************************************/
+#define DDRCTRL_BASE			U(0x5A003000)
+
+/*******************************************************************************
+ * STM32MP1 DDRPHYC
+ ******************************************************************************/
+#define DDRPHYC_BASE			U(0x5A004000)
+
+/*******************************************************************************
+ * STM32MP1 IWDG
+ ******************************************************************************/
+#define IWDG_MAX_INSTANCE		U(2)
+#define IWDG1_INST			U(0)
+#define IWDG2_INST			U(1)
+
+#define IWDG1_BASE			U(0x5C003000)
+#define IWDG2_BASE			U(0x5A002000)
+
+/*******************************************************************************
+ * STM32MP1 I2C
+ ******************************************************************************/
+#define I2C4_BASE			U(0x5C002000)
+#define I2C6_BASE			U(0x5C009000)
+
+/*******************************************************************************
+ * STM32MP1 DBGMCU
+ ******************************************************************************/
+#define DBGMCU_BASE			U(0x50081000)
+
+/*******************************************************************************
+ * STM32MP1 SPI
+ ******************************************************************************/
+#define SPI6_BASE	U(0x5C001000)
+
+/*******************************************************************************
+ * STM32MP1 RNG
+ ******************************************************************************/
+#define RNG1_BASE	U(0x54003000)
+
+/*******************************************************************************
+ * STM32MP1 CRYP
+ ******************************************************************************/
+#define CRYP1_BASE	U(0x54001000)
+
+/*******************************************************************************
+ * STM32MP1 TIMERS
+ ******************************************************************************/
+#define TIM12_BASE			U(0x40006000)
+#define TIM15_BASE			U(0x44006000)
+#define TIM_MAX_INSTANCE		U(2)
+
+/*******************************************************************************
+ * STM32MP1 OPP
+ ******************************************************************************/
+#define PLAT_OPP_ID1			U(1)
+#define PLAT_OPP_ID2			U(2)
+#define PLAT_MAX_OPP_NB			U(2)
+#define PLAT_MAX_PLLCFG_NB		U(6)
+
+/*******************************************************************************
+ * DEBUG
+ ******************************************************************************/
+/*#define  ICACHE_OFF*/
+/*#define  DCACHE_OFF*/
+/*#define  MMU_OFF*/
+
+/*******************************************************************************
+ * Device Tree defines
+ ******************************************************************************/
+#define DT_NVMEM_LAYOUT_COMPAT		"st,stm32-nvmem-layout"
+#define DT_OPP_COMPAT			"operating-points-v2"
+#define DT_PWR_COMPAT			"st,stm32mp1-pwr"
+#define DT_RCC_CLK_COMPAT		"st,stm32mp1-rcc"
+#define DT_SYSCFG_COMPAT		"st,stm32mp157-syscfg"
+
+#define DT_PLL1_NODE_NAME		"st,pll@0"
+
+#endif /* STM32MP1_DEF_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_gic.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_gic.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright (c) 2016-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <bl_common.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <gicv2.h>
+#include <libfdt.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <utils.h>
+
+struct stm32_gic_instance {
+	uint32_t cells;
+	uint32_t phandle_node;
+};
+
+/******************************************************************************
+ * On a GICv2 system, the Group 1 secure interrupts are treated as Group 0
+ * interrupts.
+ *****************************************************************************/
+static const interrupt_prop_t stm32mp1_interrupt_props[] = {
+	PLATFORM_G1S_PROPS(GICV2_INTR_GROUP0),
+	PLATFORM_G0_PROPS(GICV2_INTR_GROUP0)
+};
+
+/* Fix target_mask_array as secondary core is not able to initialize it */
+static unsigned int target_mask_array[PLATFORM_CORE_COUNT] = {1, 2};
+
+static gicv2_driver_data_t platform_gic_data = {
+	.interrupt_props = stm32mp1_interrupt_props,
+	.interrupt_props_num = ARRAY_SIZE(stm32mp1_interrupt_props),
+	.target_masks = target_mask_array,
+	.target_masks_num = ARRAY_SIZE(target_mask_array),
+};
+
+static struct stm32_gic_instance stm32_gic;
+
+static uint32_t enable_gic_interrupt(const fdt32_t *array)
+{
+	unsigned int id, cfg;
+
+	switch (fdt32_to_cpu(*array)) {
+	case GIC_SPI:
+		id = MIN_SPI_ID;
+		break;
+
+	case GIC_PPI:
+		id = MIN_PPI_ID;
+		break;
+
+	default:
+		id = MIN_SGI_ID;
+		break;
+	}
+
+	id += fdt32_to_cpu(*(array + 1));
+	cfg = (fdt32_to_cpu(*(array + 2)) < IRQ_TYPE_LEVEL_HIGH) ?
+		GIC_INTR_CFG_EDGE : GIC_INTR_CFG_LEVEL;
+
+	if ((id >= MIN_SPI_ID) && (id <= MAX_SPI_ID)) {
+		VERBOSE("Enable IT %i\n", id);
+		gicv2_set_interrupt_type(id, GICV2_INTR_GROUP0);
+		gicv2_set_interrupt_priority(id, STM32MP1_IRQ_SEC_SPI_PRIO);
+		gicv2_set_spi_routing(id, STM32MP_PRIMARY_CPU);
+		gicv2_interrupt_set_cfg(id, cfg);
+		gicv2_enable_interrupt(id);
+	}
+
+	return id;
+}
+
+static void find_next_interrupt(const fdt32_t **array)
+{
+	int node;
+	const fdt32_t *cuint;
+	void *fdt;
+
+	assert(fdt32_to_cpu(**array) != stm32_gic.phandle_node);
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	node = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(**array));
+	if (node < 0) {
+		panic();
+	}
+
+	cuint = fdt_getprop(fdt, node, "#interrupt-cells", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	*array += fdt32_to_cpu(*cuint) + 1;
+}
+
+void stm32mp1_gic_init(void)
+{
+	int node;
+	void *fdt;
+	const fdt32_t *cuint;
+	struct dt_node_info dt_gic;
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	node = dt_get_node(&dt_gic, -1, "arm,cortex-a7-gic");
+	if (node < 0) {
+		panic();
+	}
+
+	platform_gic_data.gicd_base = dt_gic.base;
+
+	cuint = fdt_getprop(fdt, node, "reg", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	platform_gic_data.gicc_base = fdt32_to_cpu(*(cuint + 2));
+
+	cuint = fdt_getprop(fdt, node, "#interrupt-cells", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	stm32_gic.cells = fdt32_to_cpu(*cuint);
+
+	stm32_gic.phandle_node = fdt_get_phandle(fdt, node);
+	if (stm32_gic.phandle_node == 0U) {
+		panic();
+	}
+
+	gicv2_driver_init(&platform_gic_data);
+	gicv2_distif_init();
+
+	stm32mp1_gic_pcpu_init();
+}
+
+void stm32mp1_gic_pcpu_init(void)
+{
+	gicv2_pcpu_distif_init();
+	gicv2_set_pe_target_mask(plat_my_core_pos());
+	gicv2_cpuif_enable();
+}
+
+int stm32_gic_enable_spi(int node, const char *name)
+{
+	const fdt32_t *cuint;
+	void *fdt;
+	int res, len;
+	int index = -1;
+	int i = 0;
+	int id = -1;
+	bool extended;
+	const fdt32_t *t_array, *max;
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	cuint = fdt_getprop(fdt, node, "interrupt-parent", NULL);
+	if (cuint != NULL) {
+		if (stm32_gic.phandle_node != fdt32_to_cpu(*cuint)) {
+			return -FDT_ERR_NOTFOUND;
+		}
+	}
+
+	if (name != NULL) {
+		index = fdt_stringlist_search(fdt, node, "interrupt-names",
+					      name);
+		if (index < 0) {
+			return index;
+		}
+	}
+
+	res = fdt_get_interrupt(node, &t_array, &len, &extended);
+	if (res < 0) {
+		return res;
+	}
+
+	max = t_array + (len / sizeof(uint32_t));
+
+	while ((t_array < max) && ((i <= index) || (index == -1))) {
+		if (!extended) {
+			if ((index == -1) || (i == index)) {
+				id = enable_gic_interrupt(t_array);
+			}
+			t_array += stm32_gic.cells;
+		} else {
+			if (fdt32_to_cpu(*t_array) == stm32_gic.phandle_node) {
+				t_array++;
+				if ((index == -1) || (i == index)) {
+					id = enable_gic_interrupt(t_array);
+				}
+				t_array += stm32_gic.cells;
+			} else {
+				find_next_interrupt(&t_array);
+			}
+		}
+		i++;
+	}
+
+	return id;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_low_power.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_low_power.c
@@ -0,0 +1,299 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <assert.h>
+#include <boot_api.h>
+#include <debug.h>
+#include <delay_timer.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+#include <gic_common.h>
+#include <gicv2.h>
+#include <libfdt.h>
+#include <mmio.h>
+#include <platform.h>
+#include <stm32_iwdg.h>
+#include <stm32_rtc.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp1_clk.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_ddr_helpers.h>
+#include <stm32mp1_low_power.h>
+#include <stm32mp1_private.h>
+#include <stm32mp1_pwr.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+
+static unsigned int gicc_pmr;
+static struct stm32_rtc_calendar sleep_time;
+static bool enter_cstop_done;
+static uint8_t int_stack[STM32MP_INT_STACK_SIZE];
+
+extern void wfi_svc_int_enable(uintptr_t stack_addr);
+
+struct pwr_lp_config {
+	uint32_t pwr_cr1;
+	uint32_t pwr_mpucr;
+	const char *regul_suspend_node_name;
+};
+
+#define PWR_CR1_MASK	(PWR_CR1_LPDS | PWR_CR1_LPCFG | PWR_CR1_LVDS)
+#define PWR_MPUCR_MASK	(PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF | PWR_MPUCR_PDDS)
+
+static const struct pwr_lp_config config_pwr[STM32_PM_MAX_SOC_MODE] = {
+	[STM32_PM_CSLEEP_RUN] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = NULL,
+	},
+	[STM32_PM_CSTOP_ALLOW_STOP] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = NULL,
+	},
+	[STM32_PM_CSTOP_ALLOW_LP_STOP] = {
+		.pwr_cr1 = PWR_CR1_LPDS,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = "lp-stop",
+	},
+	[STM32_PM_CSTOP_ALLOW_LPLV_STOP] = {
+		.pwr_cr1 = PWR_CR1_LVDS | PWR_CR1_LPDS | PWR_CR1_LPCFG,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF,
+		.regul_suspend_node_name = "lplv-stop",
+	},
+	[STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF |
+			PWR_MPUCR_PDDS,
+		.regul_suspend_node_name = "standby-ddr-sr",
+	},
+	[STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = PWR_MPUCR_CSTDBYDIS | PWR_MPUCR_CSSF |
+			PWR_MPUCR_PDDS,
+		.regul_suspend_node_name = "standby-ddr-off",
+	},
+	[STM32_PM_SHUTDOWN] = {
+		.pwr_cr1 = 0U,
+		.pwr_mpucr = 0U,
+		.regul_suspend_node_name = "standby-ddr-off",
+	},
+};
+
+#define GICC_PMR_PRIORITY_8	U(0x8)
+
+/*
+ * stm32_enter_cstop - Prepare CSTOP mode
+ *
+ * @mode - Target low power mode
+ * @nsec_addr - Non secure resume entry point
+ * Return 0 if succeed to suspend, non 0 else.
+ */
+static void enter_cstop(uint32_t mode, uint32_t nsec_addr)
+{
+	uint32_t zq0cr0_zdata;
+	uint32_t bkpr_core1_addr =
+		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+	uint32_t bkpr_core1_magic =
+		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+	uint32_t pwr_cr1 = config_pwr[mode].pwr_cr1;
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	stm32mp1_syscfg_disable_io_compensation();
+
+	/* Switch to Software Self-Refresh mode */
+	ddr_set_sr_mode(DDR_SSR_MODE);
+
+	dcsw_op_all(DC_OP_CISW);
+
+	stm32_clean_context();
+
+	if (mode == STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR) {
+		/*
+		 * The first 64 bytes of DDR need to be saved for DDR DQS
+		 * training
+		 */
+		stm32_save_ddr_training_area();
+	}
+
+	stm32mp1_clk_mpu_suspend();
+
+	/* Clear RCC interrupt before enabling it */
+	mmio_setbits_32(rcc_base + RCC_MP_CIFR, RCC_MP_CIFR_WKUPF);
+
+	/* Enable RCC Wake-up */
+	mmio_setbits_32(rcc_base + RCC_MP_CIER, RCC_MP_CIFR_WKUPF);
+
+	/* Configure low power mode */
+	mmio_clrsetbits_32(pwr_base + PWR_MPUCR, PWR_MPUCR_MASK,
+			   config_pwr[mode].pwr_mpucr);
+	mmio_clrsetbits_32(pwr_base + PWR_CR1, PWR_CR1_MASK,
+			   pwr_cr1);
+
+	/* Clear RCC pending interrupt flags */
+	mmio_write_32(rcc_base + RCC_MP_CIFR, RCC_MP_CIFR_MASK);
+
+	/* Request CSTOP mode to RCC */
+	mmio_setbits_32(rcc_base + RCC_MP_SREQSETR,
+			RCC_MP_SREQSETR_STPREQ_P0 | RCC_MP_SREQSETR_STPREQ_P1);
+
+	stm32_iwdg_refresh(IWDG2_INST);
+
+	gicc_pmr = plat_ic_set_priority_mask(GICC_PMR_PRIORITY_8);
+
+	/*
+	 * Set DDR in Self-refresh, even if no return address is given.
+	 * This is also the procedure awaited when switching off power supply.
+	 */
+	if (ddr_standby_sr_entry(&zq0cr0_zdata) != 0) {
+		return;
+	}
+
+	stm32mp_clk_enable(RTCAPB);
+
+	mmio_write_32(bkpr_core1_addr, 0);
+	mmio_write_32(bkpr_core1_magic, 0);
+
+	if (mode == STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR) {
+		/*
+		 * Save non-secure world entrypoint after standby in Backup
+		 * register
+		 */
+		mmio_write_32(bkpr_core1_addr, nsec_addr);
+		mmio_write_32(bkpr_core1_magic,
+			      BOOT_API_A7_CORE0_MAGIC_NUMBER);
+
+		if (stm32_save_context(zq0cr0_zdata) != 0) {
+			panic();
+		}
+
+		/* Keep retention and backup RAM content in standby */
+		mmio_setbits_32(pwr_base + PWR_CR2, PWR_CR2_BREN |
+				PWR_CR2_RREN);
+		while ((mmio_read_32(pwr_base + PWR_CR2) &
+			(PWR_CR2_BRRDY | PWR_CR2_RRRDY)) == 0U) {
+			;
+		}
+	}
+
+	stm32mp_clk_disable(RTCAPB);
+
+	stm32_rtc_get_calendar(&sleep_time);
+
+	enter_cstop_done = true;
+}
+
+/*
+ * stm32_exit_cstop - Exit from CSTOP mode
+ */
+void stm32_exit_cstop(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	unsigned long long stdby_time_in_ms;
+	struct stm32_rtc_calendar current_calendar;
+
+	if (!enter_cstop_done) {
+		return;
+	}
+
+	enter_cstop_done = false;
+
+	stm32mp1_clk_mpu_resume();
+
+	if (ddr_sw_self_refresh_exit() != 0) {
+		panic();
+	}
+
+	/* Restore Self-Refresh mode saved in enter_cstop() */
+	ddr_restore_sr_mode();
+
+	plat_ic_set_priority_mask(gicc_pmr);
+
+	/* Disable RCC Wake-up */
+	mmio_clrbits_32(rcc_base + RCC_MP_CIER, RCC_MP_CIFR_WKUPF);
+
+	/* Disable STOP request */
+	mmio_setbits_32(rcc_base + RCC_MP_SREQCLRR,
+			RCC_MP_SREQSETR_STPREQ_P0 | RCC_MP_SREQSETR_STPREQ_P1);
+
+	dsb();
+	isb();
+
+	/* Disable retention and backup RAM content after stop */
+	mmio_clrbits_32(pwr_base + PWR_CR2, PWR_CR2_BREN | PWR_CR2_RREN);
+
+	/* Update STGEN counter with low power mode duration */
+	stm32_rtc_get_calendar(&current_calendar);
+
+	stdby_time_in_ms = stm32_rtc_diff_calendar(&current_calendar,
+						   &sleep_time);
+
+	stm32mp1_stgen_restore_counter(stm32_get_stgen_from_context(),
+				       stdby_time_in_ms);
+
+	stm32mp1_syscfg_enable_io_compensation();
+}
+
+static void enter_shutdown(void)
+{
+	/* Set DDR in Self-refresh before shutting down the platform */
+	if (ddr_standby_sr_entry(NULL) != 0) {
+		WARN("DDR can't be set in Self-refresh mode\n");
+	}
+}
+
+static void enter_csleep(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+
+	mmio_clrsetbits_32(pwr_base + PWR_MPUCR, PWR_MPUCR_MASK,
+			   config_pwr[STM32_PM_CSLEEP_RUN].pwr_mpucr);
+	mmio_clrsetbits_32(pwr_base + PWR_CR1, PWR_CR1_MASK,
+			   config_pwr[STM32_PM_CSLEEP_RUN].pwr_cr1);
+
+	stm32_pwr_down_wfi();
+}
+
+void stm32_enter_low_power(uint32_t mode, uint32_t nsec_addr)
+{
+	switch (mode) {
+	case STM32_PM_SHUTDOWN:
+		enter_shutdown();
+		break;
+
+	case STM32_PM_CSLEEP_RUN:
+		enter_csleep();
+		break;
+
+	default:
+		enter_cstop(mode, nsec_addr);
+		break;
+	}
+}
+
+void stm32_pwr_down_wfi(void)
+{
+	uint32_t interrupt = GIC_SPURIOUS_INTERRUPT;
+
+	stm32mp1_calib_set_wakeup(false);
+
+	while (interrupt == GIC_SPURIOUS_INTERRUPT &&
+	       !stm32mp1_calib_get_wakeup()) {
+		wfi_svc_int_enable((uintptr_t)&int_stack[0]);
+
+		interrupt = gicv2_acknowledge_interrupt();
+
+		if (interrupt != GIC_SPURIOUS_INTERRUPT) {
+			gicv2_end_of_interrupt(interrupt);
+		}
+
+		stm32_iwdg_refresh(IWDG2_INST);
+	}
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_pm.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_pm.c
@@ -0,0 +1,318 @@
+/*
+ * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <assert.h>
+#include <boot_api.h>
+#include <bsec.h>
+#include <debug.h>
+#include <delay_timer.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <errno.h>
+#include <gic_common.h>
+#include <gicv2.h>
+#include <mmio.h>
+#include <platform_def.h>
+#include <platform.h>
+#include <psci.h>
+#include <stm32mp_common.h>
+#include <stm32mp1_low_power.h>
+#include <stm32mp1_power_config.h>
+#include <stm32mp1_private.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+
+static uintptr_t stm32_sec_entrypoint;
+static uint32_t cntfrq_core0;
+static uintptr_t saved_entrypoint;
+
+/*******************************************************************************
+ * STM32MP1 handler called when a CPU is about to enter standby.
+ * call by core 1 to enter in wfi
+ ******************************************************************************/
+static void stm32_cpu_standby(plat_local_state_t cpu_state)
+{
+	uint32_t interrupt = GIC_SPURIOUS_INTERRUPT;
+
+	assert(cpu_state == ARM_LOCAL_STATE_RET);
+
+	/*
+	 * Enter standby state.
+	 * Synchronize on memory accesses and instruction flow before the WFI
+	 * instruction.
+	 */
+	dsb();
+	isb();
+	while (interrupt == GIC_SPURIOUS_INTERRUPT) {
+		wfi();
+
+		/* Acknoledge IT */
+		interrupt = gicv2_acknowledge_interrupt();
+		/* If Interrupt == 1022 it will be acknowledged by non secure */
+		if ((interrupt != PENDING_G1_INTID) &&
+		    (interrupt != GIC_SPURIOUS_INTERRUPT)) {
+			gicv2_end_of_interrupt(interrupt);
+		}
+	}
+}
+
+/*******************************************************************************
+ * STM32MP1 handler called when a power domain is about to be turned on. The
+ * mpidr determines the CPU to be turned on.
+ * call by core 0 to activate core 1
+ ******************************************************************************/
+static int stm32_pwr_domain_on(u_register_t mpidr)
+{
+	unsigned long current_cpu_mpidr = read_mpidr_el1();
+	uint32_t bkpr_core1_addr =
+		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+	uint32_t bkpr_core1_magic =
+		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+
+	if (stm32mp_is_single_core()) {
+		return PSCI_E_INTERN_FAIL;
+	}
+
+	if (mpidr == current_cpu_mpidr) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	/* Reset backup register content */
+	mmio_write_32(bkpr_core1_magic, 0);
+
+	/* Need to send additional IT 0 after individual core 1 reset */
+	gicv2_raise_sgi(ARM_IRQ_NON_SEC_SGI_0, STM32MP_SECONDARY_CPU);
+
+	/* Wait for this IT to be acknowledged by ROM code. */
+	udelay(10);
+
+	if ((stm32_sec_entrypoint < STM32MP_SYSRAM_BASE) ||
+	    (stm32_sec_entrypoint > (STM32MP_SYSRAM_BASE +
+				     (STM32MP_SYSRAM_SIZE - 1)))) {
+		return PSCI_E_INVALID_ADDRESS;
+	}
+
+	stm32mp_clk_enable(RTCAPB);
+
+	cntfrq_core0 = read_cntfrq_el0();
+
+	/* Write entrypoint in backup RAM register */
+	mmio_write_32(bkpr_core1_addr, stm32_sec_entrypoint);
+
+	/* Write magic number in backup register */
+	mmio_write_32(bkpr_core1_magic, BOOT_API_A7_CORE1_MAGIC_NUMBER);
+
+	stm32mp_clk_disable(RTCAPB);
+
+	/* Generate an IT to core 1 */
+	gicv2_raise_sgi(ARM_IRQ_SEC_SGI_0, STM32MP_SECONDARY_CPU);
+
+	return PSCI_E_SUCCESS;
+}
+
+/*******************************************************************************
+ * STM32MP1 handler called when a power domain is about to be turned off. The
+ * target_state encodes the power state that each level should transition to.
+ ******************************************************************************/
+static void stm32_pwr_domain_off(const psci_power_state_t *target_state)
+{
+	/* Nothing to do */
+}
+
+/*******************************************************************************
+ * STM32MP1 handler called when a power domain is about to be suspended. The
+ * target_state encodes the power state that each level should transition to.
+ ******************************************************************************/
+static void stm32_pwr_domain_suspend(const psci_power_state_t *target_state)
+{
+	uint32_t soc_mode = stm32mp1_get_lp_soc_mode(PSCI_MODE_SYSTEM_SUSPEND);
+
+	stm32_enter_low_power(soc_mode, saved_entrypoint);
+}
+
+/*******************************************************************************
+ * STM32MP1 handler called when a power domain has just been powered on after
+ * being turned off earlier. The target_state encodes the low power state that
+ * each level has woken up from.
+ * call by core 1 just after wake up
+ ******************************************************************************/
+static void stm32_pwr_domain_on_finish(const psci_power_state_t *target_state)
+{
+	stm32mp1_gic_pcpu_init();
+
+	write_cntfrq_el0(cntfrq_core0);
+}
+
+/*******************************************************************************
+ * STM32MP1 handler called when a power domain has just been powered on after
+ * having been suspended earlier. The target_state encodes the low power state
+ * that each level has woken up from.
+ ******************************************************************************/
+static void stm32_pwr_domain_suspend_finish(const psci_power_state_t
+					    *target_state)
+{
+	/* Nothing to do, power domain is not disabled */
+}
+
+/*******************************************************************************
+ * STM32MP1 handler called when a core tries to power itself down. If this
+ * call is made by core 0, it is a return from stop mode. In this case, we
+ * should restore previous context and jump to secure entrypoint.
+ ******************************************************************************/
+static void __dead2 stm32_pwr_domain_pwr_down_wfi(const psci_power_state_t
+						  *target_state)
+{
+	if (MPIDR_AFFLVL0_VAL(read_mpidr_el1()) == STM32MP_PRIMARY_CPU) {
+		void (*warm_entrypoint)(void) =
+			(void (*)(void))stm32_sec_entrypoint;
+
+		stm32_pwr_down_wfi();
+
+		stm32_exit_cstop();
+
+		disable_mmu_icache_secure();
+
+		warm_entrypoint();
+	}
+
+	mmio_write_32(stm32mp_rcc_base() + RCC_MP_GRSTCSETR,
+		      RCC_MP_GRSTCSETR_MPUP1RST);
+
+	/*
+	 * Synchronize on memory accesses and instruction flow before
+	 * auto-reset from the WFI instruction.
+	 */
+	dsb();
+	isb();
+	wfi();
+
+	/* This shouldn't be reached */
+	panic();
+}
+
+static void __dead2 stm32_system_off(void)
+{
+	uint32_t soc_mode = stm32mp1_get_lp_soc_mode(PSCI_MODE_SYSTEM_OFF);
+
+	if (!stm32mp_is_single_core()) {
+		/* Prepare Core 1 reset */
+		mmio_setbits_32(stm32mp_rcc_base() + RCC_MP_GRSTCSETR,
+				RCC_MP_GRSTCSETR_MPUP1RST);
+		/* Send IT to core 1 to put itself in WFI */
+		gicv2_raise_sgi(ARM_IRQ_SEC_SGI_1, STM32MP_SECONDARY_CPU);
+	}
+
+	stm32_enter_low_power(soc_mode, 0);
+
+	stm32_pwr_down_wfi();
+
+	/* This shouldn't be reached */
+	panic();
+}
+
+static void __dead2 stm32_system_reset(void)
+{
+	mmio_setbits_32(stm32mp_rcc_base() + RCC_MP_GRSTCSETR,
+			RCC_MP_GRSTCSETR_MPSYSRST);
+
+	/* Loop in case system reset is not immediately caught */
+	for ( ; ; ) {
+		;
+	}
+}
+
+static int stm32_validate_power_state(unsigned int power_state,
+				      psci_power_state_t *req_state)
+{
+	int pstate = psci_get_pstate_type(power_state);
+
+	if (pstate != 0) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	if (psci_get_pstate_pwrlvl(power_state)) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	if (psci_get_pstate_id(power_state)) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	req_state->pwr_domain_state[0] = ARM_LOCAL_STATE_RET;
+	req_state->pwr_domain_state[1] = ARM_LOCAL_STATE_RUN;
+
+	return PSCI_E_SUCCESS;
+}
+
+static int stm32_validate_ns_entrypoint(uintptr_t entrypoint)
+{
+	/* The non-secure entry point must be in DDR */
+	if (entrypoint < STM32MP_DDR_BASE) {
+		return PSCI_E_INVALID_ADDRESS;
+	}
+
+	saved_entrypoint = entrypoint;
+
+	return PSCI_E_SUCCESS;
+}
+
+static int stm32_node_hw_state(u_register_t target_cpu,
+			       unsigned int power_level)
+{
+	/*
+	 * The format of 'power_level' is implementation-defined, but 0 must
+	 * mean a CPU. Only allow level 0.
+	 */
+	if (power_level != MPIDR_AFFLVL0) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	/*
+	 * From psci view the CPU 0 is always ON,
+	 * CPU 1 can be SUSPEND or RUNNING.
+	 * Therefore do not manage POWER OFF state and always return HW_ON.
+	 */
+
+	return (int)HW_ON;
+}
+
+static void stm32_get_sys_suspend_power_state(psci_power_state_t *req_state)
+{
+	req_state->pwr_domain_state[0] = ARM_LOCAL_STATE_OFF;
+	req_state->pwr_domain_state[1] = ARM_LOCAL_STATE_OFF;
+}
+
+/*******************************************************************************
+ * Export the platform handlers. The ARM Standard platform layer will take care
+ * of registering the handlers with PSCI.
+ ******************************************************************************/
+static const plat_psci_ops_t stm32_psci_ops = {
+	.cpu_standby = stm32_cpu_standby,
+	.pwr_domain_on = stm32_pwr_domain_on,
+	.pwr_domain_off = stm32_pwr_domain_off,
+	.pwr_domain_suspend = stm32_pwr_domain_suspend,
+	.pwr_domain_on_finish = stm32_pwr_domain_on_finish,
+	.pwr_domain_suspend_finish = stm32_pwr_domain_suspend_finish,
+	.pwr_domain_pwr_down_wfi = stm32_pwr_domain_pwr_down_wfi,
+	.system_off = stm32_system_off,
+	.system_reset = stm32_system_reset,
+	.validate_power_state = stm32_validate_power_state,
+	.validate_ns_entrypoint = stm32_validate_ns_entrypoint,
+	.get_node_hw_state = stm32_node_hw_state,
+	.get_sys_suspend_power_state = stm32_get_sys_suspend_power_state,
+};
+
+/*******************************************************************************
+ * Export the platform specific power ops.
+ ******************************************************************************/
+int plat_setup_psci_ops(uintptr_t sec_entrypoint,
+			const plat_psci_ops_t **psci_ops)
+{
+	stm32_sec_entrypoint = sec_entrypoint;
+	*psci_ops = &stm32_psci_ops;
+
+	return 0;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_power_config.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_power_config.c
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <debug.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+#include <errno.h>
+#include <libfdt.h>
+#include <limits.h>
+#include <stm32mp_dt.h>
+#include <stm32mp1_power_config.h>
+
+#define SYSTEM_SUSPEND_SUPPORTED_MODES	"system_suspend_supported_soc_modes"
+#define SYSTEM_OFF_MODE			"system_off_soc_mode"
+
+static uint32_t deepest_system_suspend_mode;
+static uint32_t system_off_mode;
+static uint8_t stm32mp1_supported_soc_modes[STM32_PM_MAX_SOC_MODE];
+
+static int dt_get_pwr_node(void)
+{
+	return dt_get_node_by_compatible(DT_PWR_COMPAT);
+}
+
+static void save_supported_mode(void *fdt, int pwr_node)
+{
+	int len;
+	uint32_t count;
+	unsigned int i;
+	uint32_t supported[ARRAY_SIZE(stm32mp1_supported_soc_modes)];
+	const void *prop;
+
+	prop = fdt_getprop(fdt, pwr_node, SYSTEM_SUSPEND_SUPPORTED_MODES, &len);
+	if (prop == NULL) {
+		panic();
+	}
+
+	count = (uint32_t)len / sizeof(uint32_t);
+	if (count > STM32_PM_MAX_SOC_MODE) {
+		panic();
+	}
+
+	if (fdt_read_uint32_array(pwr_node, SYSTEM_SUSPEND_SUPPORTED_MODES,
+				  &supported[0], count) < 0) {
+		ERROR("PWR DT\n");
+		panic();
+	}
+
+	for (i = 0; i < count; i++) {
+		if (supported[i] >= STM32_PM_MAX_SOC_MODE) {
+			ERROR("Invalid mode\n");
+			panic();
+		}
+		stm32mp1_supported_soc_modes[supported[i]] = 1U;
+	}
+
+	/* Initialize to deepest possible mode */
+	for (i = STM32_PM_MAX_SOC_MODE - 1U; i != STM32_PM_CSLEEP_RUN; i--) {
+		if (stm32mp1_supported_soc_modes[i] == 1U) {
+			deepest_system_suspend_mode = i;
+			break;
+		}
+	}
+}
+
+static int dt_fill_lp_state(uint32_t *lp_state_config, const char *lp_state)
+{
+	int pwr_node;
+	void *fdt;
+	const fdt32_t *cuint;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	pwr_node = dt_get_pwr_node();
+	if (pwr_node < 0) {
+		ERROR("compatible %s not found\n", DT_PWR_COMPAT);
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cuint = fdt_getprop(fdt, pwr_node, lp_state, NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	*lp_state_config = fdt32_to_cpu(*cuint);
+
+	save_supported_mode(fdt, pwr_node);
+
+	return 0;
+}
+
+void stm32mp1_init_lp_states(void)
+{
+	if (dt_fill_lp_state(&system_off_mode, SYSTEM_OFF_MODE) < 0) {
+		ERROR("Node %s not found\n", SYSTEM_OFF_MODE);
+		//panic();
+	}
+}
+
+/* Init with all domains ON */
+static bool pm_dom[STM32MP1_PD_MAX_PM_DOMAIN] = {
+	[STM32MP1_PD_VSW] = false,
+	[STM32MP1_PD_CORE_RET] = false,
+	[STM32MP1_PD_CORE] = false
+};
+
+static bool stm32mp1_get_pm_domain_state(uint8_t mode)
+{
+	bool res = true;
+	enum stm32mp1_pm_domain id = STM32MP1_PD_MAX_PM_DOMAIN;
+
+	while (res && (id > mode)) {
+		id--;
+		res &= pm_dom[id];
+	}
+
+	return res;
+}
+
+int stm32mp1_set_pm_domain_state(enum stm32mp1_pm_domain domain, bool status)
+{
+	if (domain >= STM32MP1_PD_MAX_PM_DOMAIN) {
+		return -EINVAL;
+	}
+
+	pm_dom[domain] = status;
+
+	return 0;
+}
+
+static bool is_supported_mode(uint32_t soc_mode)
+{
+	assert(soc_mode < ARRAY_SIZE(stm32mp1_supported_soc_modes));
+
+	return stm32mp1_supported_soc_modes[soc_mode] == 1U;
+}
+
+uint32_t stm32mp1_get_lp_soc_mode(uint32_t psci_mode)
+{
+	uint32_t mode;
+
+	if (psci_mode == PSCI_MODE_SYSTEM_OFF) {
+		return system_off_mode;
+	}
+
+	mode = deepest_system_suspend_mode;
+
+	if ((mode == STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR) &&
+	    ((!stm32mp1_get_pm_domain_state(STM32MP1_PD_CORE_RET)) ||
+	     (!is_supported_mode(mode)))) {
+		mode = STM32_PM_CSTOP_ALLOW_LPLV_STOP;
+	}
+
+	if ((mode == STM32_PM_CSTOP_ALLOW_LPLV_STOP) &&
+	    ((!stm32mp1_get_pm_domain_state(STM32MP1_PD_CORE)) ||
+	     (!is_supported_mode(mode)))) {
+		mode = STM32_PM_CSTOP_ALLOW_LP_STOP;
+	}
+
+	if ((mode == STM32_PM_CSTOP_ALLOW_LP_STOP) &&
+	    (!is_supported_mode(mode))) {
+		mode = STM32_PM_CSTOP_ALLOW_STOP;
+	}
+
+	if ((mode == STM32_PM_CSTOP_ALLOW_STOP) &&
+	    (!is_supported_mode(mode))) {
+		mode = STM32_PM_CSLEEP_RUN;
+	}
+
+	return mode;
+}
+
+int stm32mp1_set_lp_deepest_soc_mode(uint32_t psci_mode, uint32_t soc_mode)
+{
+	if (soc_mode >= STM32_PM_MAX_SOC_MODE) {
+		return -EINVAL;
+	}
+
+	if (psci_mode == PSCI_MODE_SYSTEM_SUSPEND) {
+		deepest_system_suspend_mode = soc_mode;
+	}
+
+	if (psci_mode == PSCI_MODE_SYSTEM_OFF) {
+		system_off_mode = soc_mode;
+	}
+
+	return 0;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_private.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_private.c
@@ -0,0 +1,661 @@
+/*
+ * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <assert.h>
+#include <bl_common.h>
+#include <debug.h>
+#include <errno.h>
+#include <gicv2.h>
+#include <mmio.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <stm32_iwdg.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp_dummy_regulator.h>
+#include <stm32mp_pmic.h>
+#include <stm32mp_regulator.h>
+#include <stm32mp_reset.h>
+#include <xlat_tables_v2.h>
+
+/* Internal layout of the 32bit OTP word board_id */
+#define BOARD_ID_BOARD_NB_MASK		GENMASK(31, 16)
+#define BOARD_ID_BOARD_NB_SHIFT		16
+#define BOARD_ID_VARIANT_MASK		GENMASK(15, 12)
+#define BOARD_ID_VARIANT_SHIFT		12
+#define BOARD_ID_REVISION_MASK		GENMASK(11, 8)
+#define BOARD_ID_REVISION_SHIFT		8
+#define BOARD_ID_BOM_MASK		GENMASK(3, 0)
+
+#define BOARD_ID2NB(_id)		(((_id) & BOARD_ID_BOARD_NB_MASK) >> \
+					 BOARD_ID_BOARD_NB_SHIFT)
+#define BOARD_ID2VAR(_id)		(((_id) & BOARD_ID_VARIANT_MASK) >> \
+					 BOARD_ID_VARIANT_SHIFT)
+#define BOARD_ID2REV(_id)		(((_id) & BOARD_ID_REVISION_MASK) >> \
+					 BOARD_ID_REVISION_SHIFT)
+#define BOARD_ID2BOM(_id)		((_id) & BOARD_ID_BOM_MASK)
+
+#define MAP_ROM		MAP_REGION_FLAT(STM32MP_ROM_BASE, \
+					STM32MP_ROM_SIZE, \
+					MT_MEMORY | \
+					MT_RO | \
+					MT_SECURE | \
+					MT_EXECUTE)
+
+#define MAP_SRAM	MAP_REGION_FLAT(STM32MP_SYSRAM_BASE, \
+					STM32MP_SYSRAM_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_SRAM_MCU	MAP_REGION_FLAT(STM32MP_SRAM_MCU_BASE, \
+					STM32MP_SRAM_MCU_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_NS | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_RETRAM	MAP_REGION_FLAT(STM32MP_RETRAM_BASE, \
+					STM32MP_RETRAM_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_NS | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_DEVICE1	MAP_REGION_FLAT(STM32MP1_DEVICE1_BASE, \
+					STM32MP1_DEVICE1_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_DEVICE2	MAP_REGION_FLAT(STM32MP1_DEVICE2_BASE, \
+					STM32MP1_DEVICE2_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#if defined(IMAGE_BL2)
+static const mmap_region_t stm32mp1_mmap[] = {
+	MAP_ROM,
+	MAP_SRAM,
+#if defined(STM32MP_USB)
+	MAP_SRAM_MCU,
+#endif
+	MAP_DEVICE1,
+	MAP_DEVICE2,
+	{0}
+};
+#endif
+#if defined(IMAGE_BL32)
+static const mmap_region_t stm32mp1_mmap[] = {
+	MAP_ROM,
+	MAP_SRAM,
+	MAP_DEVICE1,
+	MAP_DEVICE2,
+	{0}
+};
+#endif
+
+void configure_mmu(void)
+{
+#ifndef MMU_OFF
+	unsigned int flags = 0;
+
+	mmap_add(stm32mp1_mmap);
+	init_xlat_tables();
+#ifdef DCACHE_OFF
+	flags |= DISABLE_DCACHE;
+#endif
+	enable_mmu_svc_mon(flags);
+#endif
+}
+
+#if STM32MP_UART_PROGRAMMER
+/*
+ * UART Management
+ */
+static const uintptr_t stm32mp1_uart_addresses[8] = {
+	USART1_BASE,
+	USART2_BASE,
+	USART3_BASE,
+	UART4_BASE,
+	UART5_BASE,
+	USART6_BASE,
+	UART7_BASE,
+	UART8_BASE,
+};
+
+uintptr_t get_uart_address(uint32_t instance_nb)
+{
+	if (!instance_nb || instance_nb > ARRAY_SIZE(stm32mp1_uart_addresses))
+		return 0;
+
+	return stm32mp1_uart_addresses[instance_nb - 1];
+}
+#endif
+
+#define ARM_CNTXCTL_IMASK	BIT(1)
+
+void stm32mp_mask_timer(void)
+{
+	/* Mask timer interrupts */
+	write_cntp_ctl(read_cntp_ctl() | ARM_CNTXCTL_IMASK);
+	write_cntv_ctl(read_cntv_ctl() | ARM_CNTXCTL_IMASK);
+}
+
+void __dead2 stm32mp_wait_cpu_reset(void)
+{
+	uint32_t id;
+
+	dcsw_op_all(DC_OP_CISW);
+	write_sctlr(read_sctlr() & ~SCTLR_C_BIT);
+	dcsw_op_all(DC_OP_CISW);
+	__asm__("clrex");
+
+	dsb();
+	isb();
+
+	for ( ; ; ) {
+		do {
+			id = plat_ic_get_pending_interrupt_id();
+
+			if (id <= MAX_SPI_ID) {
+				gicv2_end_of_interrupt(id);
+
+				plat_ic_disable_interrupt(id);
+			}
+		} while (id <= MAX_SPI_ID);
+
+		wfi();
+	}
+}
+
+/*
+ * tzc_source_ip contains the TZC transaction source IPs that need to be reset
+ * before a C-A7 subsystem is reset (i.e. independent reset):
+ * - C-A7 subsystem is reset separately later in the sequence,
+ * - C-M4 subsystem is not concerned here,
+ * - DAP is excluded for debug purpose,
+ * - IPs are stored with their ETZPC IDs (STM32MP1_ETZPC_MAX_ID if not
+ *   applicable) because some of them need to be reset only if they are not
+ *   configured in MCU isolation mode inside ETZPC device tree.
+ */
+struct tzc_source_ip {
+	uint32_t reset_id;
+	uint32_t clock_id;
+	uint32_t decprot_id;
+};
+
+#define _TZC_FIXED(res, clk)			\
+	{						\
+		.reset_id = (res),			\
+		.clock_id = (clk),			\
+		.decprot_id = STM32MP1_ETZPC_MAX_ID,	\
+	}
+
+#define _TZC_COND(res, clk, decprot)			\
+	{						\
+		.reset_id = (res),			\
+		.clock_id = (clk),			\
+		.decprot_id = (decprot),		\
+	}
+
+static const struct tzc_source_ip tzc_source_ip[] = {
+	_TZC_FIXED(LTDC_R, LTDC_PX),
+	_TZC_FIXED(GPU_R, GPU),
+	_TZC_FIXED(USBH_R, USBH),
+	_TZC_FIXED(SDMMC1_R, SDMMC1_K),
+	_TZC_FIXED(SDMMC2_R, SDMMC2_K),
+	_TZC_FIXED(MDMA_R, MDMA),
+	_TZC_COND(USBO_R, USBO_K, STM32MP1_ETZPC_OTG_ID),
+	_TZC_COND(SDMMC3_R, SDMMC3_K, STM32MP1_ETZPC_SDMMC3_ID),
+	_TZC_COND(ETHMAC_R, ETHMAC, STM32MP1_ETZPC_ETH_ID),
+	_TZC_COND(DMA1_R, DMA1, STM32MP1_ETZPC_DMA1_ID),
+	_TZC_COND(DMA2_R, DMA2, STM32MP1_ETZPC_DMA2_ID),
+};
+
+void __dead2 stm32mp_plat_reset(int cpu)
+{
+	uint32_t reg = RCC_MP_GRSTCSETR_MPUP0RST;
+	uint32_t id;
+
+	/* Mask timer interrupts */
+	stm32mp_mask_timer();
+
+	for (id = 0U; id < ARRAY_SIZE(tzc_source_ip); id++) {
+		if ((!stm32mp1_clk_is_enabled(tzc_source_ip[id].clock_id)) ||
+		    ((tzc_source_ip[id].decprot_id != STM32MP1_ETZPC_MAX_ID) &&
+		     (etzpc_get_decprot(tzc_source_ip[id].decprot_id) ==
+		      TZPC_DECPROT_MCU_ISOLATION))) {
+			continue;
+		}
+
+		if (tzc_source_ip[id].reset_id != GPU_R) {
+			stm32mp_reset_assert(tzc_source_ip[id].reset_id);
+			stm32mp_reset_deassert(tzc_source_ip[id].reset_id);
+		} else {
+			/* GPU reset automatically cleared by hardware */
+			mmio_setbits_32(stm32mp_rcc_base() + RCC_AHB6RSTSETR,
+					RCC_AHB6RSTSETR_GPURST);
+		}
+	}
+
+	if (!stm32mp_is_single_core()) {
+		unsigned int sec_cpu = (cpu == STM32MP_PRIMARY_CPU) ?
+			STM32MP_SECONDARY_CPU : STM32MP_PRIMARY_CPU;
+
+		gicv2_raise_sgi(ARM_IRQ_SEC_SGI_1, sec_cpu);
+		reg |= RCC_MP_GRSTCSETR_MPUP1RST;
+	}
+
+	do {
+		id = plat_ic_get_pending_interrupt_id();
+
+		if (id <= MAX_SPI_ID) {
+			gicv2_end_of_interrupt(id);
+
+			plat_ic_disable_interrupt(id);
+		}
+	} while (id <= MAX_SPI_ID);
+
+	mmio_write_32(stm32mp_rcc_base() + RCC_MP_GRSTCSETR, reg);
+
+	stm32mp_wait_cpu_reset();
+}
+
+int stm32_get_otp_index(const char *otp_name, uint32_t *otp_idx,
+			uint32_t *otp_len)
+{
+	assert(otp_name != NULL);
+	assert(otp_idx != NULL);
+
+	if (bsec_find_otp_name_in_dt(otp_name, otp_idx, otp_len) != BSEC_OK) {
+		ERROR("BSEC: Get %s number Error\n", otp_name);
+		return -1;
+	}
+
+	return 0;
+}
+
+int stm32_get_otp_value(const char *otp_name, uint32_t *otp_val)
+{
+	uint32_t otp;
+
+	assert(otp_name != NULL);
+	assert(otp_val != NULL);
+
+	if (stm32_get_otp_index(otp_name, &otp, NULL) != 0) {
+		return -1;
+	}
+
+#if defined(IMAGE_BL2)
+	if (bsec_shadow_read_otp(otp_val, otp) != BSEC_OK) {
+		ERROR("BSEC: %s Read Error\n", otp_name);
+		return -1;
+	}
+#elif defined(IMAGE_BL32)
+	if (bsec_read_otp(otp_val, otp) != BSEC_OK) {
+		ERROR("BSEC: %s Read Error\n", otp_name);
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+
+static int get_part_number(uint32_t *part_nb)
+{
+	uint32_t part_number;
+	uint32_t dev_id;
+
+	assert(part_nb != NULL);
+
+	if (stm32mp1_dbgmcu_get_chip_dev_id(&dev_id) < 0) {
+		return -1;
+	}
+
+	if (stm32_get_otp_value(PART_NUMBER_OTP, &part_number) != 0) {
+		return -1;
+	}
+
+	part_number = (part_number & PART_MASK) >> PART_SHIFT;
+
+	*part_nb = part_number | (dev_id << 16);
+
+	return 0;
+}
+
+static int get_cpu_package(uint32_t *cpu_package)
+{
+	uint32_t package;
+
+	assert(cpu_package != NULL);
+
+	if (stm32_get_otp_value(PACKAGE_OTP, &package) != 0) {
+		return -1;
+	}
+
+	*cpu_package = (package & PKG_MASK) >> PKG_SHIFT;
+
+	return 0;
+}
+
+bool stm32mp_supports_cpu_opp(uint32_t opp_id)
+{
+	uint32_t part_number;
+	uint32_t id;
+
+	if (get_part_number(&part_number) != 0) {
+		ERROR("Cannot get part number\n");
+		panic();
+	}
+
+	switch (opp_id) {
+	case PLAT_OPP_ID1:
+	case PLAT_OPP_ID2:
+		id = opp_id;
+		break;
+	default:
+		return false;
+	}
+
+	switch (part_number) {
+	case STM32MP157F_PART_NB:
+	case STM32MP157D_PART_NB:
+	case STM32MP153F_PART_NB:
+	case STM32MP153D_PART_NB:
+	case STM32MP151F_PART_NB:
+	case STM32MP151D_PART_NB:
+		return true;
+	default:
+		return id == PLAT_OPP_ID1;
+	}
+}
+
+void stm32mp_print_cpuinfo(void)
+{
+	const char *cpu_s, *cpu_r, *pkg;
+	uint32_t part_number;
+	uint32_t cpu_package;
+	uint32_t chip_dev_id;
+	int ret;
+
+	/* MPUs Part Numbers */
+	ret = get_part_number(&part_number);
+	if (ret < 0) {
+		WARN("Cannot get part number\n");
+		return;
+	}
+
+	switch (part_number) {
+	case STM32MP157C_PART_NB:
+		cpu_s = "157C";
+		break;
+	case STM32MP157A_PART_NB:
+		cpu_s = "157A";
+		break;
+	case STM32MP153C_PART_NB:
+		cpu_s = "153C";
+		break;
+	case STM32MP153A_PART_NB:
+		cpu_s = "153A";
+		break;
+	case STM32MP151C_PART_NB:
+		cpu_s = "151C";
+		break;
+	case STM32MP151A_PART_NB:
+		cpu_s = "151A";
+		break;
+	case STM32MP157F_PART_NB:
+		cpu_s = "157F";
+		break;
+	case STM32MP157D_PART_NB:
+		cpu_s = "157D";
+		break;
+	case STM32MP153F_PART_NB:
+		cpu_s = "153F";
+		break;
+	case STM32MP153D_PART_NB:
+		cpu_s = "153D";
+		break;
+	case STM32MP151F_PART_NB:
+		cpu_s = "151F";
+		break;
+	case STM32MP151D_PART_NB:
+		cpu_s = "151D";
+		break;
+	default:
+		cpu_s = "????";
+		break;
+	}
+
+	/* Package */
+	ret = get_cpu_package(&cpu_package);
+	if (ret < 0) {
+		WARN("Cannot get CPU package\n");
+		return;
+	}
+
+	switch (cpu_package) {
+	case PKG_AA_LBGA448:
+		pkg = "AA";
+		break;
+	case PKG_AB_LBGA354:
+		pkg = "AB";
+		break;
+	case PKG_AC_TFBGA361:
+		pkg = "AC";
+		break;
+	case PKG_AD_TFBGA257:
+		pkg = "AD";
+		break;
+	default:
+		pkg = "??";
+		break;
+	}
+
+	/* REVISION */
+	ret = stm32mp1_dbgmcu_get_chip_version(&chip_dev_id);
+	if (ret < 0) {
+		WARN("Cannot get CPU version\n");
+		return;
+	}
+
+	switch (chip_dev_id) {
+	case STM32MP1_REV_A:
+		cpu_r = "A";
+		break;
+	case STM32MP1_REV_B:
+		cpu_r = "B";
+		break;
+	case STM32MP1_REV_Z:
+		cpu_r = "Z";
+		break;
+	default:
+		cpu_r = "?";
+		break;
+	}
+
+	NOTICE("CPU: STM32MP%s%s Rev.%s\n", cpu_s, pkg, cpu_r);
+}
+
+void stm32mp_print_boardinfo(void)
+{
+	uint32_t board_id = 0;
+
+	if (stm32_get_otp_value(BOARD_ID_OTP, &board_id) != 0) {
+		return;
+	}
+
+	if (board_id != 0U) {
+		char rev[2];
+
+		rev[0] = BOARD_ID2REV(board_id) - 1 + 'A';
+		rev[1] = '\0';
+		NOTICE("Board: MB%04x Var%d Rev.%s-%02d\n",
+		       BOARD_ID2NB(board_id),
+		       BOARD_ID2VAR(board_id),
+		       rev,
+		       BOARD_ID2BOM(board_id));
+	}
+}
+
+/* Return true when SoC provides a single Cortex-A7 core, and false otherwise */
+bool stm32mp_is_single_core(void)
+{
+	uint32_t part_number;
+
+	if (get_part_number(&part_number) < 0) {
+		ERROR("Invalid part number, assume single core chip");
+		return true;
+	}
+
+	switch (part_number) {
+	case STM32MP151A_PART_NB:
+	case STM32MP151C_PART_NB:
+	case STM32MP151D_PART_NB:
+	case STM32MP151F_PART_NB:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+uint8_t stm32_iwdg_get_instance(uintptr_t base)
+{
+	switch (base) {
+	case IWDG1_BASE:
+		return IWDG1_INST;
+	case IWDG2_BASE:
+		return IWDG2_INST;
+	default:
+		panic();
+	}
+}
+
+uint32_t stm32_iwdg_get_otp_config(uintptr_t base)
+{
+	uint8_t idx;
+	uint32_t iwdg_cfg = 0;
+	uint32_t otp_value;
+
+	if (stm32_get_otp_value(HW2_OTP, &otp_value) != 0) {
+		panic();
+	}
+
+	idx = stm32_iwdg_get_instance(base);
+
+	if ((otp_value & BIT(idx + IWDG_HW_POS)) != 0U) {
+		iwdg_cfg |= IWDG_HW_ENABLED;
+	}
+
+	if ((otp_value & BIT(idx + IWDG_FZ_STOP_POS)) != 0U) {
+		iwdg_cfg |= IWDG_DISABLE_ON_STOP;
+	}
+
+	if ((otp_value & BIT(idx + IWDG_FZ_STANDBY_POS)) != 0U) {
+		iwdg_cfg |= IWDG_DISABLE_ON_STANDBY;
+	}
+
+	return iwdg_cfg;
+}
+
+#if defined(IMAGE_BL2)
+uint32_t stm32_iwdg_shadow_update(uintptr_t base, uint32_t flags)
+{
+	uint32_t idx;
+	uint32_t otp_value;
+	uint32_t otp;
+	uint32_t result;
+
+	if (stm32_get_otp_index(HW2_OTP, &otp, NULL) != 0) {
+		panic();
+	}
+
+	if (stm32_get_otp_value(HW2_OTP, &otp_value) != 0) {
+		panic();
+	}
+
+	idx = stm32_iwdg_get_instance(base);
+
+	if ((flags & IWDG_DISABLE_ON_STOP) != 0) {
+		otp_value |= BIT(idx + IWDG_FZ_STOP_POS);
+	}
+
+	if ((flags & IWDG_DISABLE_ON_STANDBY) != 0) {
+		otp_value |= BIT(idx + IWDG_FZ_STANDBY_POS);
+	}
+
+	result = bsec_write_otp(otp_value, otp);
+	if (result != BSEC_OK) {
+		return result;
+	}
+
+	/* Sticky lock OTP_IWDG (read and write) */
+	if ((bsec_set_sr_lock(otp) != BSEC_OK) ||
+	    (bsec_set_sw_lock(otp) != BSEC_OK)) {
+		return BSEC_LOCK_FAIL;
+	}
+
+	return BSEC_OK;
+}
+#endif
+
+/*
+ * This function allows to split bindings between platform and ETZPC
+ * HW mapping. If this conversion was done at driver level, the driver
+ * should include all supported platform bindings. ETZPC may be used on
+ * other platforms.
+ */
+enum etzpc_decprot_attributes stm32mp_etzpc_binding2decprot(uint32_t mode)
+{
+	switch (mode) {
+	case DECPROT_S_RW:
+		return TZPC_DECPROT_S_RW;
+	case DECPROT_NS_R_S_W:
+		return TZPC_DECPROT_NS_R_S_W;
+	case DECPROT_MCU_ISOLATION:
+		return TZPC_DECPROT_MCU_ISOLATION;
+	case DECPROT_NS_RW:
+		return TZPC_DECPROT_NS_RW;
+	default:
+		panic();
+	}
+}
+
+int plat_bind_regulator(struct stm32mp_regulator *regu)
+{
+	void *fdt;
+	int regu_node;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return false;
+	}
+
+	bind_dummy_regulator(regu);
+
+	regu_node = fdt_node_offset_by_phandle(fdt, regu->id);
+	if (fdt_getprop(fdt, regu_node, "regulator-always-on", NULL) != NULL) {
+		regu->always_on = true;
+	}
+
+	return 0;
+}
+
+int dt_pmic_status(void)
+{
+	return -ENOENT;
+}
+
+int pmic_ddr_power_init(enum ddr_type ddr_type)
+{
+	return 0;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_security.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_security.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <debug.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <mmio.h>
+#include <stdint.h>
+#include <stm32mp_dt.h>
+#include <stm32mp1_private.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+#include <tzc400.h>
+#include "platform_def.h"
+
+/*******************************************************************************
+ * Initialize the TrustZone Controller. Configure Region 0 with Secure RW access
+ * and allow Non-Secure masters full access.
+ ******************************************************************************/
+static void init_tzc400(void)
+{
+	unsigned long long region_base, region_top;
+	unsigned long long ddr_base = STM32MP_DDR_BASE;
+	unsigned long long ddr_size = (unsigned long long)dt_get_ddr_size();
+	unsigned long long ddr_top = ddr_base + (ddr_size - 1U);
+
+	tzc400_init(STM32MP1_TZC_BASE);
+
+	tzc400_disable_filters();
+
+#ifdef AARCH32_SP_OPTEE
+	/*
+	 * Region 1 set to cover all non-secure DRAM at 0xC000_0000. Apply the
+	 * same configuration to all filters in the TZC.
+	 */
+	region_base = ddr_base;
+	region_top = ddr_top - STM32MP_DDR_S_SIZE - STM32MP_DDR_SHMEM_SIZE;
+	tzc400_configure_region(STM32MP1_FILTER_BIT_ALL, 1,
+			region_base,
+			region_top,
+			TZC_REGION_S_NONE,
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_GPU_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_LCD_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_MDMA_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_M4_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DMA_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_HOST_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_OTG_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_SDMMC_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_ETH_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DAP_ID));
+
+	/* Region 2 set to cover all secure DRAM. */
+	region_base = region_top + 1U;
+	region_top = ddr_top - STM32MP_DDR_SHMEM_SIZE;
+	tzc400_configure_region(STM32MP1_FILTER_BIT_ALL, 2,
+				region_base,
+				region_top,
+				TZC_REGION_S_RDWR,
+				0);
+
+	/* Region 3 set to cover non-secure shared memory DRAM. */
+	region_base = region_top + 1U;
+	region_top = ddr_top;
+	tzc400_configure_region(STM32MP1_FILTER_BIT_ALL, 3,
+			region_base,
+			region_top,
+			TZC_REGION_S_NONE,
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_GPU_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_LCD_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_MDMA_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_M4_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DMA_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_HOST_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_OTG_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_SDMMC_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_ETH_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DAP_ID));
+#else
+	/*
+	 * Region 1 set to cover all DRAM at 0xC000_0000. Apply the
+	 * same configuration to all filters in the TZC.
+	 */
+	region_base = ddr_base;
+	region_top = ddr_top;
+	tzc400_configure_region(STM32MP1_FILTER_BIT_ALL, 1,
+			region_base,
+			region_top,
+			TZC_REGION_S_NONE,
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_GPU_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_LCD_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_MDMA_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_M4_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DMA_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_HOST_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_USB_OTG_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_SDMMC_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_ETH_ID) |
+			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_DAP_ID));
+#endif
+
+	/*
+	 * Raise an interrupt (secure FIQ) if a NS device tries to access
+	 * secure memory
+	 */
+	tzc400_set_action(TZC_ACTION_INT);
+
+	tzc400_enable_filters();
+}
+
+/*******************************************************************************
+ * Initialize the TrustZone Controller.
+ * Early initialization create only one region with full access to secure.
+ * This setting is used before and during DDR initialization.
+ ******************************************************************************/
+static void early_init_tzc400(void)
+{
+	stm32mp_clk_enable(TZC1);
+	stm32mp_clk_enable(TZC2);
+
+	tzc400_init(STM32MP1_TZC_BASE);
+
+	tzc400_disable_filters();
+
+	/* Region 1 set to cover Non-Secure DRAM at 0xC000_0000 */
+	tzc400_configure_region(STM32MP1_FILTER_BIT_ALL, 1,
+				STM32MP_DDR_BASE,
+				STM32MP_DDR_BASE +
+				(STM32MP_DDR_MAX_SIZE - 1U),
+				TZC_REGION_S_RDWR,
+				TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID) |
+				TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_SDMMC_ID));
+
+	/* Raise an exception if a NS device tries to access secure memory */
+	tzc400_set_action(TZC_ACTION_ERR);
+
+	tzc400_enable_filters();
+}
+
+/*******************************************************************************
+ * Initialize the secure environment. At this moment only the TrustZone
+ * Controller is initialized.
+ ******************************************************************************/
+void stm32mp1_arch_security_setup(void)
+{
+	early_init_tzc400();
+}
+
+/*******************************************************************************
+ * Initialize the secure environment. At this moment only the TrustZone
+ * Controller is initialized.
+ ******************************************************************************/
+void stm32mp1_security_setup(void)
+{
+	init_tzc400();
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_shared_resources.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_shared_resources.c
@@ -0,0 +1,830 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics
+ */
+
+#include <arch.h>
+#include <assert.h>
+#include <debug.h>
+#include <platform_def.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stm32_gpio.h>
+#include <stm32mp_dt.h>
+#include <stm32mp_shres_helpers.h>
+
+static bool registering_locked;
+static int8_t gpioz_nbpin = -1;
+
+/*
+ * Generic clock enable/disable from secure world.
+ * Some drivers may use non secure resources in specific execution context:
+ * when the other SMP core(s) are offline and non secure is never reached.
+ * In such cases, drivers shall enable/disable the HW clock only if it was not
+ * left enabled by the non secure world.
+ *
+ * During driver initializations, before registering_locked is locked, all
+ * driver simply enable/disable the clock as if the peripheral was secure.
+ */
+void stm32mp_clk_enable(unsigned long id)
+{
+	if (registering_locked) {
+		if (stm32mp1_clock_is_non_secure(id)) {
+			assert(stm32mp1_clk_get_refcount(id) == 0U);
+
+			if (stm32mp1_clk_is_enabled(id)) {
+				return;
+			}
+		}
+	}
+
+	stm32mp1_clk_enable_secure(id);
+}
+
+void stm32mp_clk_disable(unsigned long id)
+{
+	if (registering_locked) {
+		if (stm32mp1_clock_is_non_secure(id)) {
+			if (stm32mp1_clk_get_refcount(id) == 0U) {
+				return;
+			}
+		}
+	}
+
+	stm32mp1_clk_disable_secure(id);
+}
+
+/*
+ * Shared peripherals and resources.
+ * Defines resource that may be non secure, secure or shared.
+ * May be a device, a bus, a clock, a memory.
+ *
+ * State default to PERIPH_UNREGISTERED resource is not explicitly
+ * set here.
+ *
+ * Resource driver not built, the resource defaults
+ * to non secure ownership.
+ *
+ * Each IO of the GPIOZ IO can be secure or non secure.
+ * When the GPIO driver is enabled, the GPIOZ bank is fully non secure
+ * only if each IO is non secure and the GPIOZ bank is shared if it
+ * includes secure and non secure IOs.
+ *
+ * BKPSRAM is assumed shared.
+ * DDR control (DDRC and DDRPHY) is secure.
+ * Inits will define the resource state according the device tree
+ * and the driver initialization sequences.
+ *
+ * The platform initialization uses these information to set the ETZPC
+ * configuration. Non secure services (as clocks or regulator accesses)
+ * rely on these information to drive the related service execution.
+ */
+#define SHRES_NON_SECURE		3
+#define SHRES_SHARED			2
+#define SHRES_SECURE			1
+#define SHRES_UNREGISTERED		0
+
+static uint8_t shres_state[STM32MP1_SHRES_COUNT];
+
+static const char *shres2str_id_tbl[STM32MP1_SHRES_COUNT] = {
+	[STM32MP1_SHRES_GPIOZ(0)] = "GPIOZ0",
+	[STM32MP1_SHRES_GPIOZ(1)] = "GPIOZ1",
+	[STM32MP1_SHRES_GPIOZ(2)] = "GPIOZ2",
+	[STM32MP1_SHRES_GPIOZ(3)] = "GPIOZ3",
+	[STM32MP1_SHRES_GPIOZ(4)] = "GPIOZ4",
+	[STM32MP1_SHRES_GPIOZ(5)] = "GPIOZ5",
+	[STM32MP1_SHRES_GPIOZ(6)] = "GPIOZ6",
+	[STM32MP1_SHRES_GPIOZ(7)] = "GPIOZ7",
+	[STM32MP1_SHRES_IWDG1] = "IWDG1",
+	[STM32MP1_SHRES_USART1] = "USART1",
+	[STM32MP1_SHRES_SPI6] = "SPI6",
+	[STM32MP1_SHRES_I2C4] = "I2C4",
+	[STM32MP1_SHRES_RNG1] = "RNG1",
+	[STM32MP1_SHRES_HASH1] = "HASH1",
+	[STM32MP1_SHRES_CRYP1] = "CRYP1",
+	[STM32MP1_SHRES_I2C6] = "I2C6",
+	[STM32MP1_SHRES_RTC] = "RTC",
+	[STM32MP1_SHRES_MCU] = "MCU",
+	[STM32MP1_SHRES_HSI] = "HSI",
+	[STM32MP1_SHRES_LSI] = "LSI",
+	[STM32MP1_SHRES_HSE] = "HSE",
+	[STM32MP1_SHRES_LSE] = "LSE",
+	[STM32MP1_SHRES_CSI] = "CSI",
+	[STM32MP1_SHRES_PLL1] = "PLL1",
+	[STM32MP1_SHRES_PLL1_P] = "PLL1_P",
+	[STM32MP1_SHRES_PLL1_Q] = "PLL1_Q",
+	[STM32MP1_SHRES_PLL1_R] = "PLL1_R",
+	[STM32MP1_SHRES_PLL2] = "PLL2",
+	[STM32MP1_SHRES_PLL2_P] = "PLL2_P",
+	[STM32MP1_SHRES_PLL2_Q] = "PLL2_Q",
+	[STM32MP1_SHRES_PLL2_R] = "PLL2_R",
+	[STM32MP1_SHRES_PLL3] = "PLL3",
+	[STM32MP1_SHRES_PLL3_P] = "PLL3_P",
+	[STM32MP1_SHRES_PLL3_Q] = "PLL3_Q",
+	[STM32MP1_SHRES_PLL3_R] = "PLL3_R",
+};
+
+static const char *shres2str_id(unsigned int id)
+{
+	return shres2str_id_tbl[id];
+}
+
+static const char *shres2str_state_tbl[4] = {
+	[SHRES_SHARED] = "shared",
+	[SHRES_NON_SECURE] = "non secure",
+	[SHRES_SECURE] = "secure",
+	[SHRES_UNREGISTERED] = "unregistered",
+};
+
+static const char *shres2str_state(unsigned int id)
+{
+	return shres2str_state_tbl[id];
+}
+
+struct shres2decprot {
+	unsigned int shres_id;
+	unsigned int decprot_id;
+	const char *decprot_str;
+};
+
+#define SHRES2DECPROT(shres, decprot, str) {	\
+		.shres_id = shres,		\
+		.decprot_id = decprot,		\
+		.decprot_str = str,		\
+	}
+
+#define SHRES_INVALID		~0U
+static const struct shres2decprot shres2decprot_tbl[] = {
+	SHRES2DECPROT(STM32MP1_SHRES_IWDG1, STM32MP1_ETZPC_IWDG1_ID, "IWDG1"),
+	SHRES2DECPROT(STM32MP1_SHRES_USART1, STM32MP1_ETZPC_USART1_ID, "UART1"),
+	SHRES2DECPROT(STM32MP1_SHRES_SPI6, STM32MP1_ETZPC_SPI6_ID, "SPI6"),
+	SHRES2DECPROT(STM32MP1_SHRES_I2C4, STM32MP1_ETZPC_I2C4_ID, "I2C4"),
+	SHRES2DECPROT(STM32MP1_SHRES_RNG1, STM32MP1_ETZPC_RNG1_ID, "RNG1"),
+	SHRES2DECPROT(STM32MP1_SHRES_HASH1, STM32MP1_ETZPC_HASH1_ID, "HASH1"),
+	SHRES2DECPROT(STM32MP1_SHRES_CRYP1, STM32MP1_ETZPC_CRYP1_ID, "CRYP1"),
+	SHRES2DECPROT(STM32MP1_SHRES_I2C6, STM32MP1_ETZPC_I2C6_ID, "I2C6"),
+	/* Below are specific IDs without a 1-to-1 mapping to SHRES IDs */
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_STGENC_ID, "STGEN"),
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_BKPSRAM_ID, "BKPSRAM"),
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_DDRCTRL_ID, "DDRCTRL"),
+	SHRES2DECPROT(SHRES_INVALID, STM32MP1_ETZPC_DDRPHYC_ID, "DDRPHY"),
+};
+
+static unsigned int decprot2shres(unsigned int decprot_id)
+{
+	uint32_t i;
+
+	for (i = 0; i < ARRAY_SIZE(shres2decprot_tbl); i++) {
+		if (shres2decprot_tbl[i].decprot_id == decprot_id) {
+			return shres2decprot_tbl[i].shres_id;
+		}
+	}
+
+	VERBOSE("No shared resource %u", decprot_id);
+	return SHRES_INVALID;
+}
+
+static const char *decprot2str(unsigned int decprot_id)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(shres2decprot_tbl); i++) {
+		if (shres2decprot_tbl[i].decprot_id == decprot_id) {
+			return shres2decprot_tbl[i].decprot_str;
+		}
+	}
+
+	ERROR("Invalid ID %u", decprot_id);
+	panic();
+}
+
+static unsigned int get_gpioz_nbpin(void)
+{
+	if (gpioz_nbpin < 0) {
+		gpioz_nbpin = (int8_t)fdt_get_gpioz_nbpins_from_dt();
+		assert((gpioz_nbpin == 0) ||
+		       (gpioz_nbpin == STM32MP_GPIOZ_PIN_MAX_COUNT));
+	}
+
+	return (unsigned int)gpioz_nbpin;
+}
+
+static bool shareable_resource(unsigned int id)
+{
+	switch (id) {
+	default:
+		/* Currently no shareable resource */
+		return false;
+	}
+}
+
+static void register_periph(unsigned int id, unsigned int state)
+{
+	assert(id < STM32MP1_SHRES_COUNT &&
+	       state > SHRES_UNREGISTERED &&
+	       state <= SHRES_NON_SECURE);
+
+	if (registering_locked) {
+		if (shres_state[id] == state) {
+			return;
+		}
+
+		panic();
+	}
+
+	if ((state == SHRES_SHARED && !shareable_resource(id)) ||
+	    ((shres_state[id] != SHRES_UNREGISTERED) &&
+	     (shres_state[id] != state))) {
+		VERBOSE("Cannot change %s from %s to %s\n",
+			shres2str_id(id),
+			shres2str_state(shres_state[id]),
+			shres2str_state(state));
+		panic();
+	}
+
+	shres_state[id] = (uint8_t)state;
+
+	if (shres_state[id] == SHRES_UNREGISTERED) {
+		VERBOSE("Register %s as %s\n",
+			shres2str_id(id), shres2str_state(state));
+	}
+
+	switch (id) {
+	case STM32MP1_SHRES_GPIOZ(0) ... STM32MP1_SHRES_GPIOZ(7):
+		if ((id - STM32MP1_SHRES_GPIOZ(0)) >= get_gpioz_nbpin()) {
+			ERROR("Invalid GPIO pin %u, %u pin(s) available\n",
+			      id - STM32MP1_SHRES_GPIOZ(0),
+			      get_gpioz_nbpin());
+			panic();
+		}
+		break;
+	default:
+		break;
+	}
+
+	/* Explore clock tree to lock dependencies */
+	if ((state == SHRES_SECURE) || (state == SHRES_SHARED)) {
+		switch (id) {
+		case STM32MP1_SHRES_GPIOZ(0) ... STM32MP1_SHRES_GPIOZ(7):
+			stm32mp1_register_clock_parents_secure(GPIOZ);
+			break;
+		case STM32MP1_SHRES_IWDG1:
+			stm32mp1_register_clock_parents_secure(IWDG1);
+			break;
+		case STM32MP1_SHRES_USART1:
+			stm32mp1_register_clock_parents_secure(USART1_K);
+			break;
+		case STM32MP1_SHRES_SPI6:
+			stm32mp1_register_clock_parents_secure(SPI6_K);
+			break;
+		case STM32MP1_SHRES_I2C4:
+			stm32mp1_register_clock_parents_secure(I2C4_K);
+			break;
+		case STM32MP1_SHRES_RNG1:
+			stm32mp1_register_clock_parents_secure(RNG1_K);
+			break;
+		case STM32MP1_SHRES_HASH1:
+			stm32mp1_register_clock_parents_secure(HASH1);
+			break;
+		case STM32MP1_SHRES_CRYP1:
+			stm32mp1_register_clock_parents_secure(CRYP1);
+			break;
+		case STM32MP1_SHRES_I2C6:
+			stm32mp1_register_clock_parents_secure(I2C6_K);
+			break;
+		case STM32MP1_SHRES_RTC:
+			stm32mp1_register_clock_parents_secure(RTC);
+			break;
+		case STM32MP1_SHRES_PLL1_P:
+		case STM32MP1_SHRES_PLL1_Q:
+		case STM32MP1_SHRES_PLL1_R:
+			register_periph(STM32MP1_SHRES_PLL1, SHRES_SECURE);
+			stm32mp1_register_clock_parents_secure(PLL1);
+			break;
+		case STM32MP1_SHRES_PLL2_P:
+		case STM32MP1_SHRES_PLL2_Q:
+		case STM32MP1_SHRES_PLL2_R:
+			register_periph(STM32MP1_SHRES_PLL2, SHRES_SECURE);
+			stm32mp1_register_clock_parents_secure(PLL2);
+			break;
+		case STM32MP1_SHRES_PLL3_P:
+		case STM32MP1_SHRES_PLL3_Q:
+		case STM32MP1_SHRES_PLL3_R:
+			register_periph(STM32MP1_SHRES_PLL3, SHRES_SECURE);
+			stm32mp1_register_clock_parents_secure(PLL3);
+			break;
+		default:
+			/* No expected resource dependency */
+			break;
+		}
+	}
+}
+
+static bool stm32mp1_mckprot_resource(unsigned int id)
+{
+	switch (id) {
+	case STM32MP1_SHRES_MCU:
+	case STM32MP1_SHRES_PLL3:
+	case STM32MP1_SHRES_PLL3_P:
+	case STM32MP1_SHRES_PLL3_Q:
+	case STM32MP1_SHRES_PLL3_R:
+		return true;
+	default:
+		return false;
+	}
+}
+
+/* Register resource by ID */
+void stm32mp1_register_secure_periph(unsigned int id)
+{
+	register_periph(id, SHRES_SECURE);
+}
+
+void stm32mp1_register_shared_periph(unsigned int id)
+{
+	register_periph(id, SHRES_SHARED);
+}
+
+void stm32mp1_register_non_secure_periph(unsigned int id)
+{
+	register_periph(id, SHRES_NON_SECURE);
+}
+
+/* Register resource by IO memory base address */
+static void register_periph_iomem(uintptr_t base, unsigned int state)
+{
+	unsigned int id;
+
+	switch (base) {
+	case IWDG1_BASE:
+		id = STM32MP1_SHRES_IWDG1;
+		break;
+	case USART1_BASE:
+		id = STM32MP1_SHRES_USART1;
+		break;
+	case SPI6_BASE:
+		id = STM32MP1_SHRES_SPI6;
+		break;
+	case I2C4_BASE:
+		id = STM32MP1_SHRES_I2C4;
+		break;
+	case I2C6_BASE:
+		id = STM32MP1_SHRES_I2C6;
+		break;
+	case RTC_BASE:
+		id = STM32MP1_SHRES_RTC;
+		break;
+	case RNG1_BASE:
+		id = STM32MP1_SHRES_RNG1;
+		break;
+	case CRYP1_BASE:
+		id = STM32MP1_SHRES_CRYP1;
+		break;
+	case HASH1_BASE:
+		id = STM32MP1_SHRES_HASH1;
+		break;
+
+	case GPIOA_BASE:
+	case GPIOB_BASE:
+	case GPIOC_BASE:
+	case GPIOD_BASE:
+	case GPIOE_BASE:
+	case GPIOF_BASE:
+	case GPIOG_BASE:
+	case GPIOH_BASE:
+	case GPIOI_BASE:
+	case GPIOJ_BASE:
+	case GPIOK_BASE:
+	case USART2_BASE:
+	case USART3_BASE:
+	case UART4_BASE:
+	case UART5_BASE:
+	case USART6_BASE:
+	case UART7_BASE:
+	case UART8_BASE:
+	case IWDG2_BASE:
+		/* Allow drivers to register some non secure resources */
+		VERBOSE("IO for non secure resource 0x%x\n",
+			(unsigned int)base);
+		if (state != SHRES_NON_SECURE) {
+			panic();
+		}
+
+		return;
+
+	default:
+		panic();
+		break;
+	}
+
+	register_periph(id, state);
+}
+
+void stm32mp_register_secure_periph_iomem(uintptr_t base)
+{
+	register_periph_iomem(base, SHRES_SECURE);
+}
+
+void stm32mp_register_non_secure_periph_iomem(uintptr_t base)
+{
+	register_periph_iomem(base, SHRES_NON_SECURE);
+}
+
+/* Register GPIO resource */
+void stm32mp_register_secure_gpio(unsigned int bank, unsigned int pin)
+{
+	switch (bank) {
+	case GPIO_BANK_Z:
+		register_periph(STM32MP1_SHRES_GPIOZ(pin), SHRES_SECURE);
+		break;
+	default:
+		ERROR("GPIO bank %u cannot be secured\n", bank);
+		panic();
+	}
+}
+
+void stm32mp_register_non_secure_gpio(unsigned int bank, unsigned int pin)
+{
+	switch (bank) {
+	case GPIO_BANK_Z:
+		register_periph(STM32MP1_SHRES_GPIOZ(pin), SHRES_NON_SECURE);
+		break;
+	default:
+		break;
+	}
+}
+
+void stm32mp1_register_etzpc_decprot(unsigned int id,
+				     enum etzpc_decprot_attributes attr)
+{
+	unsigned int state = SHRES_SECURE;
+	unsigned int id_shres;
+
+	switch (attr) {
+	case TZPC_DECPROT_S_RW:
+		break;
+	case TZPC_DECPROT_NS_R_S_W:
+	case TZPC_DECPROT_MCU_ISOLATION:
+	case TZPC_DECPROT_NS_RW:
+		state = SHRES_NON_SECURE;
+		break;
+	default:
+		panic();
+	}
+
+	id_shres = decprot2shres(id);
+	if (id_shres == SHRES_INVALID) {
+		if (state == SHRES_SECURE) {
+			panic();
+		}
+	} else {
+		register_periph(id_shres, state);
+	}
+}
+
+/* Get resource state: these accesses lock the registering support */
+static void lock_registering(void)
+{
+	registering_locked = true;
+}
+
+bool stm32mp1_periph_is_shared(unsigned long id)
+{
+	lock_registering();
+
+	return shres_state[id] == SHRES_SHARED;
+}
+
+bool stm32mp1_periph_is_non_secure(unsigned long id)
+{
+	lock_registering();
+
+	return shres_state[id] == SHRES_NON_SECURE;
+}
+
+bool stm32mp1_periph_is_secure(unsigned long id)
+{
+	lock_registering();
+
+	return shres_state[id] == SHRES_SECURE;
+}
+
+bool stm32mp1_periph_is_unregistered(unsigned long id)
+{
+	lock_registering();
+
+	return shres_state[id] == SHRES_UNREGISTERED;
+}
+
+bool stm32mp_gpio_bank_is_shared(unsigned int bank)
+{
+	unsigned int non_secure = 0;
+	unsigned int i;
+
+	lock_registering();
+
+	if (bank != GPIO_BANK_Z) {
+		return false;
+	}
+
+	for (i = 0U; i < get_gpioz_nbpin(); i++) {
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_GPIOZ(i)) ||
+		    stm32mp1_periph_is_unregistered(STM32MP1_SHRES_GPIOZ(i))) {
+			non_secure++;
+		}
+	}
+
+	return (non_secure != 0) && (non_secure < get_gpioz_nbpin());
+}
+
+bool stm32mp_gpio_bank_is_non_secure(unsigned int bank)
+{
+	unsigned int non_secure = 0;
+	unsigned int i;
+
+	lock_registering();
+
+	if (bank != GPIO_BANK_Z) {
+		return true;
+	}
+
+	for (i = 0U; i < get_gpioz_nbpin(); i++) {
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_GPIOZ(i)) ||
+		    stm32mp1_periph_is_unregistered(STM32MP1_SHRES_GPIOZ(i))) {
+			non_secure++;
+		}
+	}
+
+	return non_secure == get_gpioz_nbpin();
+}
+
+bool stm32mp_gpio_bank_is_secure(unsigned int bank)
+{
+	unsigned int secure = 0;
+	unsigned int i;
+
+	lock_registering();
+
+	if (bank != GPIO_BANK_Z) {
+		return false;
+	}
+
+	for (i = 0U; i < get_gpioz_nbpin(); i++) {
+		if (stm32mp1_periph_is_secure(STM32MP1_SHRES_GPIOZ(i))) {
+			secure++;
+		}
+	}
+
+	return secure == get_gpioz_nbpin();
+}
+
+bool stm32mp1_clock_is_shareable(unsigned long clock_id)
+{
+	switch (clock_id) {
+	case GPIOZ:
+		return get_gpioz_nbpin() > 0;
+	case RTCAPB:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool stm32mp1_clock_is_shared(unsigned long clock_id)
+{
+	lock_registering();
+
+	switch (clock_id) {
+	case GPIOZ:
+		if (get_gpioz_nbpin() > 0) {
+			return stm32mp_gpio_bank_is_shared(GPIO_BANK_Z);
+		} else {
+			return false;
+		}
+	case RTCAPB:
+		/* RTCAPB is shared for non secure backup registers */
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool stm32mp1_clock_is_non_secure(unsigned long clock_id)
+{
+	unsigned int shres_id;
+
+	lock_registering();
+
+	if (stm32mp1_clock_is_shared(clock_id)) {
+		return false;
+	}
+
+	switch (clock_id) {
+	case BSEC:
+	case BKPSRAM:
+	case TZPC:
+	case TZC1:
+	case TZC2:
+	case STGEN_K:
+	case DDRC1:
+	case DDRC1LP:
+	case DDRC2:
+	case DDRC2LP:
+	case DDRPHYC:
+	case DDRPHYCLP:
+	case DDRCAPB:
+	case DDRCAPBLP:
+	case AXIDCG:
+	case DDRPHYCAPB:
+	case DDRPHYCAPBLP:
+		return false;
+	case IWDG1:
+		shres_id = STM32MP1_SHRES_IWDG1;
+		break;
+	case USART1_K:
+		shres_id = STM32MP1_SHRES_USART1;
+		break;
+	case SPI6_K:
+		shres_id = STM32MP1_SHRES_SPI6;
+		break;
+	case I2C4_K:
+		shres_id = STM32MP1_SHRES_I2C4;
+		break;
+	case RNG1_K:
+		shres_id = STM32MP1_SHRES_RNG1;
+		break;
+	case HASH1:
+		shres_id = STM32MP1_SHRES_HASH1;
+		break;
+	case CRYP1:
+		shres_id = STM32MP1_SHRES_CRYP1;
+		break;
+	case I2C6_K:
+		shres_id = STM32MP1_SHRES_I2C6;
+		break;
+	case RTC:
+		shres_id = STM32MP1_SHRES_RTC;
+		break;
+	default:
+		return true;
+	}
+
+	return stm32mp1_periph_is_non_secure(shres_id);
+}
+
+/* ETZPC configuration at drivers initialization completion */
+static enum etzpc_decprot_attributes decprot_periph_attr(unsigned int id)
+{
+	switch (id) {
+	case STM32MP1_SHRES_GPIOZ(0) ... STM32MP1_SHRES_GPIOZ(7):
+		assert((id - STM32MP1_SHRES_GPIOZ(0)) < get_gpioz_nbpin());
+		return TZPC_DECPROT_NS_RW;
+	default:
+		if (stm32mp1_periph_is_non_secure(id)) {
+			return TZPC_DECPROT_NS_RW;
+		}
+
+		return TZPC_DECPROT_S_RW;
+	}
+}
+
+static bool check_decprot(unsigned int id, enum etzpc_decprot_attributes exp)
+{
+	enum etzpc_decprot_attributes cur = etzpc_get_decprot(id);
+
+	if (cur == exp) {
+		return true;
+	}
+
+	switch (exp) {
+	case TZPC_DECPROT_NS_RW:
+		if (cur == TZPC_DECPROT_S_RW) {
+			WARN("ETZPC: %s (%d) could be non secure\n",
+			     decprot2str(id), id);
+		}
+		return true;
+
+	case TZPC_DECPROT_S_RW:
+		ERROR("ETZPC: %s (%d) expected secure but DECPROT = %d\n",
+		      decprot2str(id), id, cur);
+		break;
+
+	case TZPC_DECPROT_NS_R_S_W:
+	case TZPC_DECPROT_MCU_ISOLATION:
+	default:
+		panic();
+	}
+
+	return false;
+}
+
+static void check_etzpc_secure_configuration(void)
+{
+	bool error = false;
+
+	assert(registering_locked);
+
+	error |= !check_decprot(STM32MP1_ETZPC_STGENC_ID, TZPC_DECPROT_S_RW);
+
+	error |= !check_decprot(STM32MP1_ETZPC_BKPSRAM_ID, TZPC_DECPROT_S_RW);
+
+	error |= !check_decprot(STM32MP1_ETZPC_USART1_ID,
+				decprot_periph_attr(STM32MP1_SHRES_USART1));
+
+	error |= !check_decprot(STM32MP1_ETZPC_SPI6_ID,
+				decprot_periph_attr(STM32MP1_SHRES_SPI6));
+
+	error |= !check_decprot(STM32MP1_ETZPC_I2C4_ID,
+				decprot_periph_attr(STM32MP1_SHRES_I2C4));
+
+	error |= !check_decprot(STM32MP1_ETZPC_RNG1_ID,
+				decprot_periph_attr(STM32MP1_SHRES_RNG1));
+
+	error |= !check_decprot(STM32MP1_ETZPC_HASH1_ID,
+				decprot_periph_attr(STM32MP1_SHRES_HASH1));
+
+	error |= !check_decprot(STM32MP1_ETZPC_CRYP1_ID,
+				decprot_periph_attr(STM32MP1_SHRES_CRYP1));
+
+	error |= !check_decprot(STM32MP1_ETZPC_DDRCTRL_ID, TZPC_DECPROT_S_RW);
+
+	error |= !check_decprot(STM32MP1_ETZPC_DDRPHYC_ID, TZPC_DECPROT_S_RW);
+
+	error |= !check_decprot(STM32MP1_ETZPC_I2C6_ID,
+				decprot_periph_attr(STM32MP1_SHRES_I2C6));
+
+	if (error) {
+		panic();
+	}
+}
+
+static void check_rcc_secure_configuration(void)
+{
+	uint32_t n;
+	uint32_t error = 0;
+	bool mckprot = stm32mp1_rcc_is_mckprot();
+	bool secure = stm32mp1_rcc_is_secure();
+
+	for (n = 0; n < ARRAY_SIZE(shres_state); n++) {
+		if  ((shres_state[n] == SHRES_SECURE) ||
+		     (shres_state[n] == SHRES_SHARED)) {
+			if ((stm32mp1_mckprot_resource(n) && (!mckprot)) ||
+			    !secure) {
+				ERROR("RCC %s MCKPROT %s and %s (%u) secure\n",
+				      secure ? "secure" : "non secure",
+				      mckprot ? "set" : "not set",
+				      shres2str_id(n), n);
+				error++;
+			}
+		}
+	}
+
+	if (error != 0U) {
+		panic();
+	}
+}
+
+static void check_gpio_secure_configuration(void)
+{
+	uint32_t pin;
+
+	for (pin = 0U; pin < get_gpioz_nbpin(); pin++) {
+		bool secure =
+			stm32mp1_periph_is_secure(STM32MP1_SHRES_GPIOZ(pin));
+
+		set_gpio_secure_cfg(GPIO_BANK_Z, pin, secure);
+	}
+}
+
+void stm32mp1_driver_init_late(void)
+{
+	uint32_t __unused id;
+
+	registering_locked = true;
+
+#if LOG_LEVEL >= LOG_LEVEL_INFO
+	for (id = 0; id < STM32MP1_SHRES_COUNT; id++) {
+		uint8_t *state = &shres_state[id];
+
+		/* Display only the secure and shared resources */
+		if ((*state == SHRES_NON_SECURE) ||
+		    ((*state == SHRES_UNREGISTERED))) {
+			continue;
+		}
+
+		INFO("stm32mp %s (%u): %s\n",
+		     shres2str_id(id), id,
+		     *state == SHRES_SECURE ? "Secure only" :
+		     *state == SHRES_SHARED ? "Shared" :
+		     *state == SHRES_NON_SECURE ? "Non secure" :
+		     *state == SHRES_UNREGISTERED ? "Unregistered" :
+		     "<Invalid>");
+	}
+#endif
+
+	stm32mp1_update_earlyboot_clocks_state();
+
+	check_rcc_secure_configuration();
+	check_etzpc_secure_configuration();
+	check_gpio_secure_configuration();
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_stack_protector.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_stack_protector.c
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <platform.h>
+#include <stdint.h>
+
+#define RANDOM_CANARY_VALUE	2144346116U
+
+u_register_t plat_get_stack_protector_canary(void)
+{
+	/*
+	 * Ideally, a random number should be returned instead of the
+	 * combination of a timer's value and a compile-time constant.
+	 */
+	return RANDOM_CANARY_VALUE ^ (u_register_t)read_cntpct_el0();
+}
+
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_syscfg.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_syscfg.c
@@ -0,0 +1,206 @@
+/*
+ * Copyright (c) 2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <debug.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <mmio.h>
+#include <platform_def.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp1_clk.h>
+#include <stm32mp1_private.h>
+#include <stpmic1.h>
+
+/*
+ * SYSCFG register offsets (base relative)
+ */
+#define SYSCFG_BOOTR				0x00U
+#define SYSCFG_IOCTRLSETR			0x18U
+#define SYSCFG_ICNR				0x1CU
+#define SYSCFG_CMPCR				0x20U
+#define SYSCFG_CMPENSETR			0x24U
+
+/*
+ * SYSCFG_BOOTR Register
+ */
+#define SYSCFG_BOOTR_BOOT_MASK			GENMASK(2, 0)
+#define SYSCFG_BOOTR_BOOTPD_SHIFT		4
+/*
+ * SYSCFG_IOCTRLSETR Register
+ */
+#define SYSCFG_IOCTRLSETR_HSLVEN_TRACE		BIT(0)
+#define SYSCFG_IOCTRLSETR_HSLVEN_QUADSPI	BIT(1)
+#define SYSCFG_IOCTRLSETR_HSLVEN_ETH		BIT(2)
+#define SYSCFG_IOCTRLSETR_HSLVEN_SDMMC		BIT(3)
+#define SYSCFG_IOCTRLSETR_HSLVEN_SPI		BIT(4)
+
+/*
+ * SYSCFG_ICNR Register
+ */
+#define SYSCFG_ICNR_AXI_M9			BIT(9)
+
+/*
+ * SYSCFG_CMPCR Register
+ */
+#define SYSCFG_CMPCR_SW_CTRL			BIT(1)
+#define SYSCFG_CMPCR_READY			BIT(8)
+#define SYSCFG_CMPCR_RANSRC			GENMASK(19, 16)
+#define SYSCFG_CMPCR_RANSRC_SHIFT		16
+#define SYSCFG_CMPCR_RAPSRC			GENMASK(23, 20)
+#define SYSCFG_CMPCR_ANSRC_SHIFT		24
+
+#define SYSCFG_CMPCR_READY_TIMEOUT_US		10000U
+
+/*
+ * SYSCFG_CMPENSETR Register
+ */
+#define SYSCFG_CMPENSETR_MPU_EN			BIT(0)
+
+void stm32mp1_syscfg_init(void)
+{
+	uint32_t bootr;
+	uint32_t otp_value;
+	uint32_t vdd_voltage;
+	uintptr_t syscfg_base = dt_get_syscfg_base();
+	bool product_below_2v5;
+
+	/*
+	 * Interconnect update : select master using the port 1.
+	 * LTDC = AXI_M9.
+	 */
+	mmio_write_32(syscfg_base + SYSCFG_ICNR, SYSCFG_ICNR_AXI_M9);
+	VERBOSE("[0x%x] SYSCFG.icnr = 0x%08x (LTDC)\n",
+		(uint32_t)syscfg_base + SYSCFG_ICNR,
+		mmio_read_32(syscfg_base + SYSCFG_ICNR));
+
+	/* Disable Pull-Down for boot pin connected to VDD */
+	bootr = mmio_read_32(syscfg_base + SYSCFG_BOOTR);
+	bootr &= ~(SYSCFG_BOOTR_BOOT_MASK << SYSCFG_BOOTR_BOOTPD_SHIFT);
+	bootr |= (bootr & SYSCFG_BOOTR_BOOT_MASK) << SYSCFG_BOOTR_BOOTPD_SHIFT;
+	mmio_write_32(syscfg_base + SYSCFG_BOOTR, bootr);
+	VERBOSE("[0x%x] SYSCFG.bootr = 0x%08x\n",
+		(uint32_t)syscfg_base + SYSCFG_BOOTR,
+		mmio_read_32(syscfg_base + SYSCFG_BOOTR));
+
+	/*
+	 * High Speed Low Voltage Pad mode Enable for SPI, SDMMC, ETH, QSPI
+	 * and TRACE. Needed above ~50MHz and conditioned by AFMUX selection.
+	 * It could be disabled for low frequencies or if AFMUX is selected
+	 * but the function not used, typically for TRACE.
+	 * Otherwise, impact on power consumption.
+	 *
+	 * WARNING:
+	 *   Enabling High Speed mode while VDD > 2.7V
+	 *   with the OTP product_below_2v5 (OTP 18, BIT 13)
+	 *   erroneously set to 1 can damage the IC!
+	 *   => TF-A enables the low power mode only if VDD < 2.7V (in DT)
+	 *      but this value needs to be consistent with board design.
+	 */
+	if (stm32_get_otp_value(HW2_OTP, &otp_value) != 0) {
+		panic();
+	}
+
+	product_below_2v5 = (otp_value & HW2_OTP_PRODUCT_BELOW_2V5) != 0U;
+
+	/* Get VDD supply */
+	vdd_voltage = dt_get_pwr_vdd_voltage();
+	VERBOSE("VDD regulator voltage = %d\n", vdd_voltage);
+
+	/* Check if VDD is Low Voltage */
+	if (vdd_voltage == 0U) {
+		WARN("VDD unknown\n");
+	} else if (vdd_voltage < 2700000U) {
+		mmio_write_32(syscfg_base + SYSCFG_IOCTRLSETR,
+			      SYSCFG_IOCTRLSETR_HSLVEN_TRACE |
+			      SYSCFG_IOCTRLSETR_HSLVEN_QUADSPI |
+			      SYSCFG_IOCTRLSETR_HSLVEN_ETH |
+			      SYSCFG_IOCTRLSETR_HSLVEN_SDMMC |
+			      SYSCFG_IOCTRLSETR_HSLVEN_SPI);
+
+		if (!product_below_2v5) {
+			INFO("Product_below_2v5=0: HSLVEN protected by HW\n");
+		}
+	} else {
+		if (product_below_2v5) {
+			ERROR("Product_below_2v5=1: HSLVEN update is destructive, no update as VDD>2.7V\n");
+			panic();
+		}
+	}
+
+	VERBOSE("[0x%x] SYSCFG.IOCTRLSETR = 0x%08x\n",
+		(uint32_t)syscfg_base + SYSCFG_IOCTRLSETR,
+		mmio_read_32(syscfg_base + SYSCFG_IOCTRLSETR));
+
+	stm32mp1_syscfg_enable_io_compensation();
+}
+
+void stm32mp1_syscfg_enable_io_compensation(void)
+{
+	uintptr_t syscfg_base = dt_get_syscfg_base();
+	uint64_t start;
+
+	/*
+	 * Activate automatic I/O compensation.
+	 * Warning: need to ensure CSI enabled and ready in clock driver.
+	 * Enable non-secure clock, we assume non-secure is suspended.
+	 */
+	stm32mp1_clk_enable_non_secure(SYSCFG);
+
+	mmio_setbits_32(syscfg_base + SYSCFG_CMPENSETR,
+			SYSCFG_CMPENSETR_MPU_EN);
+
+	start = timeout_start();
+
+	while ((mmio_read_32(syscfg_base + SYSCFG_CMPCR) &
+		SYSCFG_CMPCR_READY) == 0U) {
+		if (timeout_elapsed(start, SYSCFG_CMPCR_READY_TIMEOUT_US)) {
+			/*
+			 * Failure on IO compensation enable is not a issue:
+			 * warn only.
+			 */
+			WARN("IO compensation cell not ready\n");
+			break;
+		}
+	}
+
+	mmio_clrbits_32(syscfg_base + SYSCFG_CMPCR, SYSCFG_CMPCR_SW_CTRL);
+
+	VERBOSE("[0x%x] SYSCFG.cmpcr = 0x%08x\n",
+		(uint32_t)syscfg_base + SYSCFG_CMPCR,
+		mmio_read_32(syscfg_base + SYSCFG_CMPCR));
+}
+
+void stm32mp1_syscfg_disable_io_compensation(void)
+{
+	uintptr_t syscfg_base = dt_get_syscfg_base();
+	uint32_t value;
+
+	/*
+	 * Deactivate automatic I/O compensation.
+	 * Warning: CSI is disabled automatically in STOP if not
+	 * requested for other usages and always OFF in STANDBY.
+	 * Disable non-secure SYSCFG clock, we assume non-secure is suspended.
+	 */
+	value = mmio_read_32(syscfg_base + SYSCFG_CMPCR) >>
+	      SYSCFG_CMPCR_ANSRC_SHIFT;
+
+	mmio_clrbits_32(syscfg_base + SYSCFG_CMPCR,
+			SYSCFG_CMPCR_RANSRC | SYSCFG_CMPCR_RAPSRC);
+
+	value = mmio_read_32(syscfg_base + SYSCFG_CMPCR) |
+		(value << SYSCFG_CMPCR_RANSRC_SHIFT);
+
+	mmio_write_32(syscfg_base + SYSCFG_CMPCR, value | SYSCFG_CMPCR_SW_CTRL);
+
+	VERBOSE("[0x%x] SYSCFG.cmpcr = 0x%08x\n",
+		(uint32_t)syscfg_base + SYSCFG_CMPCR,
+		mmio_read_32(syscfg_base + SYSCFG_CMPCR));
+
+	mmio_clrbits_32(syscfg_base + SYSCFG_CMPENSETR,
+			SYSCFG_CMPENSETR_MPU_EN);
+
+	stm32mp1_clk_disable_non_secure(SYSCFG);
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_topology.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_topology.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2015-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+#include <platform.h>
+#include <psci.h>
+
+/* 1 cluster, all cores into */
+static const unsigned char stm32mp1_power_domain_tree_desc[] = {
+	PLATFORM_CLUSTER_COUNT,
+	PLATFORM_CORE_COUNT,
+};
+
+/* This function returns the platform topology */
+const unsigned char *plat_get_power_domain_tree_desc(void)
+{
+	return stm32mp1_power_domain_tree_desc;
+}
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform that allows the former to query the platform
+ * to convert an MPIDR to a unique linear index. An error code (-1) is returned
+ * in case the MPIDR is invalid.
+ ******************************************************************************/
+int plat_core_pos_by_mpidr(u_register_t mpidr)
+{
+	unsigned int cluster_id, cpu_id;
+	u_register_t mpidr_copy = mpidr;
+
+	mpidr_copy &= MPIDR_AFFINITY_MASK;
+
+	if ((mpidr_copy & ~(MPIDR_CLUSTER_MASK | MPIDR_CPU_MASK)) != 0U) {
+		return -1;
+	}
+
+	cluster_id = (mpidr_copy >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+	cpu_id = (mpidr_copy >> MPIDR_AFF0_SHIFT) & MPIDR_AFFLVL_MASK;
+
+	if (cluster_id >= PLATFORM_CLUSTER_COUNT) {
+		return -1;
+	}
+
+	/*
+	 * Validate cpu_id by checking whether it represents a CPU in one
+	 * of the two clusters present on the platform.
+	 */
+	if (cpu_id >= PLATFORM_CORE_COUNT) {
+		return -1;
+	}
+
+	return (int)cpu_id;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_usb_desc.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_usb_desc.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (c) 2015-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <bsec.h>
+#include <debug.h>
+#include <limits.h>
+#include <platform_def.h>
+#include <stm32mp_common.h>
+#include <stm32mp1_usb_desc.h>
+#include <string.h>
+#include <usb_core.h>
+#include <usb_st_dfu.h>
+
+/* USB Standard Device Descriptor */
+static const uint8_t usb_stm32mp1_desc[USB_LEN_DEV_DESC] = {
+	USB_LEN_DEV_DESC,           /* bLength */
+	USB_DESC_TYPE_DEVICE,       /* bDescriptorType */
+	0x00,                       /* bcdUSB */
+	0x02,                       /* version */
+	0x00,                       /* bDeviceClass */
+	0x00,                       /* bDeviceSubClass */
+	0x00,                       /* bDeviceProtocol */
+	USB_MAX_EP0_SIZE,           /* bMaxPacketSize */
+	LOBYTE(USBD_VID),           /* idVendor */
+	HIBYTE(USBD_VID),           /* idVendor */
+	LOBYTE(USBD_PID),           /* idVendor */
+	HIBYTE(USBD_PID),           /* idVendor */
+	0x00,                       /* bcdDevice rel. 2.00 */
+	0x02,
+	USBD_IDX_MFC_STR,           /* Index of manufacturer string */
+	USBD_IDX_PRODUCT_STR,       /* Index of product string */
+	USBD_IDX_SERIAL_STR,        /* Index of serial number string */
+	USBD_MAX_NUM_CONFIGURATION  /* bNumConfigurations */
+}; /* USB_DeviceDescriptor */
+
+/* USB Standard String Descriptor */
+static const uint8_t usb_stm32mp1_lang_id_desc[USB_LEN_LANGID_STR_DESC] = {
+	USB_LEN_LANGID_STR_DESC,
+	USB_DESC_TYPE_STRING,
+	LOBYTE(USBD_LANGID_STRING),
+	HIBYTE(USBD_LANGID_STRING),
+};
+
+/* USB Standard Device Descriptor */
+static const uint8_t
+usbd_stm32mp1_qualifier_desc[USB_LEN_DEV_QUALIFIER_DESC] = {
+	USB_LEN_DEV_QUALIFIER_DESC,
+	USB_DESC_TYPE_DEVICE_QUALIFIER,
+	0x00,
+	0x02,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x01,
+	0x00,
+};
+
+static uint8_t usb_stm32mp1_serial[USB_SIZ_STRING_SERIAL + 1] = {
+	USB_SIZ_STRING_SERIAL,
+	USB_DESC_TYPE_STRING,
+};
+
+/* USB DFU device Configuration Descriptor */
+static uint8_t usb_stm32mp1_config_desc[USB_DFU_CONFIG_DESC_SIZ] = {
+	0x09, /* bLength: Configuation Descriptor size */
+	USB_DESC_TYPE_CONFIGURATION, /* bDescriptorType: Configuration */
+	USB_DFU_CONFIG_DESC_SIZ,
+	/* wTotalLength: Bytes returned */
+	0x00,
+	0x01,/* bNumInterfaces: 1 interface*/
+	0x01,/* bConfigurationValue: Configuration value*/
+	0x02,/* iConfiguration: Index of string descriptor
+	      *	describing the configuration
+	      */
+	0xC0,/* bmAttributes: bus powered and Supprts Remote Wakeup */
+	0x32,/* MaxPower 100 mA: this current is used for detecting Vbus */
+	/* 09 */
+
+	/* Descriptor of DFU interface 0 Alternate setting 0 */
+	USBD_DFU_IF_DESC(0), /* This interface is mandatory for all devices */
+
+	/* Descriptor of DFU interface 0 Alternate setting 1 */
+	USBD_DFU_IF_DESC(1),
+
+	/* Descriptor of DFU interface 0 Alternate setting 2 */
+	USBD_DFU_IF_DESC(2),
+
+	/* Descriptor of DFU interface 0 Alternate setting 3 */
+	USBD_DFU_IF_DESC(3),
+
+	/* Descriptor of DFU interface 0 Alternate setting 4 */
+	USBD_DFU_IF_DESC(4),
+
+	/* Descriptor of DFU interface 0 Alternate setting 5 */
+	USBD_DFU_IF_DESC(5),
+
+	/* DFU Functional Descriptor */
+	0x09,/* blength = 9 Bytes */
+	DFU_DESCRIPTOR_TYPE,/* DFU Functional Descriptor*/
+	DFU_BM_ATTRIBUTE,/* bmAttribute
+			  * bitCanDnload		= 1 (bit 0)
+			  * bitCanUpload		= 1 (bit 1)
+			  * bitManifestationTolerant	= 1 (bit 2)
+			  * bitWillDetach		= 1 (bit 3)
+			  * Reserved			(bit4-6)
+			  * bitAcceleratedST		= 0 (bit 7)
+			  */
+	0xFF,/* DetachTimeOut = 255 ms */
+	0x00,
+	/* WARNING: In DMA mode the multiple MPS packets feature
+	 *  is still not supported ==> In this case,
+	 *  when using DMA USBD_DFU_XFER_SIZE should be set
+	 *  to 64 in usbd_conf.h
+	 */
+	TRANSFER_SIZE_BYTES(USBD_DFU_XFER_SIZE),/* TransferSize = 1024 Byte*/
+	((USB_DFU_VERSION >> 0) & 0xFF), /* bcdDFUVersion*/
+	((USB_DFU_VERSION >> 8) & 0xFF)
+};
+
+static uint8_t usb_local_string_dec[USBD_MAX_STR_DESC_SIZ];
+
+/*
+ * Convert Hex 32Bits value into char
+ * value: value to convert
+ * pbuf: pointer to the buffer
+ * len: buffer length
+ */
+static void int_to_unicode(uint32_t value, uint8_t *pbuf, uint8_t len)
+{
+	uint8_t idx = 0;
+
+	for (idx = 0; idx < len; idx++) {
+		if (((value >> 28)) < 0xA)
+			pbuf[2 * idx] = (value >> 28) + '0';
+		else
+			pbuf[2 * idx] = (value >> 28) + 'A' - 10;
+		value = value << 4;
+		pbuf[(2 * idx) + 1] = 0;
+	}
+}
+
+/*
+ * Create the serial number string descriptor
+ */
+static void update_serial_num_string(void)
+{
+	/* serial number is set to 0*/
+	uint8_t i;
+	uint32_t deviceserial[UID_WORD_NB] = {0U, 0U, 0U};
+	uint32_t otp;
+	uint32_t len;
+
+	if (stm32_get_otp_index(UID_OTP, &otp, &len) != 0) {
+		ERROR("BSEC: Get UID_OTP number Error\n");
+		return;
+	}
+
+	if ((len / __WORD_BIT) != UID_WORD_NB) {
+		ERROR("BSEC: Get UID_OTP length Error\n");
+		return;
+	}
+
+	for (i = 0; i < UID_WORD_NB; i++) {
+		if (bsec_shadow_read_otp(&deviceserial[i], i + otp) !=
+		    BSEC_OK) {
+			ERROR("BSEC: UID%d Error\n", i);
+			return;
+		}
+	}
+
+	int_to_unicode(deviceserial[0], (uint8_t *)&usb_stm32mp1_serial[2], 8);
+	int_to_unicode(deviceserial[1], (uint8_t *)&usb_stm32mp1_serial[18], 8);
+	int_to_unicode(deviceserial[2], (uint8_t *)&usb_stm32mp1_serial[34], 8);
+}
+
+/*
+ * usb_get_qualifier_desc
+ *         return Device Qualifier descriptor
+ * param :  length : pointer data length
+ * return : pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_get_qualifier_desc(uint16_t *length)
+{
+	*length = sizeof(usbd_stm32mp1_qualifier_desc);
+	return (uint8_t *)usbd_stm32mp1_qualifier_desc;
+}
+
+/*
+ * stm32mp1_get_dfu_desc
+ *         return Device Qualifier descriptor
+ * param :  length : pointer data length
+ * return : pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_get_dfu_desc(uint16_t *len)
+{
+	*len = USB_DFU_DESC_SIZ;
+	return ((uint8_t *)usb_stm32mp1_config_desc + (9 * 7));
+}
+
+/*
+ * stm32mp1_get_config_desc
+ *         return configuration descriptor
+ * param : speed : current device speed
+ * param : length : pointer data length
+ * return : pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_get_config_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp1_config_desc);
+	return (uint8_t *)usb_stm32mp1_config_desc;
+}
+
+/*
+ * stm32mp1_get_string
+ *         Convert Ascii string into unicode one
+ * param : desc : descriptor buffer
+ * param : unicode : Formatted string buffer (unicode)
+ * param : len : descriptor length
+ * return : None
+ */
+static void stm32mp1_get_string(uint8_t *desc, uint8_t *unicode, uint16_t *len)
+{
+	uint8_t idx = 0;
+
+	if (!desc)
+		return;
+
+	*len =  strlen((char *)desc) * 2 + 2;
+	unicode[idx++] = *len;
+	unicode[idx++] =  USB_DESC_TYPE_STRING;
+
+	while (*desc != '\0') {
+		unicode[idx++] = *desc++;
+		unicode[idx++] =  0x00;
+	}
+}
+
+/*
+ * stm32mp1_device_desc
+ * Returns the device descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_device_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp1_desc);
+	return (uint8_t *)usb_stm32mp1_desc;
+}
+
+/*
+ * stm32mp1_lang_id_desc
+ * Returns the LangID string descriptor.
+ * speed: Current device speed
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_lang_id_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp1_lang_id_desc);
+
+	return (uint8_t *)usb_stm32mp1_lang_id_desc;
+}
+
+/*
+ * stm32mp1_product_desc
+ * Returns the product string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_product_desc(uint16_t *length)
+{
+	stm32mp1_get_string((uint8_t *)USBD_PRODUCT_HS_STRING,
+			    usb_local_string_dec, length);
+
+	return usb_local_string_dec;
+}
+
+/*
+ * stm32mp1_manufacturer_desc
+ * Returns the manufacturer string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_manufacturer_desc(uint16_t *length)
+{
+	stm32mp1_get_string((uint8_t *)USBD_MANUFACTURER_STRING,
+			    usb_local_string_dec, length);
+
+	return usb_local_string_dec;
+}
+
+/*
+ * stm32mp1_serial_desc
+ * Returns the serial number string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_serial_desc(uint16_t *length)
+{
+	*length = USB_SIZ_STRING_SERIAL;
+
+	/* Update the serial number string descriptor
+	 * with the data from the unique ID
+	 */
+	update_serial_num_string();
+
+	return (uint8_t *)usb_stm32mp1_serial;
+}
+
+/*
+ * stm32mp1_Config_desc
+ * Returns the configuration string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_config_desc(uint16_t *length)
+{
+	stm32mp1_get_string((uint8_t *)USBD_CONFIGURATION_HS_STRING,
+			    usb_local_string_dec, length);
+
+	return usb_local_string_dec;
+}
+
+/*
+ * stm32mp1_interface_desc
+ * Returns the interface string descriptor.
+ * length : Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp1_interface_desc(uint16_t *length)
+{
+	stm32mp1_get_string((uint8_t *)USBD_INTERFACE_HS_STRING,
+			    usb_local_string_dec, length);
+
+	return usb_local_string_dec;
+}
+
+/*
+ * stm32mp1_get_usr_desc
+ *         Manages the transfer of memory interfaces string descriptors.
+ * param : index: descriptor index
+ * param : length : pointer data length
+ * return : pointer to the descriptor table or NULL if the descriptor
+ *          is not supported.
+ */
+static uint8_t *stm32mp1_get_usr_desc(uint8_t index, uint16_t *length)
+{
+	uint8_t *ret;
+
+	if (index > (USBD_IDX_INTERFACE_STR + USBD_DESC_MAX_ITF_NUM))
+		return NULL;
+
+	switch (index) {
+	case 6:
+		stm32mp1_get_string((uint8_t *)"@Partition0 /0x00/1*256Ke",
+				    usb_local_string_dec, length);
+		ret = usb_local_string_dec;
+		break;
+	case 7:
+		stm32mp1_get_string((uint8_t *)"@FSBL /0x01/1*1Me",
+				    usb_local_string_dec, length);
+		ret = usb_local_string_dec;
+		break;
+	case 8:
+		stm32mp1_get_string((uint8_t *)"@Partition2 /0x02/1*1Me",
+				    usb_local_string_dec, length);
+		ret = usb_local_string_dec;
+		break;
+	case 9:
+		stm32mp1_get_string((uint8_t *)"@Partition3 /0x03/1*16Me",
+				    usb_local_string_dec, length);
+		ret = usb_local_string_dec;
+		break;
+	case 10:
+		stm32mp1_get_string((uint8_t *)"@Partition4 /0x04/1*16Me",
+				    usb_local_string_dec, length);
+		ret = usb_local_string_dec;
+		break;
+	case 11:
+		stm32mp1_get_string((uint8_t *)"@virtual /0xF1/1*512Ba",
+				    usb_local_string_dec, length);
+		ret = usb_local_string_dec;
+		break;
+	default:
+		ret = NULL;
+		break;
+	}
+
+	return ret;
+}
+
+static const usb_desc_t dfu_desc = {
+	.get_device_desc = stm32mp1_device_desc,
+	.get_lang_id_desc = stm32mp1_lang_id_desc,
+	.get_manufacturer_desc = stm32mp1_manufacturer_desc,
+	.get_product_desc = stm32mp1_product_desc,
+	.get_configuration_desc = stm32mp1_config_desc,
+	.get_serial_desc = stm32mp1_serial_desc,
+	.get_interface_desc = stm32mp1_interface_desc,
+	.get_usr_desc = stm32mp1_get_usr_desc,
+	.get_hs_config_desc = stm32mp1_get_config_desc,
+	.get_fs_config_desc = stm32mp1_get_config_desc,
+	.get_other_speed_config_desc = stm32mp1_get_config_desc,
+	.get_device_qualifier_desc = stm32mp1_get_qualifier_desc,
+	.get_dfu_desc = stm32mp1_get_dfu_desc
+};
+
+void stm32mp_usb_init_desc(usb_handle_t *pdev)
+{
+	register_platform(pdev, &dfu_desc);
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/sp_min/sp_min-txmp.mk
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/sp_min/sp_min-txmp.mk
@@ -0,0 +1,36 @@
+#
+# Copyright (c) 2017-2018, ARM Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+SP_MIN_WITH_SECURE_FIQ	:=	1
+
+BL32_SOURCES		+=	plat/common/aarch32/platform_mp_stack.S		\
+				drivers/st/clk/stm32mp1_calib.c			\
+				drivers/st/etzpc/etzpc.c			\
+				drivers/st/rng/stm32_rng.c			\
+				drivers/st/rtc/stm32_rtc.c			\
+				drivers/st/tamper/stm32_tamp.c			\
+				drivers/st/timer/stm32_timer.c 			\
+				plat/$(VENDOR)/$(PLAT)/sp_min/sp_min_setup.c		\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_low_power.c		\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_pm.c			\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_power_config.c	\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_topology.c
+# Generic GIC v2
+BL32_SOURCES		+=	drivers/arm/gic/common/gic_common.c	\
+				drivers/arm/gic/v2/gicv2_helpers.c	\
+				drivers/arm/gic/v2/gicv2_main.c		\
+				plat/common/plat_gicv2.c		\
+				plat/$(VENDOR)/$(PLAT)/stm32mp1_gic.c
+
+# Generic PSCI
+BL32_SOURCES		+=	plat/common/plat_psci_common.c
+
+# stm32mp1 specific services
+BL32_SOURCES		+=	plat/$(VENDOR)/$(PLAT)/services/bsec_svc.c		\
+				plat/$(VENDOR)/$(PLAT)/services/low_power_svc.c	\
+				plat/$(VENDOR)/$(PLAT)/services/pwr_svc.c		\
+				plat/$(VENDOR)/$(PLAT)/services/rcc_svc.c		\
+				plat/$(VENDOR)/$(PLAT)/services/stm32mp1_svc_setup.c
Index: arm-trusted-firmware.git/plat/karo/txmp/sp_min/sp_min_setup.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/sp_min/sp_min_setup.c
@@ -0,0 +1,390 @@
+/*
+ * Copyright (c) 2015-2020, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <assert.h>
+#include <bl_common.h>
+#include <bsec.h>
+#include <context.h>
+#include <context_mgmt.h>
+#include <debug.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <etzpc.h>
+#include <generic_delay_timer.h>
+#include <gicv2.h>
+#include <mmio.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <platform_sp_min.h>
+#include <stm32_console.h>
+#include <stm32_gpio.h>
+#include <stm32_iwdg.h>
+#include <stm32_rng.h>
+#include <stm32_rtc.h>
+#include <stm32_tamp.h>
+#include <stm32_timer.h>
+#include <stm32mp_dt.h>
+#include <stm32mp1_clk.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_ddr_helpers.h>
+#include <stm32mp1_power_config.h>
+#include <stm32mp1_private.h>
+#include <stm32mp1_shared_resources.h>
+#include <stpmic1.h>
+#include <string.h>
+#include <tzc400.h>
+#include <xlat_tables_v2.h>
+
+/******************************************************************************
+ * Placeholder variables for copying the arguments that have been passed to
+ * BL32 from BL2.
+ ******************************************************************************/
+static entry_point_info_t bl33_image_ep_info;
+
+static struct console_stm32 console;
+
+static struct stm32_tamp_int int_tamp[PLAT_MAX_TAMP_INT] = {
+	TAMP_UNUSED,
+	TAMP_UNUSED,
+	TAMP_UNUSED,
+	TAMP_UNUSED,
+	TAMP_UNUSED,
+};
+
+static struct stm32_tamp_ext ext_tamp[PLAT_MAX_TAMP_EXT] = {
+	TAMP_UNUSED,
+	TAMP_UNUSED,
+	TAMP_UNUSED,
+};
+
+static void tzc_it_handler(void)
+{
+	ERROR("No IT handler in ARM tzc400 driver\n");
+}
+
+static void stm32_sgi1_it_handler(void)
+{
+	uint32_t id;
+
+	stm32mp_mask_timer();
+
+	gicv2_end_of_interrupt(ARM_IRQ_SEC_SGI_1);
+
+	do {
+		id = plat_ic_get_pending_interrupt_id();
+
+		if (id <= MAX_SPI_ID) {
+			gicv2_end_of_interrupt(id);
+
+			plat_ic_disable_interrupt(id);
+		}
+	} while (id <= MAX_SPI_ID);
+
+	stm32mp_wait_cpu_reset();
+}
+
+static void configure_wakeup_interrupt(void)
+{
+	int irq_num = fdt_rcc_enable_it("wakeup");
+
+	if (irq_num < 0) {
+		ERROR("irq_num = %d\n", irq_num);
+		panic();
+	}
+
+	plat_ic_set_interrupt_priority(irq_num, STM32MP1_IRQ_RCC_SEC_PRIO);
+}
+
+static void initialize_pll1_settings(void)
+{
+	uint32_t vddcore_voltage = 1200000;
+
+	if (stm32_are_pll1_settings_valid_in_context()) {
+		return;
+	}
+
+	if (stm32mp1_clk_compute_all_pll1_settings(vddcore_voltage) != 0) {
+		panic();
+	}
+}
+
+/*******************************************************************************
+ * Interrupt handler for FIQ (secure IRQ)
+ ******************************************************************************/
+void sp_min_plat_fiq_handler(uint32_t id)
+{
+	uint32_t value = 0;
+
+	switch (id & INT_ID_MASK) {
+	case ARM_IRQ_SEC_PHY_TIMER:
+	case STM32MP1_IRQ_MCU_SEV:
+	case STM32MP1_IRQ_RCC_WAKEUP:
+		stm32mp1_calib_it_handler(id);
+		break;
+	case STM32MP1_IRQ_TZC400:
+		tzc400_init(STM32MP1_TZC_BASE);
+		tzc400_it_handler();
+		panic();
+		break;
+	case STM32MP1_IRQ_TAMPSERRS:
+		stm32_tamp_it_handler();
+		break;
+	case ARM_IRQ_SEC_SGI_1:
+		stm32_sgi1_it_handler();
+		break;
+	case STM32MP1_IRQ_IWDG1:
+	case STM32MP1_IRQ_IWDG2:
+		stm32_iwdg_it_handler(id);
+		break;
+	case STM32MP1_IRQ_AXIERRIRQ:
+		ERROR("STM32MP1_IRQ_AXIERRIRQ generated\n");
+		tzc400_init(STM32MP1_TZC_BASE);
+		__asm__("mrc	p15, 1, %0, c9, c0, 3" : "=r" (value));
+		if (value) {
+			/* we have a pending IT clear it */
+			value = 0;
+			__asm__("mcr	p15, 1, %0, c9, c0, 3" :: "r" (value));
+		} else {
+			ERROR("IRQ_AXIERRIRQ handle call w/o any flag set!!\n");
+		}
+
+		/* Check if FIQ has been generated due to TZC400 abort*/
+		if (tzc400_is_pending_interrupt()) {
+			tzc_it_handler();
+		} else {
+			ERROR("IRQ_AXIERRIRQ cause can't be detected");
+		}
+
+		panic();
+		break;
+	default:
+		ERROR("SECURE IT handler not define for it : %u", id);
+		break;
+	}
+}
+
+/*******************************************************************************
+ * Return a pointer to the 'entry_point_info' structure of the next image for
+ * the security state specified. BL33 corresponds to the non-secure image type
+ * while BL32 corresponds to the secure image type. A NULL pointer is returned
+ * if the image does not exist.
+ ******************************************************************************/
+entry_point_info_t *sp_min_plat_get_bl33_ep_info(void)
+{
+	entry_point_info_t *next_image_info;
+	uint32_t bkpr_core1_addr =
+		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
+	uint32_t bkpr_core1_magic =
+		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+
+	next_image_info = &bl33_image_ep_info;
+
+	/*
+	 * PC is set to 0 when resetting after STANDBY
+	 * The context should be restored, and the image information
+	 * should be filled with what what was saved
+	 */
+	if (next_image_info->pc == 0U) {
+		void *cpu_context;
+		uint32_t magic_nb, saved_pc;
+
+		stm32mp_clk_enable(RTCAPB);
+
+		magic_nb = mmio_read_32(bkpr_core1_magic);
+		saved_pc = mmio_read_32(bkpr_core1_addr);
+
+		stm32mp_clk_disable(RTCAPB);
+
+		if (stm32_restore_context() != 0) {
+			panic();
+		}
+
+		cpu_context = cm_get_context(NON_SECURE);
+
+		next_image_info->spsr = read_ctx_reg(get_regs_ctx(cpu_context),
+						     CTX_SPSR);
+
+		/* PC should be retrieved in backup register if OK, else it can
+		 * be retrieved from non-secure context
+		 */
+		if (magic_nb == BOOT_API_A7_CORE0_MAGIC_NUMBER) {
+			/* BL33 return address should be in DDR */
+			if ((saved_pc < STM32MP_DDR_BASE) ||
+			    (saved_pc > (STM32MP_DDR_BASE +
+					 (dt_get_ddr_size() - 1U)))) {
+				panic();
+			}
+
+			next_image_info->pc = saved_pc;
+		} else {
+			next_image_info->pc =
+				read_ctx_reg(get_regs_ctx(cpu_context), CTX_LR);
+		}
+	}
+
+	return next_image_info;
+}
+
+/*******************************************************************************
+ * Perform any BL32 specific platform actions.
+ ******************************************************************************/
+void sp_min_early_platform_setup2(u_register_t arg0, u_register_t arg1,
+				  u_register_t arg2, u_register_t arg3)
+{
+#if STM32MP_UART_PROGRAMMER
+	uint32_t boot_itf, boot_instance;
+#endif
+	struct dt_node_info dt_dev_info;
+	int result;
+	bl_params_t *params_from_bl2 = (bl_params_t *)arg0;
+
+	/* Imprecise aborts can be masked in NonSecure */
+	write_scr(read_scr() | SCR_AW_BIT);
+
+	assert(params_from_bl2 != NULL);
+	assert(params_from_bl2->h.type == PARAM_BL_PARAMS);
+	assert(params_from_bl2->h.version >= VERSION_2);
+
+	bl_params_node_t *bl_params = params_from_bl2->head;
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+#if SEPARATE_CODE_AND_RODATA
+	mmap_add_region(BL_RO_DATA_BASE, BL_RO_DATA_BASE,
+			BL_RO_DATA_LIMIT - BL_RO_DATA_BASE,
+			MT_RO_DATA | MT_SECURE);
+#endif
+
+	mmap_add_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
+			dt_get_ddr_size() - STM32MP_DDR_S_SIZE,
+			MT_MEMORY | MT_RW | MT_NS);
+
+	configure_mmu();
+
+	/*
+	 * Copy BL33 entry point information.
+	 * They are stored in Secure RAM, in BL2's address space.
+	 */
+	while (bl_params != NULL) {
+		if (bl_params->image_id == BL33_IMAGE_ID) {
+			bl33_image_ep_info = *bl_params->ep_info;
+			break;
+		}
+
+		bl_params = bl_params->next_params_info;
+	}
+
+	if (dt_open_and_check() < 0) {
+		panic();
+	}
+
+	if (bsec_probe() != 0) {
+		panic();
+	}
+
+	if (stm32mp1_clk_probe() < 0) {
+		panic();
+	}
+
+	/* Initialize uart for console except if it is used by programmer */
+	result = dt_get_stdout_uart_info(&dt_dev_info);
+#if STM32MP_UART_PROGRAMMER
+	stm32_get_boot_interface(&boot_itf, &boot_instance);
+
+	if ((result > 0) && dt_dev_info.status &&
+	    !((boot_itf == BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) &&
+	      (get_uart_address(boot_instance) == dt_dev_info.base))) {
+#else
+	if ((result > 0) && dt_dev_info.status) {
+#endif
+		if (console_stm32_register(dt_dev_info.base, 0,
+					   STM32MP_UART_BAUDRATE, &console) ==
+		    0) {
+			panic();
+		}
+	}
+
+	initialize_pll1_settings();
+
+	stm32mp1_init_lp_states();
+}
+
+/*******************************************************************************
+ * Set security setup in sp_min
+ ******************************************************************************/
+void stm32mp1_sp_min_security_setup(void)
+{
+	uint32_t filter_conf = 0;
+	uint32_t active_conf = 0;
+	int ret;
+
+	if (etzpc_init() != 0) {
+		ERROR("ETZPC configuration issue\n");
+		panic();
+	}
+
+	/* Init rtc driver */
+	ret = stm32_rtc_init();
+	if (ret < 0) {
+		WARN("RTC driver init error %i\n", ret);
+	}
+
+	/*  Init rng driver */
+	ret = stm32_rng_init();
+	if (ret < 0) {
+		WARN("RNG driver init error %i\n", ret);
+	}
+
+	/* Init tamper */
+	if (stm32_tamp_init() > 0) {
+		stm32_tamp_configure_internal(int_tamp, PLAT_MAX_TAMP_INT);
+		stm32_tamp_configure_external(ext_tamp, PLAT_MAX_TAMP_EXT,
+					      filter_conf, active_conf);
+
+		/* Enable timestamp for tamper */
+		stm32_rtc_set_tamper_timestamp();
+	}
+
+	if (stm32_timer_init() == 0) {
+		stm32mp1_calib_init();
+	}
+}
+
+/*******************************************************************************
+ * Initialize the MMU, security and the GIC.
+ ******************************************************************************/
+void sp_min_platform_setup(void)
+{
+	ddr_save_sr_mode();
+
+	/* Initialize tzc400 after DDR initialization */
+	stm32mp1_security_setup();
+
+	generic_delay_timer_init();
+
+	stm32mp1_gic_init();
+
+	/* Update security settings */
+	stm32mp1_sp_min_security_setup();
+
+	if (stm32_iwdg_init() < 0) {
+		panic();
+	}
+
+	configure_wakeup_interrupt();
+
+	stm32mp1_driver_init_late();
+}
+
+void sp_min_plat_arch_setup(void)
+{
+}
+
+void sp_min_plat_runtime_setup(void)
+{
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/services/bsec_svc.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/bsec_svc.c
@@ -0,0 +1,460 @@
+/*
+ * Copyright (c) 2016-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch.h>
+#include <arch_helpers.h>
+#include <assert.h>
+#include <boot_api.h>
+#include <debug.h>
+#include <mmio.h>
+#include <platform_def.h>
+#include <runtime_svc.h>
+#include <std_svc.h>
+#include <stm32mp1_dbgmcu.h>
+#include <stm32mp1_ddr_helpers.h>
+#include <stm32mp1_smc.h>
+
+#include "bsec_svc.h"
+
+#define SSP_OTP_REQ		BIT(BOOT_API_OTP_SSP_REQ_BIT_POS)
+#define SSP_OTP_SUCCESS		BIT(BOOT_API_OTP_SSP_SUCCESS_BIT_POS)
+#define SSP_OTP_MASK		(SSP_OTP_REQ | SSP_OTP_SUCCESS)
+
+enum bsec_ssp_status {
+	BSEC_NO_SSP = 0,
+	BSEC_SSP_SET,
+	BSEC_SSP_ERROR
+};
+
+struct otp_exchange {
+	uint32_t version;
+	uint32_t configuration;
+	uint32_t reserved;
+	uint32_t status;
+	uint32_t general_lock;
+	uint32_t debug_conf;
+	uint32_t reserved1[2];
+	uint32_t otp_disturb[3];
+	uint32_t reserved2[3];
+	uint32_t error_status[3];
+	uint32_t reserved3[3];
+	uint32_t permanent_lock[3];
+	uint32_t reserved4[3];
+	uint32_t programming_lock[3];
+	uint32_t reserved5[3];
+	uint32_t shadow_write_lock[3];
+	uint32_t reserved6[3];
+	uint32_t shadow_read_lock[3];
+	uint32_t reserved7[3];
+	uint32_t otp_value[STM32MP1_OTP_MAX_ID + 1];
+	uint32_t reserved8[112];
+	uint32_t bsec_hw_conf;
+	uint32_t ip_version;
+	uint32_t ip_id;
+	uint32_t ip_magic_id;
+};
+
+static enum bsec_ssp_status bsec_check_ssp(uint32_t otp, uint32_t update)
+{
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)BOOT_PARAM_ADDR;
+
+	/* No SSP update or SSP already done*/
+	if ((((otp & SSP_OTP_MASK) == 0U) && ((update & SSP_OTP_MASK) == 0U)) ||
+	    (((otp & SSP_OTP_MASK) == SSP_OTP_MASK) &&
+	     ((update & SSP_OTP_MASK) == SSP_OTP_MASK))) {
+		return BSEC_NO_SSP;
+	}
+
+	/* SSP update */
+	if ((update & SSP_OTP_MASK) != 0U) {
+		if ((update & SSP_OTP_SUCCESS) != 0U) {
+			return BSEC_SSP_ERROR;
+		}
+
+		/* SSP boot process */
+		boot_context->p_ssp_config->ssp_cmd =
+			BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK;
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)boot_context->p_ssp_config,
+				   sizeof(boot_api_ssp_config_t));
+#endif
+		return BSEC_SSP_SET;
+	}
+	return BSEC_NO_SSP;
+}
+
+#if STM32MP_USB || STM32MP_UART_PROGRAMMER
+static uint32_t bsec_read_all_bsec(struct otp_exchange *exchange)
+{
+	uint32_t i;
+	uint32_t result;
+
+	if (exchange == NULL) {
+		return BSEC_ERROR;
+	}
+
+	exchange->version = BSEC_SERVICE_VERSION;
+
+	for (i = 0U; i <= STM32MP1_OTP_MAX_ID; i++) {
+		if (bsec_check_nsec_access_rights(i) == BSEC_OK) {
+			result = bsec_shadow_register(i);
+			if (result != BSEC_OK) {
+				return result;
+			}
+
+			result = bsec_read_otp(&exchange->otp_value[i], i);
+			if (result != BSEC_OK) {
+				return result;
+			}
+		}
+	}
+
+	exchange->configuration = mmio_read_32(bsec_get_base() +
+					       BSEC_OTP_CONF_OFF);
+
+	exchange->status = mmio_read_32(bsec_get_base() + BSEC_OTP_STATUS_OFF);
+
+	exchange->general_lock = mmio_read_32(bsec_get_base() +
+					      BSEC_OTP_LOCK_OFF);
+
+	exchange->debug_conf = mmio_read_32(bsec_get_base() + BSEC_DEN_OFF);
+
+	exchange->otp_disturb[0] = mmio_read_32(bsec_get_base() +
+						BSEC_DISTURBED_OFF);
+
+	exchange->otp_disturb[1] = mmio_read_32(bsec_get_base() +
+						BSEC_DISTURBED1_OFF);
+
+	exchange->otp_disturb[2] = mmio_read_32(bsec_get_base() +
+						BSEC_DISTURBED2_OFF);
+
+	exchange->error_status[0] = mmio_read_32(bsec_get_base() +
+						 BSEC_ERROR_OFF);
+
+	exchange->error_status[1] = mmio_read_32(bsec_get_base() +
+						 BSEC_ERROR1_OFF);
+
+	exchange->error_status[2] = mmio_read_32(bsec_get_base() +
+						 BSEC_ERROR2_OFF);
+
+	exchange->permanent_lock[0] = mmio_read_32(bsec_get_base() +
+						   BSEC_WRLOCK_OFF);
+
+	exchange->permanent_lock[1] = mmio_read_32(bsec_get_base() +
+						   BSEC_WRLOCK1_OFF);
+
+	exchange->permanent_lock[2] = mmio_read_32(bsec_get_base() +
+						   BSEC_WRLOCK2_OFF);
+
+	exchange->programming_lock[0] = mmio_read_32(bsec_get_base() +
+						     BSEC_SPLOCK_OFF);
+
+	exchange->programming_lock[1] = mmio_read_32(bsec_get_base() +
+						     BSEC_SPLOCK1_OFF);
+
+	exchange->programming_lock[2] = mmio_read_32(bsec_get_base() +
+						     BSEC_SPLOCK2_OFF);
+
+	exchange->shadow_write_lock[0] = mmio_read_32(bsec_get_base() +
+						      BSEC_SWLOCK_OFF);
+
+	exchange->shadow_write_lock[1] = mmio_read_32(bsec_get_base() +
+						      BSEC_SWLOCK1_OFF);
+
+	exchange->shadow_write_lock[2] = mmio_read_32(bsec_get_base() +
+						      BSEC_SWLOCK2_OFF);
+
+	exchange->shadow_read_lock[0] = mmio_read_32(bsec_get_base() +
+						     BSEC_SRLOCK_OFF);
+
+	exchange->shadow_read_lock[1] = mmio_read_32(bsec_get_base() +
+						     BSEC_SRLOCK1_OFF);
+
+	exchange->shadow_read_lock[2] = mmio_read_32(bsec_get_base() +
+						     BSEC_SRLOCK2_OFF);
+
+	exchange->bsec_hw_conf = mmio_read_32(bsec_get_base() +
+					      BSEC_IPHW_CFG_OFF);
+
+	exchange->ip_version = mmio_read_32(bsec_get_base() + BSEC_IPVR_OFF);
+
+	exchange->ip_id = mmio_read_32(bsec_get_base() + BSEC_IP_ID_OFF);
+
+	exchange->ip_magic_id = mmio_read_32(bsec_get_base() +
+					     BSEC_IP_MAGIC_ID_OFF);
+
+	return BSEC_OK;
+}
+
+static uint32_t bsec_write_all_bsec(struct otp_exchange *exchange,
+				    uint32_t *ret_otp_value)
+{
+	uint32_t i;
+	uint32_t j;
+	uint32_t start_otp = 0U;
+	uint32_t value = 0U;
+	uint32_t ret;
+	struct bsec_config config_param;
+
+	*ret_otp_value = 0U;
+
+	if (exchange == NULL) {
+		return BSEC_ERROR;
+	}
+
+	if (exchange->version != BSEC_SERVICE_VERSION) {
+		return BSEC_ERROR;
+	}
+
+	for (i = start_otp; i <= STM32MP1_OTP_MAX_ID; i++) {
+		if (bsec_check_nsec_access_rights(i) != BSEC_OK) {
+			continue;
+		}
+
+		ret = bsec_shadow_register(i);
+		if (ret != BSEC_OK) {
+			return ret;
+		}
+
+		ret = bsec_read_otp(&value, i);
+		if (ret != BSEC_OK) {
+			return ret;
+		}
+
+		if ((value ==  exchange->otp_value[i]) &&
+		    (i != BOOT_API_OTP_SSP_WORD_NB)) {
+			continue;
+		}
+
+		if (i == BOOT_API_OTP_SSP_WORD_NB) {
+			*ret_otp_value = (uint32_t)bsec_check_ssp(value,
+							exchange->otp_value[i]);
+			VERBOSE("Result OTP SSP %d\n", *ret_otp_value);
+			if (*ret_otp_value == (uint32_t)BSEC_SSP_ERROR) {
+				continue;
+			}
+		}
+
+		ret = bsec_program_otp(exchange->otp_value[i], i);
+		if (ret != BSEC_OK) {
+			return ret;
+		}
+
+		ret = bsec_write_otp(exchange->otp_value[i], i);
+		if (ret != BSEC_OK) {
+			return ret;
+		}
+	}
+
+	ret = bsec_write_debug_conf(exchange->debug_conf);
+	if (ret != BSEC_OK) {
+		return ret;
+	}
+
+	for (j = 0U; j < 3U; j++) {
+		if (exchange->permanent_lock[j] == 0U) {
+			continue;
+		}
+
+		for (i = 0U; i < 32U; i++) {
+			if (bsec_check_nsec_access_rights((32U * j) + i) !=
+			    BSEC_OK) {
+				continue;
+			}
+
+			value = (exchange->permanent_lock[j] >> i) & 1U;
+			if (value != 0U) {
+				ret = bsec_permanent_lock_otp((32U * j) + i);
+				if (ret != BSEC_OK) {
+					return ret;
+				}
+			}
+		}
+	}
+
+	for (j = 0U; j < 3U; j++) {
+		if (exchange->programming_lock[j] == 0U) {
+			continue;
+		}
+
+		for (i = 0U; i < 32U; i++) {
+			if (bsec_check_nsec_access_rights((32U * j) + i) !=
+			    BSEC_OK) {
+				continue;
+			}
+
+			value = (exchange->programming_lock[j] >> i) & 1U;
+			if (value != 0U) {
+				if (bsec_set_sp_lock((32U * j) + i) !=
+				    BSEC_OK) {
+					return BSEC_ERROR;
+				}
+			}
+		}
+	}
+
+	for (j = 0U; j < 3U; j++) {
+		if (exchange->shadow_write_lock[j] == 0U) {
+			continue;
+		}
+
+		for (i = 0U; i < 32U; i++) {
+			if (bsec_check_nsec_access_rights((32U * j) + i) !=
+			    BSEC_OK) {
+				continue;
+			}
+
+			value = (exchange->shadow_write_lock[j] >> i) & 1U;
+			if (value != 0U) {
+				if (bsec_set_sw_lock((32U * j) + i) !=
+				    BSEC_OK) {
+					return BSEC_ERROR;
+				}
+			}
+		}
+	}
+
+	for (j = 0U; j < 3U; j++) {
+		if (exchange->shadow_read_lock[j] == 0U) {
+			continue;
+		}
+
+		for (i = 0U; i < 32U; i++) {
+			if (bsec_check_nsec_access_rights((32U * j) + i) !=
+			    BSEC_OK) {
+				continue;
+			}
+
+			value = (exchange->shadow_read_lock[j] >> i) & 1U;
+			if (value != 0U) {
+				if (bsec_set_sr_lock((32U * j) + i) !=
+				    BSEC_OK) {
+					return BSEC_ERROR;
+				}
+			}
+		}
+	}
+
+	ret = bsec_get_config(&config_param);
+	if (ret != BSEC_OK) {
+		return ret;
+	}
+
+	config_param.power =
+		(uint8_t)(exchange->configuration & BSEC_CONF_POWER_UP_MASK) >>
+		BSEC_CONF_POWER_UP_SHIFT;
+	config_param.freq =
+		(uint8_t)(exchange->configuration & BSEC_CONF_FRQ_MASK) >>
+		BSEC_CONF_FRQ_SHIFT;
+	config_param.pulse_width =
+		(uint8_t)(exchange->configuration & BSEC_CONF_PRG_WIDTH_MASK) >>
+		BSEC_CONF_PRG_WIDTH_SHIFT;
+	config_param.tread =
+		(uint8_t)((exchange->configuration & BSEC_CONF_TREAD_MASK) >>
+		BSEC_CONF_TREAD_SHIFT);
+	config_param.den_lock =
+		(uint8_t)(exchange->general_lock & DENREG_LOCK_MASK) >>
+		DENREG_LOCK_SHIFT;
+	config_param.prog_lock =
+		(uint8_t)(exchange->general_lock & GPLOCK_LOCK_MASK) >>
+		GPLOCK_LOCK_SHIFT;
+
+	config_param.upper_otp_lock =
+		(uint8_t)(exchange->general_lock & UPPER_OTP_LOCK_MASK) >>
+		 UPPER_OTP_LOCK_SHIFT;
+
+	ret = bsec_set_config(&config_param);
+	if (ret != BSEC_OK) {
+		return ret;
+	}
+
+	INFO("write all otp succeed\n");
+
+	return BSEC_OK;
+}
+#endif /* STM32MP_USB || STM32MP_UART_PROGRAMMER */
+
+uint32_t bsec_main(uint32_t x1, uint32_t x2, uint32_t x3,
+		   uint32_t *ret_otp_value)
+{
+	uint32_t result;
+	uint32_t tmp_data = 0U;
+
+	if ((x1 != STM32_SMC_READ_ALL) && (x1 != STM32_SMC_WRITE_ALL) &&
+	    (bsec_check_nsec_access_rights(x2) != BSEC_OK)) {
+		return STM32_SMC_INVALID_PARAMS;
+	}
+
+#if STM32MP_USB || STM32MP_UART_PROGRAMMER
+	if (((x1 == STM32_SMC_READ_ALL) || (x1 == STM32_SMC_WRITE_ALL)) &&
+	    (!ddr_is_nonsecured_area((uintptr_t)x2,
+				     sizeof(struct otp_exchange)))) {
+		return STM32_SMC_INVALID_PARAMS;
+	}
+#endif
+
+	switch (x1) {
+	case STM32_SMC_READ_SHADOW:
+		result = bsec_read_otp(ret_otp_value, x2);
+		break;
+	case STM32_SMC_PROG_OTP:
+		*ret_otp_value = 0U;
+		if (x2 == BOOT_API_OTP_SSP_WORD_NB) {
+			result = bsec_read_otp(&tmp_data, x2);
+			if (result != BSEC_OK) {
+				break;
+			}
+
+			*ret_otp_value = (uint32_t)bsec_check_ssp(tmp_data, x3);
+			if (*ret_otp_value == (uint32_t)BSEC_SSP_ERROR) {
+				result = BSEC_OK;
+				break;
+			}
+		}
+		result = bsec_program_otp(x3, x2);
+		break;
+	case STM32_SMC_WRITE_SHADOW:
+		*ret_otp_value = 0;
+		result = bsec_write_otp(x3, x2);
+		break;
+	case STM32_SMC_READ_OTP:
+		*ret_otp_value = 0;
+		result = bsec_read_otp(&tmp_data, x2);
+		if (result != BSEC_OK) {
+			break;
+		}
+
+		result = bsec_shadow_register(x2);
+		if (result != BSEC_OK) {
+			break;
+		}
+
+		result = bsec_read_otp(ret_otp_value, x2);
+		if (result != BSEC_OK) {
+			break;
+		}
+
+		result = bsec_write_otp(tmp_data, x2);
+		break;
+#if STM32MP_USB || STM32MP_UART_PROGRAMMER
+	case STM32_SMC_READ_ALL:
+		result = bsec_read_all_bsec((struct otp_exchange *)x2);
+		break;
+	case STM32_SMC_WRITE_ALL:
+		result = bsec_write_all_bsec((struct otp_exchange *)x2,
+					     ret_otp_value);
+		break;
+#endif
+	case STM32_SMC_WRLOCK_OTP:
+		result = bsec_permanent_lock_otp(x2);
+		break;
+	default:
+		return STM32_SMC_INVALID_PARAMS;
+	}
+
+	return (result == BSEC_OK) ? STM32_SMC_OK : STM32_SMC_FAILED;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/services/bsec_svc.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/bsec_svc.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2016-2017, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BSEC_SVC_H
+#define BSEC_SVC_H
+
+#include <arch.h>
+#include <bl_common.h>
+#include <bsec.h>
+
+/* version of this service */
+/* must be increase at each structure modification */
+#define BSEC_SERVICE_VERSION		0x01U
+
+uint32_t bsec_main(uint32_t x1, uint32_t x2, uint32_t x3,
+		   uint32_t *ret_otp_value);
+
+#endif /* BSEC_SVC_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/services/low_power_svc.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/low_power_svc.c
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <smccc_helpers.h>
+#include <stm32mp1_power_config.h>
+#include <stm32mp1_smc.h>
+#include "low_power_svc.h"
+
+uint32_t pm_domain_scv_handler(uint32_t x1, uint32_t x2)
+{
+	if (stm32mp1_set_pm_domain_state((enum stm32mp1_pm_domain)x1,
+					 (bool)x2) < 0) {
+		return STM32_SMC_FAILED;
+	}
+
+	return STM32_SMC_OK;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/services/low_power_svc.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/low_power_svc.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef LOW_POWER_SVC_H
+#define LOW_POWER_SVC_H
+
+#include <stdint.h>
+
+uint32_t pm_domain_scv_handler(uint32_t x1, uint32_t x2);
+
+#endif /* LOW_POWER_SVC_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/services/pwr_svc.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/pwr_svc.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2017-2018, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2018 ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <debug.h>
+#include <mmio.h>
+#include <platform_def.h>
+#include <spinlock.h>
+#include <stm32mp_common.h>
+#include <stm32mp1_pwr.h>
+#include <stm32mp1_smc.h>
+#include "pwr_svc.h"
+
+static struct spinlock lock;
+
+void pwr_regs_lock(void)
+{
+	const uint32_t mask = SCTLR_M_BIT | SCTLR_C_BIT;
+
+	/* Lock is currently required only when MMU and cache are enabled */
+	if ((read_sctlr() & mask) == mask) {
+		spin_lock(&lock);
+	}
+}
+
+void pwr_regs_unlock(void)
+{
+	const uint32_t mask = SCTLR_M_BIT | SCTLR_C_BIT;
+
+	/* Unlock is required only when MMU and cache are enabled */
+	if ((read_sctlr() & mask) == mask) {
+		spin_unlock(&lock);
+	}
+}
+
+static void access_allowed_mask(uint32_t request, uint32_t offset,
+				uint32_t value, uint32_t allowed_mask)
+{
+	uint32_t addr = stm32mp_pwr_base() + offset;
+	uint32_t masked_value = value & allowed_mask;
+
+	pwr_regs_lock();
+
+	switch (request) {
+	case STM32_SMC_REG_WRITE:
+		mmio_clrsetbits_32(addr, allowed_mask, masked_value);
+		VERBOSE("wrt 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_SET:
+		mmio_setbits_32(addr, masked_value);
+		VERBOSE("set 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_CLEAR:
+		mmio_clrbits_32(addr, masked_value);
+		VERBOSE("clear 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	default:
+		break;
+	}
+
+	pwr_regs_unlock();
+}
+
+static void raw_allowed_access_request(uint32_t request,
+				       uint32_t offset, uint32_t value)
+{
+	uint32_t allowed_mask = 0;
+
+	switch (offset) {
+	case PWR_CR3:
+		allowed_mask |= PWR_CR3_VBE | PWR_CR3_VBRS | PWR_CR3_USB33DEN |
+				PWR_CR3_REG18EN | PWR_CR3_REG11EN;
+		break;
+
+	case PWR_WKUPCR:
+		allowed_mask |= PWR_WKUPCR_MASK;
+		break;
+
+	case PWR_MPUWKUPENR:
+		allowed_mask |= PWR_MPUWKUPENR_MASK;
+		break;
+
+	default:
+		return;
+	}
+
+	if (allowed_mask != 0U) {
+		access_allowed_mask(request, offset, value, allowed_mask);
+	}
+}
+
+uint32_t pwr_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3)
+{
+	uint32_t request = x1;
+	uint32_t offset = x2;
+	uint32_t value = x3;
+
+	/*
+	 * x2 may be either the PWR register offset or the register
+	 * full physical address.
+	 */
+	if ((offset & ~PWR_OFFSET_MASK) != 0) {
+		if ((offset & ~PWR_OFFSET_MASK) != stm32mp_pwr_base()) {
+			return STM32_SMC_INVALID_PARAMS;
+		}
+
+		offset &= PWR_OFFSET_MASK;
+	}
+
+	/* PWR controls for non secure resource may be accessed straight */
+	raw_allowed_access_request(request, offset, value);
+
+	return STM32_SMC_OK;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/services/pwr_svc.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/pwr_svc.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2017, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PWR_SVC_H
+#define PWR_SVC_H
+
+uint32_t pwr_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3);
+
+#endif /* PWR_SVC_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/services/rcc_svc.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/rcc_svc.c
@@ -0,0 +1,507 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <debug.h>
+#include <limits.h>
+#include <mmio.h>
+#include <platform_def.h>
+#include <stm32_gpio.h>
+#include <stm32mp_common.h>
+#include <stm32mp_shres_helpers.h>
+#include <stm32mp1_clk.h>
+#include <stm32mp1_rcc.h>
+#include <stm32mp1_shared_resources.h>
+#include <stm32mp1_smc.h>
+#include "rcc_svc.h"
+
+#define STD_REG			0
+#define SET_REG			1
+#define CLR_REG			2
+
+static void shared_clk_request(uint32_t request,
+			       uint32_t offset, uint32_t value)
+{
+	unsigned long id;
+	unsigned int bit;
+	uint32_t enable_bits = 0;
+	int clr_std_set = STD_REG;
+
+	switch (request) {
+	case STM32_SMC_REG_WRITE:
+	case STM32_SMC_REG_SET:
+	case STM32_SMC_REG_CLEAR:
+		break;
+	default:
+		return;
+	}
+
+	switch (offset) {
+	case RCC_MP_APB5ENSETR:
+		clr_std_set = SET_REG;
+		/* Non secure backup registers requires RTCAPB clock */
+		enable_bits |= RCC_MP_APB5ENSETR_RTCAPBEN;
+		break;
+	case RCC_MP_APB5ENCLRR:
+		clr_std_set = CLR_REG;
+		/* Non secure backup registers requires RTCAPB clock */
+		enable_bits |= RCC_MP_APB5ENSETR_RTCAPBEN;
+		break;
+
+	case RCC_MP_AHB5ENSETR:
+		clr_std_set = SET_REG;
+		if (stm32mp_gpio_bank_is_shared(GPIO_BANK_Z)) {
+			enable_bits |= RCC_MP_AHB5ENSETR_GPIOZEN;
+		}
+		break;
+	case RCC_MP_AHB5ENCLRR:
+		clr_std_set = CLR_REG;
+		if (stm32mp_gpio_bank_is_shared(GPIO_BANK_Z)) {
+			enable_bits |= RCC_MP_AHB5ENSETR_GPIOZEN;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if ((clr_std_set != STD_REG) && (request == STM32_SMC_REG_CLEAR)) {
+		return;
+	}
+
+	/*
+	 * Parse bit that relate to a functional clock.
+	 * Call stm32mp1_clk_enable/disable_non_secure() for that clock
+	 * according to request (write/set/clear) and target register
+	 * (write or set/clear).
+	 */
+	for (bit = 0; bit < __WORD_BIT; bit++) {
+
+		if ((BIT(bit) & enable_bits) == 0U) {
+			continue;
+		}
+
+		id = stm32mp1_clk_rcc2id(offset, bit);
+		if (id == ~0U) {
+			panic();
+		}
+
+		switch (clr_std_set) {
+		case SET_REG:
+			if ((BIT(bit) & value) != 0U) {
+				stm32mp1_clk_enable_non_secure(id);
+			}
+			break;
+		case CLR_REG:
+			if ((BIT(bit) & value) != 0U) {
+				stm32mp1_clk_disable_non_secure(id);
+			}
+			break;
+		default:
+			/* Standard registers case */
+			switch (request) {
+			case STM32_SMC_REG_WRITE:
+				if ((BIT(bit) & value) != 0U) {
+					stm32mp1_clk_enable_non_secure(id);
+				} else {
+					stm32mp1_clk_disable_non_secure(id);
+				}
+				break;
+			case STM32_SMC_REG_SET:
+				if ((BIT(bit) & value) != 0U) {
+					stm32mp1_clk_enable_non_secure(id);
+				}
+				break;
+			case STM32_SMC_REG_CLEAR:
+				if ((BIT(bit) & value) != 0U) {
+					stm32mp1_clk_disable_non_secure(id);
+				}
+				break;
+			default:
+				return;
+			}
+			break;
+		}
+
+		enable_bits &= ~BIT(bit);
+		if (enable_bits == 0U) {
+			break;
+		}
+	}
+}
+
+static void access_allowed_mask(uint32_t request, uint32_t offset,
+				uint32_t value, uint32_t allowed_mask)
+{
+	uint32_t addr = stm32mp_rcc_base() + offset;
+	uint32_t masked_value = value & allowed_mask;
+
+	switch (request) {
+	case STM32_SMC_REG_WRITE:
+		switch (offset) {
+		/* CLR registers show the SET state, not the CLR state */
+		case RCC_OCENCLRR:
+		case RCC_MP_SREQCLRR:
+		case RCC_APB5RSTCLRR:
+		case RCC_AHB5RSTCLRR:
+		case RCC_MP_APB5ENCLRR:
+		case RCC_MP_AHB5ENCLRR:
+		case RCC_MP_APB5LPENCLRR:
+		case RCC_MP_AHB5LPENCLRR:
+		case RCC_MP_IWDGFZCLRR:
+			mmio_write_32(addr, masked_value);
+			break;
+		default:
+			stm32mp_mmio_clrsetbits_32_shregs(addr, allowed_mask,
+							  masked_value);
+			break;
+		}
+		VERBOSE("wrt 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_SET:
+		switch (offset) {
+		/* CLR registers show the SET state, not the CLR state */
+		case RCC_OCENCLRR:
+		case RCC_MP_SREQCLRR:
+		case RCC_APB5RSTCLRR:
+		case RCC_AHB5RSTCLRR:
+		case RCC_MP_APB5ENCLRR:
+		case RCC_MP_AHB5ENCLRR:
+		case RCC_MP_APB5LPENCLRR:
+		case RCC_MP_AHB5LPENCLRR:
+		case RCC_MP_IWDGFZCLRR:
+			mmio_write_32(addr, masked_value);
+			break;
+		default:
+			stm32mp_mmio_setbits_32_shregs(addr, masked_value);
+			break;
+		}
+		VERBOSE("set 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	case STM32_SMC_REG_CLEAR:
+		switch (offset) {
+		case RCC_OCENCLRR:
+		case RCC_MP_SREQCLRR:
+		case RCC_APB5RSTCLRR:
+		case RCC_AHB5RSTCLRR:
+		case RCC_MP_APB5ENCLRR:
+		case RCC_MP_AHB5ENCLRR:
+		case RCC_MP_APB5LPENCLRR:
+		case RCC_MP_AHB5LPENCLRR:
+		case RCC_MP_IWDGFZCLRR:
+			/* Nothing to do on CLR registers */
+			break;
+		default:
+			stm32mp_mmio_clrbits_32_shregs(addr, masked_value);
+			break;
+		}
+		VERBOSE("clear 0x%x = 0x%x => 0x%x\n", offset, value,
+			mmio_read_32(addr));
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void raw_allowed_access_request(uint32_t request,
+				       uint32_t offset, uint32_t value)
+{
+	uint32_t allowed_mask = 0;
+
+	/* Use UINT32_MAX if no secure restriction on register access */
+	switch (offset) {
+	case RCC_OCENSETR:
+	case RCC_OCENCLRR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_HSI)) {
+			allowed_mask |= RCC_OCENR_HSION | RCC_OCENR_HSIKERON;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_CSI)) {
+			allowed_mask |= RCC_OCENR_CSION | RCC_OCENR_CSIKERON;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_HSE)) {
+			allowed_mask |= RCC_OCENR_HSEON | RCC_OCENR_HSEKERON |
+					RCC_OCENR_HSEBYP | RCC_OCENR_HSECSSON |
+					RCC_OCENR_DIGBYP;
+		}
+		break;
+
+	case RCC_HSICFGR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_HSI)) {
+			allowed_mask = UINT32_MAX;
+		}
+		break;
+
+	case RCC_CSICFGR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_CSI)) {
+			allowed_mask = UINT32_MAX;
+		}
+		break;
+
+	case RCC_MP_CIER:
+	case RCC_MP_CIFR:
+		/* RCC_MP_CIFR_xxxRDYF matches CIER and CIFR bit mapping */
+		allowed_mask |= RCC_MP_CIFR_WKUPF | RCC_MP_CIFR_PLL4DYF;
+
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_LSI)) {
+			allowed_mask |= RCC_MP_CIFR_LSIRDYF;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_LSE)) {
+			allowed_mask |= RCC_MP_CIFR_LSERDYF;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_HSI)) {
+			allowed_mask |= RCC_MP_CIFR_HSIRDYF;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_HSE)) {
+			allowed_mask |= RCC_MP_CIFR_HSERDYF;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_CSI)) {
+			allowed_mask |= RCC_MP_CIFR_CSIRDYF;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL1)) {
+			allowed_mask |= RCC_MP_CIFR_PLL1DYF;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL2)) {
+			allowed_mask |= RCC_MP_CIFR_PLL2DYF;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL3)) {
+			allowed_mask |= RCC_MP_CIFR_PLL3DYF;
+		}
+		break;
+
+	case RCC_PLL1CR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL1_P)) {
+			allowed_mask |= RCC_PLLNCR_DIVPEN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL1_Q)) {
+			allowed_mask |= RCC_PLLNCR_DIVQEN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL1_R)) {
+			allowed_mask |= RCC_PLLNCR_DIVREN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL1)) {
+			allowed_mask |= RCC_PLLNCR_PLLON | RCC_PLLNCR_PLLRDY |
+					RCC_PLLNCR_SSCG_CTRL;
+		}
+		break;
+
+	case RCC_PLL2CR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL2_P)) {
+			allowed_mask |= RCC_PLLNCR_DIVPEN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL2_Q)) {
+			allowed_mask |= RCC_PLLNCR_DIVQEN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL2_R)) {
+			allowed_mask |= RCC_PLLNCR_DIVREN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL2)) {
+			allowed_mask |= RCC_PLLNCR_PLLON | RCC_PLLNCR_PLLRDY |
+					RCC_PLLNCR_SSCG_CTRL;
+		}
+		break;
+
+	case RCC_PLL3CR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL3_P)) {
+			allowed_mask |= RCC_PLLNCR_DIVPEN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL3_Q)) {
+			allowed_mask |= RCC_PLLNCR_DIVQEN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL3_R)) {
+			allowed_mask |= RCC_PLLNCR_DIVREN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_PLL3)) {
+			allowed_mask |= RCC_PLLNCR_PLLON | RCC_PLLNCR_PLLRDY |
+					RCC_PLLNCR_SSCG_CTRL;
+		}
+		break;
+
+	case RCC_MP_BOOTCR:		/* Allowed MPU/MCU reboot cfg */
+	case RCC_MP_GCR:		/* Allowed MPU/MCU reboot cfg */
+	case RCC_MP_GRSTCSETR:		/* Allowed MCU and system reset */
+	case RCC_BR_RSTSCLRR:		/* Allowed system reset status */
+	case RCC_MC_RSTSCLRR:		/* Allowed system reset status */
+	case RCC_MP_RSTSCLRR:		/* Allowed system reset status */
+		allowed_mask = UINT32_MAX;
+		break;
+	case RCC_APB5RSTSETR:
+	case RCC_APB5RSTCLRR:
+	case RCC_MP_APB5ENSETR:
+	case RCC_MP_APB5ENCLRR:
+	case RCC_MP_APB5LPENSETR:
+	case RCC_MP_APB5LPENCLRR:
+		/*
+		 * SPI6/I2C4/I2C6/USART1/IWDG1 resources may be non secure.
+		 * TZPC/TZC/BSEC/STGEN resources are secure only.
+		 * Bit mask RCC_MP_APB5ENSETR_xxxEN fits EN, RST and LPEN.
+		 */
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_SPI6)) {
+			allowed_mask |= RCC_MP_APB5ENSETR_SPI6EN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_I2C4)) {
+			allowed_mask |= RCC_MP_APB5ENSETR_I2C4EN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_I2C6)) {
+			allowed_mask |= RCC_MP_APB5ENSETR_I2C6EN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_USART1)) {
+			allowed_mask |= RCC_MP_APB5ENSETR_USART1EN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_IWDG1)) {
+			allowed_mask |= RCC_MP_APB5ENSETR_IWDG1APBEN;
+		}
+		break;
+	case RCC_AHB5RSTSETR:
+	case RCC_AHB5RSTCLRR:
+	case RCC_MP_AHB5ENSETR:
+	case RCC_MP_AHB5ENCLRR:
+	case RCC_MP_AHB5LPENSETR:
+	case RCC_MP_AHB5LPENCLRR:
+		/*
+		 * RNG1/HASH1/CRYP1/GPIOZ resources are accessible if
+		 * related BKPSRAM resources are reserved to secure services.
+		 * Bit mask RCC_MP_AHB5ENSETR_xxxEN fits EN, RST and LPEN.
+		 */
+		if (stm32mp_gpio_bank_is_non_secure(GPIO_BANK_Z)) {
+			allowed_mask |= RCC_MP_AHB5ENSETR_GPIOZEN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_CRYP1)) {
+			allowed_mask |= RCC_MP_AHB5ENSETR_CRYP1EN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_HASH1)) {
+			allowed_mask |= RCC_MP_AHB5ENSETR_HASH1EN;
+		}
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_RNG1)) {
+			allowed_mask |= RCC_MP_AHB5ENSETR_RNG1EN;
+		}
+		break;
+	case RCC_RTCDIVR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_RTC)) {
+			allowed_mask = UINT32_MAX;
+		}
+		break;
+	case RCC_I2C46CKSELR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_I2C4) &&
+		    stm32mp1_periph_is_non_secure(STM32MP1_SHRES_I2C6)) {
+			allowed_mask = UINT32_MAX;
+		}
+		break;
+	case RCC_SPI6CKSELR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_SPI6)) {
+			allowed_mask = UINT32_MAX;
+		}
+		break;
+	case RCC_UART1CKSELR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_USART1)) {
+			allowed_mask = UINT32_MAX;
+		}
+		break;
+	case RCC_RNG1CKSELR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_RNG1)) {
+			allowed_mask = UINT32_MAX;
+		}
+		break;
+	case RCC_MP_IWDGFZSETR:
+	case RCC_MP_IWDGFZCLRR:
+		if (stm32mp1_periph_is_non_secure(STM32MP1_SHRES_IWDG1)) {
+			allowed_mask |= RCC_MP_IWDGFZSETR_IWDG1;
+		}
+		allowed_mask |= RCC_MP_IWDGFZSETR_IWDG2;
+		break;
+	default:
+		return;
+	}
+
+	if (allowed_mask != 0U) {
+		access_allowed_mask(request, offset, value, allowed_mask);
+	}
+}
+
+uint32_t rcc_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3)
+{
+	uint32_t request = x1;
+	uint32_t offset = x2;
+	uint32_t value = x3;
+
+	/*
+	 * x2 may be either the RCC register offset or the register
+	 * full physical address.
+	 */
+	if ((offset & ~RCC_OFFSET_MASK) != 0) {
+		if ((offset & ~RCC_OFFSET_MASK) != stm32mp_rcc_base()) {
+			return STM32_SMC_INVALID_PARAMS;
+		}
+
+		offset &= RCC_OFFSET_MASK;
+	}
+
+	/* Some clocks may be managed by some secure services */
+	shared_clk_request(request, offset, value);
+
+	/* RCC controls for non secure resource may be accessed straight */
+	raw_allowed_access_request(request, offset, value);
+
+	return STM32_SMC_OK;
+}
+
+uint32_t rcc_cal_scv_handler(uint32_t x1)
+{
+	uint32_t ret = STM32_SMC_FAILED;
+
+	switch (x1) {
+	case CK_CSI:
+		if (stm32mp1_calib_start_csi_cal() ==  0) {
+			ret = STM32_SMC_OK;
+		}
+		break;
+
+	case CK_HSI:
+		if (stm32mp1_calib_start_hsi_cal() == 0) {
+			ret = STM32_SMC_OK;
+		}
+		break;
+
+	default:
+		ret = STM32_SMC_INVALID_PARAMS;
+		break;
+	}
+
+	return ret;
+}
+
+uint32_t rcc_opp_scv_handler(uint32_t x1, uint32_t x2, uint32_t *res)
+{
+	uint32_t cmd = x1;
+	uint32_t opp = x2 / 1000U; /* KHz */
+
+	switch (cmd) {
+	case STM32_SMC_RCC_OPP_SET:
+		if (stm32mp1_set_opp_khz(opp) != 0) {
+			return STM32_SMC_FAILED;
+		}
+		break;
+
+	case STM32_SMC_RCC_OPP_ROUND:
+		if (stm32mp1_round_opp_khz(&opp) != 0) {
+			return STM32_SMC_FAILED;
+		}
+
+		if (opp > (UINT32_MAX / 1000U)) {
+			return STM32_SMC_FAILED;
+		}
+
+		*res = opp * 1000U;
+		break;
+
+	default:
+		return STM32_SMC_INVALID_PARAMS;
+	}
+
+	return STM32_SMC_OK;
+}
Index: arm-trusted-firmware.git/plat/karo/txmp/services/rcc_svc.h
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/rcc_svc.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2017-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef RCC_SVC_H
+#define RCC_SVC_H
+
+uint32_t rcc_scv_handler(uint32_t x1, uint32_t x2, uint32_t x3);
+uint32_t rcc_cal_scv_handler(uint32_t x1);
+uint32_t rcc_opp_scv_handler(uint32_t x1, uint32_t x2, uint32_t *res);
+
+#endif /* RCC_SVC_H */
Index: arm-trusted-firmware.git/plat/karo/txmp/services/stm32mp1_svc_setup.c
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/services/stm32mp1_svc_setup.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2014-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <debug.h>
+#include <psci.h>
+#include <runtime_svc.h>
+#include <stm32mp1_smc.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <uuid.h>
+#include "bsec_svc.h"
+#include "low_power_svc.h"
+#include "pwr_svc.h"
+#include "rcc_svc.h"
+
+/* STM32 SiP Service UUID */
+DEFINE_SVC_UUID2(stm32_sip_svc_uid,
+		 0xa778aa50, 0xf49b, 0x144a, 0x8a, 0x5e,
+		 0x26, 0x4d, 0x59, 0x94, 0xc2, 0x14);
+
+/* Setup STM32MP1 Standard Services */
+static int32_t stm32mp1_svc_setup(void)
+{
+	/*
+	 * PSCI is the only specification implemented as a Standard Service.
+	 * Invoke PSCI setup from here.
+	 */
+	return 0;
+}
+
+/*
+ * Top-level Standard Service SMC handler. This handler will in turn dispatch
+ * calls to PSCI SMC handler.
+ */
+static uintptr_t stm32mp1_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+					  u_register_t x2, u_register_t x3,
+					  u_register_t x4, void *cookie,
+					  void *handle, u_register_t flags)
+{
+	uint32_t ret1 = 0U, ret2 = 0U;
+	bool ret_uid = false, ret2_enabled = false;
+
+	switch (smc_fid) {
+	case STM32_SIP_SVC_CALL_COUNT:
+		ret1 = STM32_COMMON_SIP_NUM_CALLS;
+		break;
+
+	case STM32_SIP_SVC_UID:
+		/* Return UUID to the caller */
+		ret_uid = true;
+		break;
+
+	case STM32_SIP_SVC_VERSION:
+		/* Return the version of current implementation */
+		ret1 = STM32_SIP_SVC_VERSION_MAJOR;
+		ret2 = STM32_SIP_SVC_VERSION_MINOR;
+		ret2_enabled = true;
+		break;
+
+	case STM32_SMC_BSEC:
+		ret1 = bsec_main(x1, x2, x3, &ret2);
+		ret2_enabled = true;
+		break;
+
+	case STM32_SMC_RCC:
+		ret1 = rcc_scv_handler(x1, x2, x3);
+		break;
+
+	case STM32_SMC_RCC_CAL:
+		ret1 = rcc_cal_scv_handler(x1);
+		break;
+
+	case STM32_SMC_RCC_OPP:
+		ret1 = rcc_opp_scv_handler(x1, x2, &ret2);
+		ret2_enabled = true;
+		break;
+
+	case STM32_SMC_PWR:
+		ret1 = pwr_scv_handler(x1, x2, x3);
+		break;
+
+	case STM32_SMC_PD_DOMAIN:
+		ret1 = pm_domain_scv_handler(x1, x2);
+		break;
+
+	default:
+		WARN("Unimplemented STM32MP1 Service Call: 0x%x\n", smc_fid);
+		ret1 = STM32_SMC_NOT_SUPPORTED;
+		break;
+	}
+
+	if (ret_uid) {
+		SMC_UUID_RET(handle, stm32_sip_svc_uid);
+	}
+
+	if (ret2_enabled) {
+		SMC_RET2(handle, ret1, ret2);
+	}
+
+	SMC_RET1(handle, ret1);
+}
+
+/* Register Standard Service Calls as runtime service */
+DECLARE_RT_SVC(stm32mp1_sip_svc,
+	       OEN_SIP_START,
+	       OEN_SIP_END,
+	       SMC_TYPE_FAST,
+	       stm32mp1_svc_setup,
+	       stm32mp1_svc_smc_handler
+);
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1.S
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1.S
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) 2016-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifdef BL32_BIN_PATH
+.section .bl32_image
+.incbin BL32_BIN_PATH
+#endif
+
+.section .bl2_image
+.incbin BL2_BIN_PATH
+
+.section .dtb_image
+.incbin DTB_BIN_PATH
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1.ld.S
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1.ld.S
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2015-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_LD_S
+#define STM32MP1_LD_S
+
+#include <platform_def.h>
+#include <xlat_tables_defs.h>
+
+OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
+OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+
+ENTRY(__BL2_IMAGE_START__)
+
+MEMORY {
+	HEADER (rw) : ORIGIN = 0x00000000, LENGTH = 0x3000
+	RAM (rwx) : ORIGIN = STM32MP_BINARY_BASE, LENGTH = STM32MP_BINARY_SIZE
+}
+
+SECTIONS
+{
+    /*
+     * TF mapping must conform to ROM code specification.
+     */
+    .header : {
+        __HEADER_START__ = .;
+        KEEP(*(.header))
+        . = ALIGN(4);
+        __HEADER_END__ = .;
+    } >HEADER
+
+    . = STM32MP_BINARY_BASE;
+    .data . : {
+        . = ALIGN(PAGE_SIZE);
+        __DATA_START__ = .;
+        *(.data*)
+
+        /*
+         * dtb.
+         * The strongest and only alignment contraint is MMU 4K page.
+         * Indeed as images below will be removed, 4K pages will be re-used.
+         */
+        . = ( STM32MP_DTB_BASE - STM32MP_BINARY_BASE );
+        __DTB_IMAGE_START__ = .;
+        *(.dtb_image*)
+        __DTB_IMAGE_END__ = .;
+
+        /*
+         * bl2.
+         * The strongest and only alignment contraint is MMU 4K page.
+         * Indeed as images below will be removed, 4K pages will be re-used.
+         */
+        . = ( STM32MP_BL2_BASE - STM32MP_BINARY_BASE );
+        __BL2_IMAGE_START__ = .;
+        *(.bl2_image*)
+        __BL2_IMAGE_END__ = .;
+
+#ifndef AARCH32_SP_OPTEE
+        /*
+         * bl32 will be settled by bl2.
+         * The strongest and only alignment constraint is 8 words to simplify
+         * memraise8 assembly code.
+         */
+        . = ( STM32MP_BL32_BASE - STM32MP_BINARY_BASE );
+        __BL32_IMAGE_START__ = .;
+        *(.bl32_image*)
+        __BL32_IMAGE_END__ = .;
+#endif
+
+        __DATA_END__ = .;
+    } >RAM
+
+    __TF_END__ = .;
+
+}
+#endif /* STM32MP1_LD_S */
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_helper.S
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_helper.S
@@ -0,0 +1,384 @@
+/*
+ * Copyright (c) 2015-2020, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <bl_common.h>
+#include <platform_def.h>
+#include <smccc_helpers.h>
+#include <stm32_gpio.h>
+#include <stm32mp1_rcc.h>
+
+#define GPIO_TX_SHIFT		(DEBUG_UART_TX_GPIO_PORT << 1)
+
+	.globl	platform_mem_init
+	.globl	plat_report_exception
+#if AARCH32_EXCEPTION_DEBUG
+	.globl	plat_report_undef_inst
+	.globl	plat_report_prefetch_abort
+	.globl	plat_report_data_abort
+#endif
+	.globl	plat_get_my_entrypoint
+	.globl	plat_secondary_cold_boot_setup
+	.globl	plat_reset_handler
+	.globl	plat_is_my_cpu_primary
+	.globl	plat_my_core_pos
+	.globl	plat_crash_console_init
+	.globl	plat_crash_console_flush
+	.globl	plat_crash_console_putc
+	.globl	plat_panic_handler
+	.globl	wfi_svc_int_enable
+
+func platform_mem_init
+	/* Nothing to do, don't need to init SYSRAM */
+	bx	lr
+endfunc platform_mem_init
+
+func plat_report_exception
+#if DEBUG
+	mov	r8, lr
+
+	/* Test if an abort occurred */
+	cmp	r0, #MODE32_abt
+	bne	undef_inst_lbl
+	ldr	r4, =abort_str
+	bl	asm_print_str
+	b	print_excpetion_info
+
+undef_inst_lbl:
+	/* Test for an undefined instruction */
+	cmp	r0, #MODE32_und
+	bne	other_excpetion_lbl
+	ldr	r4, =undefined_str
+	bl	asm_print_str
+	b	print_excpetion_info
+
+other_excpetion_lbl:
+	/* Other exceptions */
+	mov	r9, r0
+	ldr	r4, =exception_start_str
+	bl	asm_print_str
+	mov	r4, r9
+	bl	asm_print_hex
+	ldr	r4, =exception_end_str
+	bl	asm_print_str
+
+print_excpetion_info:
+	mrs	r4, lr_svc
+	sub	r4, r4, #4
+	bl	asm_print_hex
+
+	ldr	r4, =end_error_str
+	bl	asm_print_str
+
+	bx	r8
+#else
+	bx	lr
+#endif
+endfunc plat_report_exception
+
+#if AARCH32_EXCEPTION_DEBUG
+func plat_report_undef_inst
+#if DEBUG
+	mov	r8, lr
+
+	mov	r9, r0
+
+	ldr	r4, =undefined_str
+	bl	asm_print_str
+
+	mov	r4, r9
+	sub	r4, r4, #4
+	bl	asm_print_hex
+
+	ldr	r4, =end_error_str
+	bl	asm_print_str
+
+	bx	r8
+#else
+	bx	lr
+#endif
+endfunc plat_report_undef_inst
+
+func plat_report_prefetch_abort
+#if DEBUG
+	mov	r8, lr
+	mov	r9, r0
+
+	ldr	r4, =prefetch_abort_str
+	bl	asm_print_str
+
+	mov	r4, r9
+	sub	r4, r4, #4
+	bl	asm_print_hex
+
+	ldr	r4, =ifsr_str
+	bl	asm_print_str
+
+	ldcopr	r4, IFSR
+	bl	asm_print_hex
+
+	ldr	r4, =ifar_str
+	bl	asm_print_str
+
+	ldcopr	r4, IFAR
+	bl	asm_print_hex
+
+	ldr	r4, =end_error_str
+	bl	asm_print_str
+
+	bx	r8
+#else
+	bx	lr
+#endif
+endfunc plat_report_prefetch_abort
+
+func plat_report_data_abort
+#if DEBUG
+	mov	r8, lr
+	mov	r9, r0
+
+	ldr	r4, =data_abort_str
+	bl	asm_print_str
+
+	mov	r4, r9
+	sub	r4, r4, #8
+	bl	asm_print_hex
+
+	ldr	r4, =dfsr_str
+	bl	asm_print_str
+
+	ldcopr	r4, DFSR
+	bl	asm_print_hex
+
+	ldr	r4, =dfar_str
+	bl	asm_print_str
+
+	ldcopr	r4, DFAR
+	bl	asm_print_hex
+
+	ldr	r4, =end_error_str
+	bl	asm_print_str
+
+	bx	r8
+#else
+	bx	lr
+#endif
+endfunc plat_report_data_abort
+#endif
+
+func plat_reset_handler
+	bx	lr
+endfunc plat_reset_handler
+
+	/* ------------------------------------------------------------------
+	 * unsigned long plat_get_my_entrypoint (void);
+	 *
+	 * Main job of this routine is to distinguish between a cold and warm
+	 * boot.
+	 *
+	 * Currently supports only cold boot
+	 * ------------------------------------------------------------------
+	 */
+func plat_get_my_entrypoint
+	mov	r0, #0
+	bx	lr
+endfunc plat_get_my_entrypoint
+
+	/* ---------------------------------------------
+	 * void plat_secondary_cold_boot_setup (void);
+	 *
+	 * Cold-booting secondary CPUs is not supported.
+	 * ---------------------------------------------
+	 */
+func plat_secondary_cold_boot_setup
+	b	.
+endfunc plat_secondary_cold_boot_setup
+
+	/* -----------------------------------------------------
+	 * unsigned int plat_is_my_cpu_primary (void);
+	 *
+	 * Find out whether the current cpu is the primary cpu.
+	 * -----------------------------------------------------
+	 */
+func plat_is_my_cpu_primary
+	ldcopr	r0, MPIDR
+	ldr	r1, =(MPIDR_CLUSTER_MASK | MPIDR_CPU_MASK)
+	and	r0, r1
+	cmp	r0, #STM32MP_PRIMARY_CPU
+	moveq	r0, #1
+	movne	r0, #0
+	bx	lr
+endfunc plat_is_my_cpu_primary
+
+	/* -------------------------------------------
+	 *  int plat_stm32mp1_get_core_pos(int mpidr);
+	 *
+	 *  Return CorePos = (ClusterId * 4) + CoreId
+	 * -------------------------------------------
+	 */
+func plat_stm32mp1_get_core_pos
+	and	r1, r0, #MPIDR_CPU_MASK
+	and	r0, r0, #MPIDR_CLUSTER_MASK
+	add	r0, r1, r0, LSR #6
+	bx	lr
+endfunc plat_stm32mp1_get_core_pos
+
+	/* ------------------------------------
+	 *  unsigned int plat_my_core_pos(void)
+	 * ------------------------------------
+	 */
+func plat_my_core_pos
+	ldcopr	r0, MPIDR
+	b	plat_stm32mp1_get_core_pos
+endfunc plat_my_core_pos
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_init(void)
+	 *
+	 * Initialize the crash console without a C Runtime stack.
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_init
+	/* Enable GPIOs for UART TX */
+	ldr	r1, =(RCC_BASE + DEBUG_UART_TX_GPIO_BANK_CLK_REG)
+	ldr	r2, [r1]
+	/* Configure GPIO */
+	orr	r2, r2, #DEBUG_UART_TX_GPIO_BANK_CLK_EN
+	str	r2, [r1]
+	ldr	r1, =DEBUG_UART_TX_GPIO_BANK_ADDRESS
+	/* Set GPIO mode alternate */
+	ldr	r2, [r1, #GPIO_MODE_OFFSET]
+	bic	r2, r2, #(GPIO_MODE_MASK << GPIO_TX_SHIFT)
+	orr	r2, r2, #(GPIO_MODE_ALTERNATE << GPIO_TX_SHIFT)
+	str	r2, [r1, #GPIO_MODE_OFFSET]
+	/* Set GPIO speed low */
+	ldr	r2, [r1, #GPIO_SPEED_OFFSET]
+	bic	r2, r2, #(GPIO_SPEED_MASK << GPIO_TX_SHIFT)
+	str	r2, [r1, #GPIO_SPEED_OFFSET]
+	/* Set no-pull */
+	ldr	r2, [r1, #GPIO_PUPD_OFFSET]
+	bic	r2, r2, #(GPIO_PULL_MASK << GPIO_TX_SHIFT)
+	str	r2, [r1, #GPIO_PUPD_OFFSET]
+	/* Set alternate */
+	ldr	r2, =DEBUG_UART_TX_GPIO_PORT
+	cmp	r2, #GPIO_ALT_LOWER_LIMIT
+	ldrge	r2, [r1, #GPIO_AFRH_OFFSET]
+	bicge	r2, r2, #(GPIO_ALTERNATE_MASK << ((DEBUG_UART_TX_GPIO_PORT - GPIO_ALT_LOWER_LIMIT) << 2))
+	orrge	r2, r2, #(DEBUG_UART_TX_GPIO_ALTERNATE << ((DEBUG_UART_TX_GPIO_PORT - GPIO_ALT_LOWER_LIMIT) << 2))
+	strge	r2, [r1, #GPIO_AFRH_OFFSET]
+	ldrlt	r2, [r1, #GPIO_AFRL_OFFSET]
+	biclt	r2, r2, #(GPIO_ALTERNATE_MASK << (DEBUG_UART_TX_GPIO_PORT << 2))
+	orrlt	r2, r2, #(DEBUG_UART_TX_GPIO_ALTERNATE << (DEBUG_UART_TX_GPIO_PORT << 2))
+	strlt	r2, [r1, #GPIO_AFRL_OFFSET]
+	/* Enable UART clock, with its source */
+	ldr	r1, =(RCC_BASE + DEBUG_UART_TX_CLKSRC_REG)
+	mov	r2, #DEBUG_UART_TX_CLKSRC
+	str	r2, [r1]
+	ldr	r1, =(RCC_BASE + DEBUG_UART_TX_EN_REG)
+	ldr	r2, [r1]
+	orr	r2, r2, #DEBUG_UART_TX_EN
+	str	r2, [r1]
+
+	ldr	r0, =STM32MP_DEBUG_USART_BASE
+	ldr	r1, =STM32MP_DEBUG_USART_CLK_FRQ
+	ldr	r2, =STM32MP_UART_BAUDRATE
+	b	console_stm32_core_init
+endfunc plat_crash_console_init
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_flush(void)
+	 *
+	 * Flush the crash console without a C Runtime stack.
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_flush
+	ldr	r1, =STM32MP_DEBUG_USART_BASE
+	b	console_stm32_core_flush
+endfunc plat_crash_console_flush
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_putc(int c)
+	 *
+	 * Print a character on the crash console without a C Runtime stack.
+	 * Clobber list : r1 - r3
+	 *
+	 * In case of bootloading through uart, we keep console crash as this.
+	 * Characters could be sent to the programmer, but will be ignored.
+	 * No specific code in that case.
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_putc
+	ldr	r1, =STM32MP_DEBUG_USART_BASE
+	b	console_stm32_core_putc
+endfunc plat_crash_console_putc
+
+	/* ----------------------------------------------------------
+	 * void plat_panic_handler(void) __dead2;
+	 * Report exception + endless loop.
+	 *
+	 * r6 holds the address where the fault occurred.
+	 * Filling lr with this value allows debuggers to reconstruct
+	 * the backtrace.
+	 * ----------------------------------------------------------
+	 */
+func plat_panic_handler
+	mrs	r0, cpsr
+	and	r0, #MODE32_MASK
+	bl	plat_report_exception
+	mov	lr, r6
+	b	.
+endfunc plat_panic_handler
+
+#if DEBUG
+.section .rodata.rev_err_str, "aS"
+abort_str:
+	.asciz "\nAbort at: 0x"
+#if AARCH32_EXCEPTION_DEBUG
+prefetch_abort_str:
+	.asciz "\nPrefetch Abort at: 0x"
+data_abort_str:
+	.asciz "\nData Abort at: 0x"
+#endif
+undefined_str:
+	.asciz "\nUndefined instruction at: 0x"
+exception_start_str:
+	.asciz "\nException mode=0x"
+exception_end_str:
+	.asciz " at: 0x"
+#if AARCH32_EXCEPTION_DEBUG
+dfsr_str:
+	.asciz " DFSR = 0x"
+dfar_str:
+	.asciz " DFAR = 0x"
+ifsr_str:
+	.asciz " IFSR = 0x"
+ifar_str:
+	.asciz " IFAR = 0x"
+#endif
+end_error_str:
+	.asciz "\n\r"
+#endif
+
+func wfi_svc_int_enable
+	push	{r4,r8,lr}
+	ldcopr	r4, SCR
+	mov	r8, sp
+	mov	sp, r0
+	add	r0, r0, #STM32MP_INT_STACK_SIZE
+	str	r0, [sp, #SMC_CTX_SP_MON]
+	str	r4, [sp, #SMC_CTX_SCR]
+	cps	#MODE32_svc
+	cpsie	af
+	dsb
+	isb
+	wfi
+	cpsid	af
+	cps	#MODE32_mon
+	mov	sp, r8
+	pop	{r4,r8,lr}
+	bx	lr
+endfunc wfi_svc_int_enable
Index: arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_helper_dbg.S
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/plat/karo/txmp/stm32mp1_helper_dbg.S
@@ -0,0 +1,233 @@
+/*
+ * Copyright (c) 2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*****************************************************************************
+ * This file is only needed for current Soc revision which has a limitation on
+ * debug reset halt. This can be removed when using the Soc revision that
+ * fixes the limitation. Anyway, this source code identifies the Soc revision
+ * and is only executed if it corresponds, so it can be kept on other
+ * revisions without any consequence.
+ * The revisions that need the workaround have ID values:
+ * - 0x2000X500
+ * - 0x2001X500
+ ****************************************************************************/
+
+/*****************************************************************************
+ * This file has been intentionally transformed in order to use only ASM
+ * standard macros and instructions. It could then be easily back-ported to
+ * other pieces of software.
+ ****************************************************************************/
+
+#include <asm_macros.S>
+
+#define BIT_(nr)			((1) << (nr))
+
+#define BSEC_BASE			0x5C005000
+#define BSEC_OTP_DATA_OFF		(BSEC_BASE + 0x200)
+#define BSEC_OTP_DATA0			BSEC_OTP_DATA_OFF
+#define BSEC_OTP_DATA0_CLOSED		BIT_(6)
+
+#define DBGMCU_BASE			0x50081000
+#define DBGMCU_IDC			0x00
+#define DBGMCU_IDC_REV_ID_DEV_ID_MSK	0xFFFE0FFF
+#define DBGMCU_IDC_REV_ID_DEV_ID_VALUE	0x20000500
+
+#define RCC_BASE			0x50000000
+#define RCC_MP_APB5ENSETR		0x208
+#define RCC_MP_APB5ENSETR_RTCAPBEN	BIT_(8)
+#define RCC_DBGCFGR			0x80C
+#define RCC_DBGCFGR_DBGCKEN		BIT_(8)
+
+#define PWR_BASE			0x50001000
+#define PWR_CR1				0x00
+#define PWR_CR1_DBP			BIT_(8)
+
+#define TAMP_BASE			0x5C00A000
+#define TAMP_BKP_REGISTER_BASE		TAMP_BASE + 0x100
+#define TAMP_BKP_REGISTER_20		TAMP_BKP_REGISTER_BASE + (20 << 2)
+
+#define CA7_DBG0_BASE			0x500D0000
+#define DBG_DSCR			0x88
+#define DBG_DSCR_HDBGEN			BIT_(14)
+
+#define FSBL_ENTRYPOINT			bl2_entrypoint
+
+	.globl	plat_dbg_attach_loop
+
+
+func plat_dbg_attach_loop
+	/*
+	 * This function is the first call of FSBL_ENTRYPOINT.
+	 * Boot rom parameters are stored in r0..r3, so we mustn't use them
+	 * here. And because they are saved in r9..r12 just after the
+	 * execution of this function, we should only use these registers.
+	 * By this way, debug will be done in conditions closed to the initial
+	 * context.
+	 */
+
+	/*
+	 * Check Sec Close bit in OTP (word 0 bit 6). If enabled, do not allow
+	 * debug session and exit function.
+	 */
+	ldr	r12, =BSEC_OTP_DATA0
+	ldr	r12, [r12]
+	ands	r11, r12, #BSEC_OTP_DATA0_CLOSED
+	bne	func_exit
+
+	/*
+	 * Enable DBGMCU clock (only if not done).
+	 * Initial register content will be saved in r10.
+	 * So r10 mustn't be used before restore part.
+	 */
+	ldr	r12, =(RCC_BASE + RCC_DBGCFGR)
+	ldr	r10, [r12]
+	tst	r10, #RCC_DBGCFGR_DBGCKEN
+	bne	dbgmcu_clk_enabled
+	orr	r11, r10, #RCC_DBGCFGR_DBGCKEN
+	str	r11, [r12]
+
+	/* Get SoC revision ID and device ID in r11 */
+dbgmcu_clk_enabled:
+	ldr	r12, =(DBGMCU_BASE + DBGMCU_IDC)
+	ldr	r12, [r12]
+	and	r11, r12, #DBGMCU_IDC_REV_ID_DEV_ID_MSK
+
+	/* Restore initial RCC_DBGCFGR content saved in r10 */
+	ldr	r12, =(RCC_BASE + RCC_DBGCFGR)
+	str	r10, [r12]
+
+	/*
+	 * Check SoC revision ID and device ID in r11,
+	 * exit if different from REV_ID_DEV_ID_VALUE
+	 */
+	ldr	r12, =(DBGMCU_IDC_REV_ID_DEV_ID_VALUE)
+	teq	r11, r12
+	bne	func_exit
+
+	/*
+	 * Enable RTC clock before reading tamper (only if not done).
+	 * Initial register content will be saved in r10.
+	 * So r10 mustn't be used before restore part.
+	 */
+	ldr	r12, =(RCC_BASE + RCC_MP_APB5ENSETR)
+	ldr	r10, [r12]
+	tst	r10, #RCC_MP_APB5ENSETR_RTCAPBEN
+	bne	rtc_clk_enabled
+	orr	r11, r10, #RCC_MP_APB5ENSETR_RTCAPBEN
+	str	r11, [r12]
+
+rtc_clk_enabled:
+	/*
+	 * Disable the backup domain write protection (only if not done).
+	 * Initial register content will be saved in r9.
+	 * So r9 mustn't be used before restore part.
+	 */
+	ldr	r12, =(PWR_BASE + PWR_CR1)
+	ldr	r9, [r12]
+	tst	r9, #PWR_CR1_DBP
+	bne	poll_dbp
+	orr	r11, r9, #PWR_CR1_DBP
+	str	r11, [r12]
+poll_dbp:
+	/* poll loop to ensure write is effective */
+	ldr	r11, [r12]
+	tst	r11, #PWR_CR1_DBP
+	beq	poll_dbp
+
+	/*
+	 * Clear bit 16 of TAMPER backup register 20 (only if set).
+	 * Firstly read the register value.
+	 * - If bit = 0, r11 = 0 after 'ands' operation. Next step is to
+	 *   restore RCC_MP_APB5ENSETR and PWR_CR1 contents and exit.
+	 * - If bit = 1, r11 != 0 after 'ands' operation, but could be
+	 *   equal to 0 after 'bic' operation. Here, after clearing the bit,
+	 *   r11 has to be set to a non-zero value. Next step is to restore
+	 *   register contents and continue.
+	 *
+	 * So r11 mustn't be used in restore part, to keep this information
+	 * for the next step, i.e. decide to continue execution (r11 = 1) or
+	 * exit function (r11 = 0).
+	 */
+	ldr	r12, =(TAMP_BKP_REGISTER_20)
+	ldr	r11, [r12]
+	ands	r11, r11, #(BIT_(16))
+	beq	restore_reg
+	ldr	r11, [r12]
+	bic	r11, #(BIT_(16))
+	str	r11, [r12]
+	ldr	r11, =(1)
+
+restore_reg:
+	/* Restore initial RCC_MP_APB5ENSETR content saved in r10 */
+	ldr	r12, =(RCC_BASE + RCC_MP_APB5ENSETR)
+	str	r10, [r12]
+
+	/* Restore initial PWR_CR1 content saved in r9 */
+	ldr	r12, =(PWR_BASE + PWR_CR1)
+	str	r9, [r12]
+poll_cr1:
+	/* poll loop to ensure write is effective */
+	ldr	r12, =(PWR_BASE + PWR_CR1)
+	ldr	r12, [r12]
+	teq	r12, r9
+	bne	poll_cr1
+
+	/*
+	 * Exit if bit 16 of TAMPER backup register 20 has been cleared.
+	 * Information is saved in r11 register.
+	 */
+	teq	r11, #0
+	beq	func_exit
+
+	/* Get time counter frequency */
+	mrc	15, 0, r12, cr14, cr0, 0
+	/* Get current time counter value, save it in r11 as start value */
+	mrrc	15, 0, r11, r10, cr14
+	/*
+	 * Compute (current time + 1 second) counter value, save it in r12 as
+	 * end value.
+	 */
+	add	r12, r12, r11
+
+loop:
+	/*
+	 * Read CA7_DBG0 DBG_DSCR HDBGEN bit value.
+	 * If set, put a software breakpoint and branch to FSBL_ENTRYPOINT.
+	 * If cleared, continue and check loop time expiry
+	 */
+	ldr	r10, =(CA7_DBG0_BASE + DBG_DSCR)
+	ldr	r10, [r10]
+	tst	r10, #DBG_DSCR_HDBGEN
+	beq	loop_continue
+	/* Set a software breakpoint (ID 5) */
+	bkpt	5
+	/* Jump to entrypoint */
+	b	FSBL_ENTRYPOINT
+loop_continue:
+	/*
+	 * Check 1 second expiry by using r11 and r12 saved values.
+	 * Get current time counter value, save it in r10 as current value.
+	 */
+	mrrc	15, 0, r10, r9, cr14
+	/* Check if MSB 64-bit increment done between start and end values */
+	cmp	r12, r11
+	bmi	msb_incr
+	/* No increment, simply check if current < end, exit if yes */
+	cmp	r12, r10
+	bmi	func_exit
+	b	loop
+msb_incr:
+	/*
+	 * Increment happened between start and end, here we need to check if
+	 * (current > end) && (current < start). Exit if yes.
+	 */
+	cmp	r12, r10
+	bpl	loop
+	cmp	r11, r10
+	bmi	loop
+func_exit:
+	bx	lr
+endfunc plat_dbg_attach_loop
Index: arm-trusted-firmware.git/fdts/stm32mp153a-qsmp-1530.dts
===================================================================
--- /dev/null
+++ arm-trusted-firmware.git/fdts/stm32mp153a-qsmp-1530.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: STM32CubeMX code generation for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp151a-qsmp.h"
+#include "stm32mp15-qsmp.dtsi"
+
+/ {
+	model = "Ka-Ro electronics GmbH QSMP-1530 solder-in module";
+	compatible = "karo,stm32mp153a-qsmp-1530", "st,stm32mp153";
+};
