From 4b06e0a05dc131068d25fcca6c23c5b250d6e8dc Mon Sep 17 00:00:00 2001
From: Romuald Jeanne <romuald.jeanne@st.com>
Date: Tue, 6 Jun 2023 09:25:08 +0200
Subject: [PATCH 02/24] v6.1-stm32mp-r1 CLOCK

Signed-off-by: Romuald Jeanne <romuald.jeanne@st.com>
---
 drivers/clk/clk-composite.c                |   15 +
 drivers/clk/clk-scmi.c                     |   37 +
 drivers/clk/clk-stm32mp1.c                 | 1657 +++++++++++++++++---
 drivers/clk/clk.c                          |    7 +-
 drivers/clk/stm32/clk-stm32-core.c         |  159 +-
 drivers/clk/stm32/clk-stm32-core.h         |   38 +
 drivers/clk/stm32/clk-stm32mp13.c          |  713 ++++++++-
 drivers/clk/stm32/reset-stm32.c            |   39 +
 drivers/clocksource/timer-stm32-lp.c       |    4 +-
 include/dt-bindings/clock/stm32mp1-clks.h  |    6 +
 include/dt-bindings/clock/stm32mp13-clks.h |    8 +-
 11 files changed, 2490 insertions(+), 193 deletions(-)

diff --git a/drivers/clk/clk-composite.c b/drivers/clk/clk-composite.c
index edfa94641bbf..52d332115643 100644
--- a/drivers/clk/clk-composite.c
+++ b/drivers/clk/clk-composite.c
@@ -42,6 +42,18 @@ static unsigned long clk_composite_recalc_rate(struct clk_hw *hw,
 	return rate_ops->recalc_rate(rate_hw, parent_rate);
 }
 
+static int clk_composite_get_duty_cycle(struct clk_hw *hw,
+					struct clk_duty *duty)
+{
+	struct clk_composite *composite = to_clk_composite(hw);
+	const struct clk_ops *rate_ops = composite->rate_ops;
+	struct clk_hw *rate_hw = composite->rate_hw;
+
+	__clk_hw_set_clk(rate_hw, hw);
+
+	return rate_ops->get_duty_cycle(rate_hw, duty);
+}
+
 static int clk_composite_determine_rate_for_parent(struct clk_hw *rate_hw,
 						   struct clk_rate_request *req,
 						   struct clk_hw *parent_hw,
@@ -282,6 +294,9 @@ static struct clk_hw *__clk_hw_register_composite(struct device *dev,
 		}
 		clk_composite_ops->recalc_rate = clk_composite_recalc_rate;
 
+		if (rate_ops->get_duty_cycle)
+			clk_composite_ops->get_duty_cycle = clk_composite_get_duty_cycle;
+
 		if (rate_ops->determine_rate)
 			clk_composite_ops->determine_rate =
 				clk_composite_determine_rate;
diff --git a/drivers/clk/clk-scmi.c b/drivers/clk/clk-scmi.c
index 2c7a830ce308..dca108016700 100644
--- a/drivers/clk/clk-scmi.c
+++ b/drivers/clk/clk-scmi.c
@@ -9,6 +9,7 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/of.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/scmi_protocol.h>
 #include <asm/div64.h>
@@ -37,6 +38,37 @@ static unsigned long scmi_clk_recalc_rate(struct clk_hw *hw,
 	return rate;
 }
 
+static unsigned long scmi_clk_round_rate_get(struct clk_hw *hw,
+					     unsigned long rate,
+					     unsigned long *parent_rate)
+{
+	int ret;
+	u64 round_rate = rate;
+	struct scmi_clk *clk = to_scmi_clk(hw);
+
+	ret = scmi_proto_clk_ops->round_rate_get(clk->ph, clk->id, &round_rate);
+	if (ret)
+		return 0;
+
+	return round_rate;
+}
+
+static int scmi_clk_get_duty_cycle(struct clk_hw *hw, struct clk_duty *duty)
+{
+	struct scmi_clk *clk = to_scmi_clk(hw);
+	int ret;
+
+	ret = scmi_proto_clk_ops->get_duty_cycle(clk->ph, clk->id,
+						 &duty->num, &duty->den);
+	if (ret) {
+		/* Assume a default value of 50% */
+		duty->num = 1;
+		duty->den = 2;
+	}
+
+	return 0;
+}
+
 static long scmi_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long *parent_rate)
 {
@@ -59,6 +91,9 @@ static long scmi_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 	else if (rate >= fmax)
 		return fmax;
 
+	if (clk->info->range.step_size == 0)
+		return scmi_clk_round_rate_get(hw, rate, parent_rate);
+
 	ftmp = rate - fmin;
 	ftmp += clk->info->range.step_size - 1; /* to round up */
 	do_div(ftmp, clk->info->range.step_size);
@@ -121,6 +156,7 @@ static const struct clk_ops scmi_clk_ops = {
 	.set_rate = scmi_clk_set_rate,
 	.prepare = scmi_clk_enable,
 	.unprepare = scmi_clk_disable,
+	.get_duty_cycle = scmi_clk_get_duty_cycle,
 };
 
 static const struct clk_ops scmi_atomic_clk_ops = {
@@ -129,6 +165,7 @@ static const struct clk_ops scmi_atomic_clk_ops = {
 	.set_rate = scmi_clk_set_rate,
 	.enable = scmi_clk_atomic_enable,
 	.disable = scmi_clk_atomic_disable,
+	.get_duty_cycle = scmi_clk_get_duty_cycle,
 };
 
 static int scmi_clk_ops_init(struct device *dev, struct scmi_clk *sclk,
diff --git a/drivers/clk/clk-stm32mp1.c b/drivers/clk/clk-stm32mp1.c
index 7ad2e6203bae..8cac8fe06de8 100644
--- a/drivers/clk/clk-stm32mp1.c
+++ b/drivers/clk/clk-stm32mp1.c
@@ -116,11 +116,11 @@ static const char * const ref3_parents[] = {
 };
 
 static const char * const ref4_parents[] = {
-	"ck_hsi", "ck_hse", "ck_csi"
+	"ck_hsi", "ck_hse", "ck_csi", "i2s_ckin"
 };
 
 static const char * const cpu_src[] = {
-	"ck_hsi", "ck_hse", "pll1_p"
+	"ck_hsi", "ck_hse", "pll1_p", "pll1_p_div"
 };
 
 static const char * const axi_src[] = {
@@ -298,6 +298,7 @@ static const struct clk_div_table ck_trace_div_table[] = {
 struct stm32_mmux {
 	u8 nbr_clk;
 	struct clk_hw *hws[MAX_MUX_CLK];
+	u8 saved_parent;
 };
 
 struct stm32_clk_mmux {
@@ -727,7 +728,7 @@ static int clk_mmux_set_parent(struct clk_hw *hw, u8 index)
 
 	for (n = 0; n < clk_mmux->mmux->nbr_clk; n++)
 		if (clk_mmux->mmux->hws[n] != hw)
-			clk_hw_reparent(clk_mmux->mmux->hws[n], hwp);
+			clk_hw_set_parent(clk_mmux->mmux->hws[n], hwp);
 
 	return 0;
 }
@@ -738,156 +739,212 @@ static const struct clk_ops clk_mmux_ops = {
 	.determine_rate	= __clk_mux_determine_rate,
 };
 
-/* STM32 PLL */
-struct stm32_pll_obj {
-	/* lock pll enable/disable registers */
-	spinlock_t *lock;
-	void __iomem *reg;
-	struct clk_hw hw;
-	struct clk_mux mux;
-};
+static bool is_all_clk_on_switch_are_off(struct clk_hw *hw)
+{
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
+	int i = 0;
 
-#define to_pll(_hw) container_of(_hw, struct stm32_pll_obj, hw)
+	for (i = 0; i < clk_mmux->mmux->nbr_clk; i++)
+		if (__clk_is_enabled(clk_mmux->mmux->hws[i]->clk))
+			return false;
 
-#define PLL_ON		BIT(0)
-#define PLL_RDY		BIT(1)
-#define DIVN_MASK	0x1FF
-#define DIVM_MASK	0x3F
-#define DIVM_SHIFT	16
-#define DIVN_SHIFT	0
-#define FRAC_OFFSET	0xC
-#define FRAC_MASK	0x1FFF
-#define FRAC_SHIFT	3
-#define FRACLE		BIT(16)
-#define PLL_MUX_SHIFT	0
-#define PLL_MUX_MASK	3
+	return true;
+}
 
-static int __pll_is_enabled(struct clk_hw *hw)
+#define MMUX_SAFE_POSITION 0
+
+static int clk_mmux_set_safe_position(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	return readl_relaxed(clk_elem->reg) & PLL_ON;
-}
+	clk_mmux->mmux->saved_parent = clk_mmux_get_parent(mux_hw);
+	clk_mux_ops.set_parent(mux_hw, MMUX_SAFE_POSITION);
 
-#define TIMEOUT 5
+	return 0;
+}
 
-static int pll_enable(struct clk_hw *hw)
+static int clk_mmux_restore_parent(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	unsigned long flags = 0;
-	unsigned int timeout = TIMEOUT;
-	int bit_status = 0;
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	spin_lock_irqsave(clk_elem->lock, flags);
+	clk_mux_ops.set_parent(mux_hw, clk_mmux->mmux->saved_parent);
 
-	if (__pll_is_enabled(hw))
-		goto unlock;
+	return 0;
+}
 
-	reg = readl_relaxed(clk_elem->reg);
-	reg |= PLL_ON;
-	writel_relaxed(reg, clk_elem->reg);
+static u8 clk_mmux_get_parent_safe(struct clk_hw *hw)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	/* We can't use readl_poll_timeout() because we can be blocked if
-	 * someone enables this clock before clocksource changes.
-	 * Only jiffies counter is available. Jiffies are incremented by
-	 * interruptions and enable op does not allow to be interrupted.
-	 */
-	do {
-		bit_status = !(readl_relaxed(clk_elem->reg) & PLL_RDY);
+	clk_mmux->mmux->saved_parent = clk_mmux_get_parent(hw);
 
-		if (bit_status)
-			udelay(120);
+	return clk_mmux->mmux->saved_parent;
+}
 
-	} while (bit_status && --timeout);
+static int clk_mmux_set_parent_safe(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-unlock:
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	clk_mmux_set_parent(hw, index);
+	clk_mmux->mmux->saved_parent = index;
 
-	return bit_status;
+	return 0;
 }
 
-static void pll_disable(struct clk_hw *hw)
-{
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	unsigned long flags = 0;
+static const struct clk_ops clk_mmux_safe_ops = {
+	.get_parent	= clk_mmux_get_parent_safe,
+	.set_parent	= clk_mmux_set_parent_safe,
+	.determine_rate	= __clk_mux_determine_rate,
+};
 
-	spin_lock_irqsave(clk_elem->lock, flags);
+static int mp1_mgate_clk_enable_safe(struct clk_hw *hw)
+{
+	struct clk_hw *composite_hw = __clk_get_hw(hw->clk);
 
-	reg = readl_relaxed(clk_elem->reg);
-	reg &= ~PLL_ON;
-	writel_relaxed(reg, clk_elem->reg);
+	clk_mmux_restore_parent(composite_hw);
+	mp1_mgate_clk_enable(hw);
 
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	return  0;
 }
 
-static u32 pll_frac_val(struct clk_hw *hw)
+static void mp1_mgate_clk_disable_safe(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg, frac = 0;
+	struct clk_hw *composite_hw = __clk_get_hw(hw->clk);
 
-	reg = readl_relaxed(clk_elem->reg + FRAC_OFFSET);
-	if (reg & FRACLE)
-		frac = (reg >> FRAC_SHIFT) & FRAC_MASK;
+	mp1_mgate_clk_disable(hw);
 
-	return frac;
+	if (is_all_clk_on_switch_are_off(composite_hw))
+		clk_mmux_set_safe_position(composite_hw);
 }
 
-static unsigned long pll_recalc_rate(struct clk_hw *hw,
-				     unsigned long parent_rate)
-{
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	u32 frac, divm, divn;
-	u64 rate, rate_frac = 0;
+static const struct clk_ops mp1_mgate_clk_safe_ops = {
+	.enable		= mp1_mgate_clk_enable_safe,
+	.disable	= mp1_mgate_clk_disable_safe,
+	.is_enabled	= clk_gate_is_enabled,
+};
+
+/* STM32 PLL */
+struct clk_pll_fractional_divider {
+	struct clk_hw hw;
+	void __iomem *mreg;
+	u8 mshift;
+	u8 mwidth;
+	u8 mflags;
+	void __iomem *nreg;
+	u8 nshift;
+	u8 nwidth;
+	u8 nflags;
+	void __iomem *freg;
+	u8 fshift;
+	u8 fwidth;
+
+	/* lock pll enable/disable registers */
+	spinlock_t *lock;
+};
 
-	reg = readl_relaxed(clk_elem->reg + 4);
+#define to_pll_fractional_divider(_hw)\
+	container_of(_hw, struct clk_pll_fractional_divider, hw)
 
-	divm = ((reg >> DIVM_SHIFT) & DIVM_MASK) + 1;
-	divn = ((reg >> DIVN_SHIFT) & DIVN_MASK) + 1;
-	rate = (u64)parent_rate * divn;
+static unsigned long clk_pll_frac_div_recalc_rate(struct clk_hw *hw,
+						  unsigned long parent_rate)
+{
+	struct clk_pll_fractional_divider *fd = to_pll_fractional_divider(hw);
+	u32 mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	u32 nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	u32 fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
 
-	do_div(rate, divm);
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
 
-	frac = pll_frac_val(hw);
-	if (frac) {
-		rate_frac = (u64)parent_rate * (u64)frac;
-		do_div(rate_frac, (divm * 8192));
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
 	}
-
-	return rate + rate_frac;
+	return rate + frate;
 }
 
-static int pll_is_enabled(struct clk_hw *hw)
+static const struct clk_ops clk_pll_frac_div_ops = {
+	.recalc_rate	= clk_pll_frac_div_recalc_rate,
+};
+
+#define PLL_BIT_ON		0
+#define PLL_BIT_RDY		1
+#define PLL_MUX_SHIFT		0
+#define PLL_MUX_MASK		3
+#define PLL_DIVMN_OFFSET	4
+#define PLL_DIVM_SHIFT		16
+#define PLL_DIVM_WIDTH		6
+#define PLL_DIVN_SHIFT		0
+#define PLL_DIVN_WIDTH		9
+#define PLL_FRAC_OFFSET		0xC
+#define PLL_FRAC_SHIFT		3
+#define PLL_FRAC_WIDTH		13
+
+#define TIMEOUT 5
+
+static int pll_enable(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	unsigned long flags = 0;
-	int ret;
+	struct clk_gate *gate = to_clk_gate(hw);
+	u32 timeout = TIMEOUT;
+	int bit_status = 0;
 
-	spin_lock_irqsave(clk_elem->lock, flags);
-	ret = __pll_is_enabled(hw);
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	if (clk_gate_ops.is_enabled(hw))
+		return 0;
 
-	return ret;
+	clk_gate_ops.enable(hw);
+
+	do {
+		bit_status = !(readl_relaxed(gate->reg) & BIT(PLL_BIT_RDY));
+
+		if (bit_status)
+			udelay(120);
+
+	} while (bit_status && --timeout);
+
+	return bit_status;
 }
 
-static u8 pll_get_parent(struct clk_hw *hw)
+static void pll_disable(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	struct clk_hw *mux_hw = &clk_elem->mux.hw;
-
-	__clk_hw_set_clk(mux_hw, hw);
+	if (!clk_gate_ops.is_enabled(hw))
+		return;
 
-	return clk_mux_ops.get_parent(mux_hw);
+	clk_gate_ops.disable(hw);
 }
 
-static const struct clk_ops pll_ops = {
+const struct clk_ops pll_gate_ops = {
 	.enable		= pll_enable,
 	.disable	= pll_disable,
-	.recalc_rate	= pll_recalc_rate,
-	.is_enabled	= pll_is_enabled,
-	.get_parent	= pll_get_parent,
+	.is_enabled	= clk_gate_is_enabled,
 };
 
 static struct clk_hw *clk_register_pll(struct device *dev, const char *name,
@@ -898,39 +955,50 @@ static struct clk_hw *clk_register_pll(struct device *dev, const char *name,
 				       unsigned long flags,
 				       spinlock_t *lock)
 {
-	struct stm32_pll_obj *element;
-	struct clk_init_data init;
-	struct clk_hw *hw;
-	int err;
+	struct clk_pll_fractional_divider *frac_div;
+	struct clk_gate *gate;
+	struct clk_mux *mux;
 
-	element = devm_kzalloc(dev, sizeof(*element), GFP_KERNEL);
-	if (!element)
+	mux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);
+	if (!mux)
 		return ERR_PTR(-ENOMEM);
 
-	init.name = name;
-	init.ops = &pll_ops;
-	init.flags = flags;
-	init.parent_names = parent_names;
-	init.num_parents = num_parents;
+	mux->reg = mux_reg;
+	mux->shift = PLL_MUX_SHIFT;
+	mux->mask = PLL_MUX_MASK;
+	mux->flags = CLK_MUX_READ_ONLY;
+	mux->table = NULL;
+	mux->lock = lock;
 
-	element->mux.lock = lock;
-	element->mux.reg =  mux_reg;
-	element->mux.shift = PLL_MUX_SHIFT;
-	element->mux.mask =  PLL_MUX_MASK;
-	element->mux.flags =  CLK_MUX_READ_ONLY;
-	element->mux.reg =  mux_reg;
+	gate = devm_kzalloc(dev, sizeof(*gate), GFP_KERNEL);
+	if (!gate)
+		return ERR_PTR(-ENOMEM);
 
-	element->hw.init = &init;
-	element->reg = reg;
-	element->lock = lock;
+	gate->reg = reg;
+	gate->bit_idx = PLL_BIT_ON;
+	gate->flags = 0;
+	gate->lock = lock;
 
-	hw = &element->hw;
-	err = clk_hw_register(dev, hw);
+	frac_div = devm_kzalloc(dev, sizeof(*frac_div), GFP_KERNEL);
+	if (!frac_div)
+		return ERR_PTR(-ENOMEM);
 
-	if (err)
-		return ERR_PTR(err);
+	frac_div->mreg = reg + PLL_DIVMN_OFFSET;
+	frac_div->mshift = PLL_DIVM_SHIFT;
+	frac_div->mwidth = PLL_DIVM_WIDTH;
+	frac_div->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	frac_div->nreg = reg + PLL_DIVMN_OFFSET;
+	frac_div->nshift = PLL_DIVN_SHIFT;
+	frac_div->nwidth = PLL_DIVN_WIDTH;
+	frac_div->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	frac_div->freg = reg + PLL_FRAC_OFFSET;
+	frac_div->fshift = PLL_FRAC_SHIFT;
+	frac_div->fwidth = PLL_FRAC_WIDTH;
 
-	return hw;
+	return clk_hw_register_composite(dev, name, parent_names, num_parents,
+					 &mux->hw, &clk_mux_ops,
+					 &frac_div->hw, &clk_pll_frac_div_ops,
+					 &gate->hw, &pll_gate_ops, flags);
 }
 
 /* Kernel Timer */
@@ -1100,9 +1168,49 @@ static const struct clk_ops rtc_div_clk_ops = {
 	.determine_rate = clk_divider_rtc_determine_rate
 };
 
+static int clk_div_get_duty_cycle(struct clk_hw *hw, struct clk_duty *duty)
+{
+	struct clk_divider *divider = to_clk_divider(hw);
+	unsigned int val;
+
+	val = readl(divider->reg) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+
+	duty->num = (val + 1) / 2;
+	duty->den = (val + 1);
+
+	return 0;
+}
+
+static unsigned long clk_div_duty_cycle_recalc_rate(struct clk_hw *hw,
+						    unsigned long parent_rate)
+{
+	return clk_divider_ops.recalc_rate(hw, parent_rate);
+}
+
+static long clk_div_duty_cycle_round_rate(struct clk_hw *hw, unsigned long rate,
+					  unsigned long *prate)
+{
+	return clk_divider_ops.round_rate(hw, rate, prate);
+}
+
+static int clk_div_duty_cycle_set_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	return clk_divider_ops.set_rate(hw, rate, parent_rate);
+}
+
+static const struct clk_ops div_dc_clk_ops = {
+	.recalc_rate	= clk_div_duty_cycle_recalc_rate,
+	.round_rate	= clk_div_duty_cycle_round_rate,
+	.set_rate	= clk_div_duty_cycle_set_rate,
+	.get_duty_cycle = clk_div_get_duty_cycle,
+};
+
 struct stm32_pll_cfg {
 	u32 offset;
 	u32 muxoff;
+	const struct clk_ops *ops;
 };
 
 static struct clk_hw *_clk_register_pll(struct device *dev,
@@ -1302,7 +1410,7 @@ _clk_stm32_register_composite(struct device *dev,
 		    NULL, &mp1_gate_clk_ops)\
 
 #define _MGATE_MP1(_mgate)\
-	.gate = &per_gate_cfg[_mgate]
+	&per_gate_cfg[_mgate]
 
 #define GATE_MP1(_id, _name, _parent, _flags, _offset, _bit_idx, _gate_flags)\
 	STM32_GATE(_id, _name, _parent, _flags,\
@@ -1318,7 +1426,7 @@ _clk_stm32_register_composite(struct device *dev,
 
 #define _STM32_DIV(_div_offset, _div_shift, _div_width,\
 		   _div_flags, _div_table, _ops)\
-	.div = &(struct stm32_div_cfg) {\
+	(&(struct stm32_div_cfg) {\
 		&(struct div_cfg) {\
 			.reg_off	= _div_offset,\
 			.shift		= _div_shift,\
@@ -1327,18 +1435,23 @@ _clk_stm32_register_composite(struct device *dev,
 			.table		= _div_table,\
 		},\
 		.ops		= _ops,\
-	}
+	})
 
 #define _DIV(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\
 	_STM32_DIV(_div_offset, _div_shift, _div_width,\
-		   _div_flags, _div_table, NULL)\
+		   _div_flags, _div_table, NULL)
+
+#define _DIV_DUTY_CYCLE(_div_offset, _div_shift, _div_width, _div_flags,\
+			_div_table)\
+	_STM32_DIV(_div_offset, _div_shift, _div_width,\
+		   _div_flags, _div_table, &div_dc_clk_ops)
 
 #define _DIV_RTC(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\
 	_STM32_DIV(_div_offset, _div_shift, _div_width,\
 		   _div_flags, _div_table, &rtc_div_clk_ops)
 
 #define _STM32_MUX(_offset, _shift, _width, _mux_flags, _mmux, _ops)\
-	.mux = &(struct stm32_mux_cfg) {\
+	(&(struct stm32_mux_cfg) {\
 		&(struct mux_cfg) {\
 			.reg_off	= _offset,\
 			.shift		= _shift,\
@@ -1348,18 +1461,18 @@ _clk_stm32_register_composite(struct device *dev,
 		},\
 		.mmux		= _mmux,\
 		.ops		= _ops,\
-	}
+	})
 
 #define _MUX(_offset, _shift, _width, _mux_flags)\
-	_STM32_MUX(_offset, _shift, _width, _mux_flags, NULL, NULL)\
+	_STM32_MUX(_offset, _shift, _width, _mux_flags, NULL, NULL)
 
-#define _MMUX(_mmux) .mux = &ker_mux_cfg[_mmux]
+#define _MMUX(_mmux)		&ker_mux_cfg[_mmux]
 
-#define PARENT(_parent) ((const char *[]) { _parent})
+#define PARENT(_parent)		((const char *[]) { _parent})
 
-#define _NO_MUX .mux = NULL
-#define _NO_DIV .div = NULL
-#define _NO_GATE .gate = NULL
+#define _NO_MUX			NULL
+#define _NO_DIV			NULL
+#define _NO_GATE		NULL
 
 #define COMPOSITE(_id, _name, _parents, _flags, _gate, _mux, _div)\
 {\
@@ -1369,9 +1482,9 @@ _clk_stm32_register_composite(struct device *dev,
 	.num_parents	= ARRAY_SIZE(_parents),\
 	.flags		= _flags,\
 	.cfg		= &(struct stm32_composite_cfg) {\
-		_gate,\
-		_mux,\
-		_div,\
+		.gate = (_gate),\
+		.mux = (_mux),\
+		.div = (_div),\
 	},\
 	.func		= _clk_stm32_register_composite,\
 }
@@ -1526,6 +1639,10 @@ static struct stm32_mgate mp1_mgate[G_LAST];
 	_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\
 	       &mp1_mgate[_id], &mp1_mgate_clk_ops)
 
+#define K_MGATE_SAFE(_id, _gate_offset, _gate_bit_idx, _gate_flags)\
+	_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\
+		&mp1_mgate[_id], &mp1_mgate_clk_safe_ops)
+
 /* Peripheral gates */
 static struct stm32_gate_cfg per_gate_cfg[G_LAST] = {
 	/* Multi gates */
@@ -1637,10 +1754,10 @@ static struct stm32_gate_cfg per_gate_cfg[G_LAST] = {
 
 	K_GATE(G_USBH,		RCC_AHB6ENSETR, 24, 0),
 	K_GATE(G_CRC1,		RCC_AHB6ENSETR, 20, 0),
-	K_MGATE(G_SDMMC2,	RCC_AHB6ENSETR, 17, 0),
-	K_MGATE(G_SDMMC1,	RCC_AHB6ENSETR, 16, 0),
-	K_MGATE(G_QSPI,		RCC_AHB6ENSETR, 14, 0),
-	K_MGATE(G_FMC,		RCC_AHB6ENSETR, 12, 0),
+	K_MGATE_SAFE(G_SDMMC2,	RCC_AHB6ENSETR, 17, 0),
+	K_MGATE_SAFE(G_SDMMC1,	RCC_AHB6ENSETR, 16, 0),
+	K_MGATE_SAFE(G_QSPI,	RCC_AHB6ENSETR, 14, 0),
+	K_MGATE_SAFE(G_FMC,	RCC_AHB6ENSETR, 12, 0),
 	K_GATE(G_ETHMAC,	RCC_AHB6ENSETR, 10, 0),
 	K_GATE(G_ETHRX,		RCC_AHB6ENSETR, 9, 0),
 	K_GATE(G_ETHTX,		RCC_AHB6ENSETR, 8, 0),
@@ -1712,9 +1829,13 @@ static struct stm32_mmux ker_mux[M_LAST];
 	_K_MUX(_id, _offset, _shift, _width, _mux_flags,\
 			&ker_mux[_id], &clk_mmux_ops)
 
+#define K_MMUX_SAFE(_id, _offset, _shift, _width, _mux_flags)\
+	_K_MUX(_id, _offset, _shift, _width, _mux_flags,\
+			&ker_mux[_id], &clk_mmux_safe_ops)
+
 static const struct stm32_mux_cfg ker_mux_cfg[M_LAST] = {
 	/* Kernel multi mux */
-	K_MMUX(M_SDMMC12, RCC_SDMMC12CKSELR, 0, 3, 0),
+	K_MMUX_SAFE(M_SDMMC12, RCC_SDMMC12CKSELR, 0, 3, 0),
 	K_MMUX(M_SPI23, RCC_SPI2S23CKSELR, 0, 3, 0),
 	K_MMUX(M_SPI45, RCC_SPI2S45CKSELR, 0, 3, 0),
 	K_MMUX(M_I2C12, RCC_I2C12CKSELR, 0, 3, 0),
@@ -1731,8 +1852,8 @@ static const struct stm32_mux_cfg ker_mux_cfg[M_LAST] = {
 	/*  Kernel simple mux */
 	K_MUX(M_RNG2, RCC_RNG2CKSELR, 0, 2, 0),
 	K_MUX(M_SDMMC3, RCC_SDMMC3CKSELR, 0, 3, 0),
-	K_MUX(M_FMC, RCC_FMCCKSELR, 0, 2, 0),
-	K_MUX(M_QSPI, RCC_QSPICKSELR, 0, 2, 0),
+	K_MMUX_SAFE(M_FMC, RCC_FMCCKSELR, 0, 2, 0),
+	K_MMUX_SAFE(M_QSPI, RCC_QSPICKSELR, 0, 2, 0),
 	K_MUX(M_USBPHY, RCC_USBCKSELR, 0, 2, 0),
 	K_MUX(M_USBO, RCC_USBCKSELR, 4, 1, 0),
 	K_MUX(M_SPDIF, RCC_SPDIFCKSELR, 0, 2, 0),
@@ -1776,7 +1897,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PLL(PLL4, "pll4", ref4_parents, 0, RCC_PLL4CR, RCC_RCK4SELR),
 
 	/* ODF */
-	COMPOSITE(PLL1_P, "pll1_p", PARENT("pll1"), 0,
+	COMPOSITE(PLL1_P, "pll1_p", PARENT("pll1"), CLK_SET_RATE_PARENT,
 		  _GATE(RCC_PLL1CR, 4, 0),
 		  _NO_MUX,
 		  _DIV(RCC_PLL1CFGR2, 0, 7, 0, NULL)),
@@ -1804,7 +1925,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	COMPOSITE(PLL3_Q, "pll3_q", PARENT("pll3"), 0,
 		  _GATE(RCC_PLL3CR, 5, 0),
 		  _NO_MUX,
-		  _DIV(RCC_PLL3CFGR2, 8, 7, 0, NULL)),
+		  _DIV_DUTY_CYCLE(RCC_PLL3CFGR2, 8, 7, 0, NULL)),
 
 	COMPOSITE(PLL3_R, "pll3_r", PARENT("pll3"), 0,
 		  _GATE(RCC_PLL3CR, 6, 0),
@@ -1824,40 +1945,40 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	COMPOSITE(PLL4_R, "pll4_r", PARENT("pll4"), 0,
 		  _GATE(RCC_PLL4CR, 6, 0),
 		  _NO_MUX,
-		  _DIV(RCC_PLL4CFGR2, 16, 7, 0, NULL)),
+		  _DIV_DUTY_CYCLE(RCC_PLL4CFGR2, 16, 7, 0, NULL)),
 
 	/* MUX system clocks */
 	MUX(CK_PER, "ck_per", per_src, CLK_OPS_PARENT_ENABLE,
 	    RCC_CPERCKSELR, 0, 2, 0),
 
 	MUX(CK_MPU, "ck_mpu", cpu_src, CLK_OPS_PARENT_ENABLE |
-	     CLK_IS_CRITICAL, RCC_MPCKSELR, 0, 2, 0),
+	    CLK_SET_RATE_PARENT | CLK_IS_CRITICAL, RCC_MPCKSELR, 0, 2, 0),
 
 	COMPOSITE(CK_AXI, "ck_axi", axi_src, CLK_IS_CRITICAL |
-		   CLK_OPS_PARENT_ENABLE,
-		   _NO_GATE,
-		   _MUX(RCC_ASSCKSELR, 0, 2, 0),
-		   _DIV(RCC_AXIDIVR, 0, 3, 0, axi_div_table)),
+		  CLK_OPS_PARENT_ENABLE,
+		  _NO_GATE,
+		  _MUX(RCC_ASSCKSELR, 0, 2, 0),
+		  _DIV(RCC_AXIDIVR, 0, 3, 0, axi_div_table)),
 
 	COMPOSITE(CK_MCU, "ck_mcu", mcu_src, CLK_IS_CRITICAL |
-		   CLK_OPS_PARENT_ENABLE,
-		   _NO_GATE,
-		   _MUX(RCC_MSSCKSELR, 0, 2, 0),
-		   _DIV(RCC_MCUDIVR, 0, 4, 0, mcu_div_table)),
+		  CLK_OPS_PARENT_ENABLE,
+		  _NO_GATE,
+		  _MUX(RCC_MSSCKSELR, 0, 2, 0),
+		  _DIV(RCC_MCUDIVR, 0, 4, 0, mcu_div_table)),
 
-	DIV_TABLE(NO_ID, "pclk1", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB1DIVR, 0,
+	DIV_TABLE(PCLK1, "pclk1", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB1DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk2", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB2DIVR, 0,
+	DIV_TABLE(PCLK2, "pclk2", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB2DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk3", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB3DIVR, 0,
+	DIV_TABLE(PCLK3, "pclk3", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB3DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk4", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB4DIVR, 0,
+	DIV_TABLE(PCLK4, "pclk4", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB4DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk5", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB5DIVR, 0,
+	DIV_TABLE(PCLK5, "pclk5", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB5DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
 	/* Kernel Timers */
@@ -1939,8 +2060,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PCLK(I2C4, "i2c4", "pclk5", 0, G_I2C4),
 	PCLK(I2C6, "i2c6", "pclk5", 0, G_I2C6),
 	PCLK(USART1, "usart1", "pclk5", 0, G_USART1),
-	PCLK(RTCAPB, "rtcapb", "pclk5", CLK_IGNORE_UNUSED |
-	     CLK_IS_CRITICAL, G_RTCAPB),
+	PCLK(RTCAPB, "rtcapb", "pclk5", CLK_IS_CRITICAL, G_RTCAPB),
 	PCLK(TZC1, "tzc1", "ck_axi", CLK_IGNORE_UNUSED, G_TZC1),
 	PCLK(TZC2, "tzc2", "ck_axi", CLK_IGNORE_UNUSED, G_TZC2),
 	PCLK(TZPC, "tzpc", "pclk5", CLK_IGNORE_UNUSED, G_TZPC),
@@ -1981,10 +2101,6 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PCLK(ETHTX, "ethtx", "ck_axi", 0, G_ETHTX),
 	PCLK_PDATA(ETHRX, "ethrx", ethrx_src, 0, G_ETHRX),
 	PCLK(ETHMAC, "ethmac", "ck_axi", 0, G_ETHMAC),
-	PCLK(FMC, "fmc", "ck_axi", CLK_IGNORE_UNUSED, G_FMC),
-	PCLK(QSPI, "qspi", "ck_axi", CLK_IGNORE_UNUSED, G_QSPI),
-	PCLK(SDMMC1, "sdmmc1", "ck_axi", 0, G_SDMMC1),
-	PCLK(SDMMC2, "sdmmc2", "ck_axi", 0, G_SDMMC2),
 	PCLK(CRC1, "crc1", "ck_axi", 0, G_CRC1),
 	PCLK(USBH, "usbh", "ck_axi", 0, G_USBH),
 	PCLK(ETHSTP, "ethstp", "ck_axi", 0, G_ETHSTP),
@@ -2078,7 +2194,8 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	GATE(CK_DBG, "ck_sys_dbg", "ck_axi", CLK_IGNORE_UNUSED,
 	     RCC_DBGCFGR, 8, 0),
 
-	COMPOSITE(CK_TRACE, "ck_trace", ck_trace_src, CLK_OPS_PARENT_ENABLE,
+	COMPOSITE(CK_TRACE, "ck_trace", ck_trace_src,
+		  CLK_OPS_PARENT_ENABLE | CLK_IGNORE_UNUSED,
 		  _GATE(RCC_DBGCFGR, 9, 0),
 		  _NO_MUX,
 		  _DIV(RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table)),
@@ -2368,6 +2485,8 @@ static int stm32_rcc_init(struct device *dev, void __iomem *base,
 	return 0;
 }
 
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base);
+
 static int stm32mp1_rcc_init(struct device *dev)
 {
 	void __iomem *base;
@@ -2388,6 +2507,8 @@ static int stm32mp1_rcc_init(struct device *dev)
 			iounmap(base);
 
 		of_node_put(dev_of_node(dev));
+	} else {
+		stm32_clk_summary_debugfs_create(dev, base);
 	}
 
 	return ret;
@@ -2459,3 +2580,1183 @@ static int __init stm32mp1_clocks_init(void)
 	return platform_driver_register(&stm32mp1_rcc_clocks_driver);
 }
 core_initcall(stm32mp1_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+#define NO_STM32_MUX		0xFFFF
+#define NO_STM32_DIV		0xFFFF
+#define NO_STM32_GATE		0xFFFF
+
+enum enum_gate_cfg {
+	GATE_HSI,
+	GATE_CSI,
+	GATE_LSI,
+	GATE_HSE,
+	GATE_LSE,
+	GATE_PLL1,
+	GATE_PLL2,
+	GATE_PLL3,
+	GATE_PLL4,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
+	GATE_RTCCK,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_DBGCK,
+	GATE_TRACECK,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_SPDIF,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_I2C6,
+	GATE_USART2,
+	GATE_UART4,
+	GATE_USART3,
+	GATE_UART5,
+	GATE_USART1,
+	GATE_USART6,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_LTDC,
+	GATE_DSI,
+	GATE_QSPI,
+	GATE_FMC,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_USBO,
+	GATE_USBPHY,
+	GATE_RNG1,
+	GATE_RNG2,
+	GATE_FDCAN,
+	GATE_DAC12,
+	GATE_CEC,
+	GATE_ADC12,
+	GATE_GPU,
+	GATE_STGEN,
+	GATE_DFSDM,
+	GATE_ADFSDM,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_MDIO,
+	GATE_TIM1,
+	GATE_TIM8,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_SYSCFG,
+	GATE_VREF,
+	GATE_TMPSENS,
+	GATE_PMBCTRL,
+	GATE_HDP,
+	GATE_IWDG2,
+	GATE_STGENRO,
+	GATE_DMA1,
+	GATE_DMA2,
+	GATE_DMAMUX,
+	GATE_DCMI,
+	GATE_CRYP2,
+	GATE_HASH2,
+	GATE_CRC2,
+	GATE_HSEM,
+	GATE_IPCC,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_GPIOJ,
+	GATE_GPIOK,
+	GATE_MDMA,
+	GATE_ETHCK,
+	GATE_ETHTX,
+	GATE_ETHRX,
+	GATE_ETHMAC,
+	GATE_CRC1,
+	GATE_USBH,
+	GATE_ETHSTP,
+	GATE_RTCAPB,
+	GATE_TZC1,
+	GATE_TZC2,
+	GATE_TZPC,
+	GATE_IWDG1,
+	GATE_BSEC,
+	GATE_GPIOZ,
+	GATE_CRYP1,
+	GATE_HASH1,
+	GATE_BKPSRAM,
+	GATE_DDRPERFM,
+
+	GATE_NB
+};
+
+struct cs_gate_cfg {
+	u16	offset;
+	u8	bit_idx;
+};
+
+#define CFG_GATE(_id, _offset, _bit_idx)\
+	[(_id)] = {\
+		.offset = (_offset),\
+		.bit_idx = (_bit_idx),\
+	}
+
+static struct cs_gate_cfg stm32mp15_gates[] = {
+	CFG_GATE(GATE_HSI,		RCC_OCENSETR,	0),
+	CFG_GATE(GATE_CSI,		RCC_OCENSETR,	4),
+	CFG_GATE(GATE_LSI,		RCC_RDLSICR,	0),
+	CFG_GATE(GATE_HSE,		RCC_OCENSETR,	8),
+	CFG_GATE(GATE_LSE,		RCC_BDCR,	0),
+	CFG_GATE(GATE_RTCCK,		RCC_BDCR,	20),
+	CFG_GATE(GATE_PLL1,		RCC_PLL1CR,	0),
+	CFG_GATE(GATE_PLL1_DIVP,	RCC_PLL1CR,	4),
+	CFG_GATE(GATE_PLL1_DIVQ,	RCC_PLL1CR,	5),
+	CFG_GATE(GATE_PLL1_DIVR,	RCC_PLL1CR,	6),
+	CFG_GATE(GATE_PLL2,		RCC_PLL2CR,	0),
+	CFG_GATE(GATE_PLL2_DIVP,	RCC_PLL2CR,	4),
+	CFG_GATE(GATE_PLL2_DIVQ,	RCC_PLL2CR,	5),
+	CFG_GATE(GATE_PLL2_DIVR,	RCC_PLL2CR,	6),
+	CFG_GATE(GATE_PLL3,		RCC_PLL3CR,	0),
+	CFG_GATE(GATE_PLL3_DIVP,	RCC_PLL3CR,	4),
+	CFG_GATE(GATE_PLL3_DIVQ,	RCC_PLL3CR,	5),
+	CFG_GATE(GATE_PLL3_DIVR,	RCC_PLL3CR,	6),
+	CFG_GATE(GATE_PLL4,		RCC_PLL4CR,	0),
+	CFG_GATE(GATE_PLL4_DIVP,	RCC_PLL4CR,	4),
+	CFG_GATE(GATE_PLL4_DIVQ,	RCC_PLL4CR,	5),
+	CFG_GATE(GATE_PLL4_DIVR,	RCC_PLL4CR,	6),
+	CFG_GATE(GATE_MCO1,		RCC_MCO1CFGR,	12),
+	CFG_GATE(GATE_MCO2,		RCC_MCO2CFGR,	12),
+	CFG_GATE(GATE_DBGCK,		RCC_DBGCFGR,	8),
+	CFG_GATE(GATE_TRACECK,		RCC_DBGCFGR,	9),
+	CFG_GATE(GATE_MDIO,		RCC_APB1ENSETR, 31),
+	CFG_GATE(GATE_DAC12,		RCC_APB1ENSETR, 29),
+	CFG_GATE(GATE_CEC,		RCC_APB1ENSETR, 27),
+	CFG_GATE(GATE_SPDIF,		RCC_APB1ENSETR, 26),
+	CFG_GATE(GATE_I2C5,		RCC_APB1ENSETR, 24),
+	CFG_GATE(GATE_I2C3,		RCC_APB1ENSETR, 23),
+	CFG_GATE(GATE_I2C2,		RCC_APB1ENSETR, 22),
+	CFG_GATE(GATE_I2C1,		RCC_APB1ENSETR, 21),
+	CFG_GATE(GATE_UART8,		RCC_APB1ENSETR, 19),
+	CFG_GATE(GATE_UART7,		RCC_APB1ENSETR, 18),
+	CFG_GATE(GATE_UART5,		RCC_APB1ENSETR, 17),
+	CFG_GATE(GATE_UART4,		RCC_APB1ENSETR, 16),
+	CFG_GATE(GATE_USART3,		RCC_APB1ENSETR, 15),
+	CFG_GATE(GATE_USART2,		RCC_APB1ENSETR, 14),
+	CFG_GATE(GATE_SPI3,		RCC_APB1ENSETR, 12),
+	CFG_GATE(GATE_SPI2,		RCC_APB1ENSETR, 11),
+	CFG_GATE(GATE_LPTIM1,		RCC_APB1ENSETR, 9),
+	CFG_GATE(GATE_TIM14,		RCC_APB1ENSETR, 8),
+	CFG_GATE(GATE_TIM13,		RCC_APB1ENSETR, 7),
+	CFG_GATE(GATE_TIM12,		RCC_APB1ENSETR, 6),
+	CFG_GATE(GATE_TIM7,		RCC_APB1ENSETR, 5),
+	CFG_GATE(GATE_TIM6,		RCC_APB1ENSETR, 4),
+	CFG_GATE(GATE_TIM5,		RCC_APB1ENSETR, 3),
+	CFG_GATE(GATE_TIM4,		RCC_APB1ENSETR, 2),
+	CFG_GATE(GATE_TIM3,		RCC_APB1ENSETR, 1),
+	CFG_GATE(GATE_TIM2,		RCC_APB1ENSETR, 0),
+	CFG_GATE(GATE_FDCAN,		RCC_APB2ENSETR, 24),
+	CFG_GATE(GATE_ADFSDM,		RCC_APB2ENSETR, 21),
+	CFG_GATE(GATE_DFSDM,		RCC_APB2ENSETR, 20),
+	CFG_GATE(GATE_SAI3,		RCC_APB2ENSETR, 18),
+	CFG_GATE(GATE_SAI2,		RCC_APB2ENSETR, 17),
+	CFG_GATE(GATE_SAI1,		RCC_APB2ENSETR, 16),
+	CFG_GATE(GATE_USART6,		RCC_APB2ENSETR, 13),
+	CFG_GATE(GATE_SPI5,		RCC_APB2ENSETR, 10),
+	CFG_GATE(GATE_SPI4,		RCC_APB2ENSETR, 9),
+	CFG_GATE(GATE_SPI1,		RCC_APB2ENSETR, 8),
+	CFG_GATE(GATE_TIM17,		RCC_APB2ENSETR, 4),
+	CFG_GATE(GATE_TIM16,		RCC_APB2ENSETR, 3),
+	CFG_GATE(GATE_TIM15,		RCC_APB2ENSETR, 2),
+	CFG_GATE(GATE_TIM8,		RCC_APB2ENSETR, 1),
+	CFG_GATE(GATE_TIM1,		RCC_APB2ENSETR, 0),
+	CFG_GATE(GATE_HDP,		RCC_APB3ENSETR, 20),
+	CFG_GATE(GATE_PMBCTRL,		RCC_APB3ENSETR, 17),
+	CFG_GATE(GATE_TMPSENS,		RCC_APB3ENSETR, 16),
+	CFG_GATE(GATE_VREF,		RCC_APB3ENSETR, 13),
+	CFG_GATE(GATE_SYSCFG,		RCC_APB3ENSETR, 11),
+	CFG_GATE(GATE_SAI4,		RCC_APB3ENSETR, 8),
+	CFG_GATE(GATE_LPTIM5,		RCC_APB3ENSETR, 3),
+	CFG_GATE(GATE_LPTIM4,		RCC_APB3ENSETR, 2),
+	CFG_GATE(GATE_LPTIM3,		RCC_APB3ENSETR, 1),
+	CFG_GATE(GATE_LPTIM2,		RCC_APB3ENSETR, 0),
+	CFG_GATE(GATE_STGENRO,		RCC_APB4ENSETR, 20),
+	CFG_GATE(GATE_USBPHY,		RCC_APB4ENSETR, 16),
+	CFG_GATE(GATE_IWDG2,		RCC_APB4ENSETR, 15),
+	CFG_GATE(GATE_DDRPERFM,		RCC_APB4ENSETR, 8),
+	CFG_GATE(GATE_DSI,		RCC_APB4ENSETR, 4),
+	CFG_GATE(GATE_LTDC,		RCC_APB4ENSETR, 0),
+	CFG_GATE(GATE_STGEN,		RCC_APB5ENSETR, 20),
+	CFG_GATE(GATE_BSEC,		RCC_APB5ENSETR, 16),
+	CFG_GATE(GATE_IWDG1,		RCC_APB5ENSETR, 15),
+	CFG_GATE(GATE_TZPC,		RCC_APB5ENSETR, 13),
+	CFG_GATE(GATE_TZC2,		RCC_APB5ENSETR, 12),
+	CFG_GATE(GATE_TZC1,		RCC_APB5ENSETR, 11),
+	CFG_GATE(GATE_RTCAPB,		RCC_APB5ENSETR, 8),
+	CFG_GATE(GATE_USART1,		RCC_APB5ENSETR, 4),
+	CFG_GATE(GATE_I2C6,		RCC_APB5ENSETR, 3),
+	CFG_GATE(GATE_I2C4,		RCC_APB5ENSETR, 2),
+	CFG_GATE(GATE_SPI6,		RCC_APB5ENSETR, 0),
+	CFG_GATE(GATE_SDMMC3,		RCC_AHB2ENSETR, 16),
+	CFG_GATE(GATE_USBO,		RCC_AHB2ENSETR, 8),
+	CFG_GATE(GATE_ADC12,		RCC_AHB2ENSETR, 5),
+	CFG_GATE(GATE_DMAMUX,		RCC_AHB2ENSETR, 2),
+	CFG_GATE(GATE_DMA2,		RCC_AHB2ENSETR, 1),
+	CFG_GATE(GATE_DMA1,		RCC_AHB2ENSETR, 0),
+	CFG_GATE(GATE_IPCC,		RCC_AHB3ENSETR, 12),
+	CFG_GATE(GATE_HSEM,		RCC_AHB3ENSETR, 11),
+	CFG_GATE(GATE_CRC2,		RCC_AHB3ENSETR, 7),
+	CFG_GATE(GATE_RNG2,		RCC_AHB3ENSETR, 6),
+	CFG_GATE(GATE_HASH2,		RCC_AHB3ENSETR, 5),
+	CFG_GATE(GATE_CRYP2,		RCC_AHB3ENSETR, 4),
+	CFG_GATE(GATE_DCMI,		RCC_AHB3ENSETR, 0),
+	CFG_GATE(GATE_GPIOK,		RCC_AHB4ENSETR, 10),
+	CFG_GATE(GATE_GPIOJ,		RCC_AHB4ENSETR, 9),
+	CFG_GATE(GATE_GPIOI,		RCC_AHB4ENSETR, 8),
+	CFG_GATE(GATE_GPIOH,		RCC_AHB4ENSETR, 7),
+	CFG_GATE(GATE_GPIOG,		RCC_AHB4ENSETR, 6),
+	CFG_GATE(GATE_GPIOF,		RCC_AHB4ENSETR, 5),
+	CFG_GATE(GATE_GPIOE,		RCC_AHB4ENSETR, 4),
+	CFG_GATE(GATE_GPIOD,		RCC_AHB4ENSETR, 3),
+	CFG_GATE(GATE_GPIOC,		RCC_AHB4ENSETR, 2),
+	CFG_GATE(GATE_GPIOB,		RCC_AHB4ENSETR, 1),
+	CFG_GATE(GATE_GPIOA,		RCC_AHB4ENSETR, 0),
+	CFG_GATE(GATE_BKPSRAM,		RCC_AHB5ENSETR, 8),
+	CFG_GATE(GATE_RNG1,		RCC_AHB5ENSETR, 6),
+	CFG_GATE(GATE_HASH1,		RCC_AHB5ENSETR, 5),
+	CFG_GATE(GATE_CRYP1,		RCC_AHB5ENSETR, 4),
+	CFG_GATE(GATE_GPIOZ,		RCC_AHB5ENSETR, 0),
+	CFG_GATE(GATE_USBH,		RCC_AHB6ENSETR, 24),
+	CFG_GATE(GATE_CRC1,		RCC_AHB6ENSETR, 20),
+	CFG_GATE(GATE_SDMMC2,		RCC_AHB6ENSETR, 17),
+	CFG_GATE(GATE_SDMMC1,		RCC_AHB6ENSETR, 16),
+	CFG_GATE(GATE_QSPI,		RCC_AHB6ENSETR, 14),
+	CFG_GATE(GATE_FMC,		RCC_AHB6ENSETR, 12),
+	CFG_GATE(GATE_ETHMAC,		RCC_AHB6ENSETR, 10),
+	CFG_GATE(GATE_ETHRX,		RCC_AHB6ENSETR, 9),
+	CFG_GATE(GATE_ETHTX,		RCC_AHB6ENSETR, 8),
+	CFG_GATE(GATE_ETHCK,		RCC_AHB6ENSETR, 7),
+	CFG_GATE(GATE_GPU,		RCC_AHB6ENSETR, 5),
+	CFG_GATE(GATE_MDMA,		RCC_AHB6ENSETR, 0),
+	CFG_GATE(GATE_ETHSTP,		RCC_AHB6LPENSETR, 11),
+};
+
+enum enum_mux_cfg {
+	MUX_MPU,
+	MUX_AXI,
+	MUX_MCU,
+	MUX_PLL12,
+	MUX_PLL3,
+	MUX_PLL4,
+	MUX_CKPER,
+	MUX_RTC,
+	MUX_SDMMC12,
+	MUX_SDMMC3,
+	MUX_FMC,
+	MUX_QSPI,
+	MUX_RNG1,
+	MUX_RNG2,
+	MUX_USBPHY,
+	MUX_USBO,
+	MUX_STGEN,
+	MUX_SPDIF,
+	MUX_SPI1,
+	MUX_SPI23,
+	MUX_SPI45,
+	MUX_SPI6,
+	MUX_CEC,
+	MUX_I2C12,
+	MUX_I2C35,
+	MUX_I2C46,
+	MUX_LPTIM1,
+	MUX_LPTIM23,
+	MUX_LPTIM45,
+	MUX_USART1,
+	MUX_UART24,
+	MUX_UART35,
+	MUX_USART6,
+	MUX_UART78,
+	MUX_SAI1,
+	MUX_SAI2,
+	MUX_SAI3,
+	MUX_SAI4,
+	MUX_DSI,
+	MUX_FDCAN,
+	MUX_ADC12,
+	MUX_ETHCK,
+	MUX_MCO1,
+	MUX_MCO2,
+};
+
+struct cs_mux_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	u32	*table;
+};
+
+#define CFG_MUX(_id, _offset, _shift, _witdh, _flags)\
+	[_id] = {\
+		.offset = (_offset),\
+		.shift = (_shift),\
+		.width = (_witdh),\
+		.flags = (_flags),\
+	}
+
+static const struct cs_mux_cfg stm32mp15_muxes[] = {
+	CFG_MUX(MUX_PLL12,	RCC_RCK12SELR, 0, 2, 0),
+	CFG_MUX(MUX_PLL3,	RCC_RCK3SELR, 0, 2, 0),
+	CFG_MUX(MUX_PLL4,	RCC_RCK4SELR, 0, 2, 0),
+	CFG_MUX(MUX_CKPER,	RCC_CPERCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_MPU,	RCC_MPCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_AXI,	RCC_ASSCKSELR, 0, 3, 0),
+	CFG_MUX(MUX_MCU,	RCC_MSSCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_RTC,	RCC_BDCR, 16, 2, 0),
+	CFG_MUX(MUX_SDMMC12,	RCC_SDMMC12CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI23,	RCC_SPI2S23CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI45,	RCC_SPI2S45CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_I2C12,	RCC_I2C12CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_I2C35,	RCC_I2C35CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_LPTIM23,	RCC_LPTIM23CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_LPTIM45,	RCC_LPTIM45CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART24,	RCC_UART24CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART35,	RCC_UART35CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART78,	RCC_UART78CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI1,	RCC_SAI1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_ETHCK,	RCC_ETHCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_I2C46,	RCC_I2C46CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_RNG2,	RCC_RNG2CKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SDMMC3,	RCC_SDMMC3CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_FMC,	RCC_FMCCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_QSPI,	RCC_QSPICKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USBPHY,	RCC_USBCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USBO,	RCC_USBCKSELR, 4, 1, 0),
+	CFG_MUX(MUX_SPDIF,	RCC_SPDIFCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SPI1,	RCC_SPI2S1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_CEC,	RCC_CECCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_LPTIM1,	RCC_LPTIM1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_USART6,	RCC_UART6CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_FDCAN,	RCC_FDCANCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SAI2,	RCC_SAI2CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI3,	RCC_SAI3CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI4,	RCC_SAI4CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_ADC12,	RCC_ADCCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_DSI,	RCC_DSICKSELR, 0, 1, 0),
+	CFG_MUX(MUX_RNG1,	RCC_RNG1CKSELR, 0, 2, 0),
+	CFG_MUX(MUX_STGEN,	RCC_STGENCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USART1,	RCC_UART1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI6,	RCC_SPI6CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_MCO1,	RCC_MCO1CFGR, 0, 3, 0),
+	CFG_MUX(MUX_MCO2,	RCC_MCO2CFGR, 0, 3, 0),
+};
+
+enum enum_div_cfg {
+	DIV_PLL1DIVP,
+	DIV_PLL2DIVP,
+	DIV_PLL2DIVQ,
+	DIV_PLL2DIVR,
+	DIV_PLL3DIVP,
+	DIV_PLL3DIVQ,
+	DIV_PLL3DIVR,
+	DIV_PLL4DIVP,
+	DIV_PLL4DIVQ,
+	DIV_PLL4DIVR,
+	DIV_MPU,
+	DIV_AXI,
+	DIV_MCU,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APB5,
+	DIV_RTC,
+	DIV_HSI,
+	DIV_MCO1,
+	DIV_MCO2,
+	DIV_TRACE,
+	DIV_ETHPTP,
+	DIV_NB
+};
+
+struct cs_div_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	const struct clk_div_table *table;
+};
+
+#define CFG_DIV(_id, _offset, _shift, _width, _flags, _table)\
+	[(_id)] = {\
+		.offset = (_offset),\
+		.shift = (_shift),\
+		.width = (_width),\
+		.flags = (_flags),\
+		.table = (_table),\
+	}
+
+static const struct cs_div_cfg stm32mp15_dividers[DIV_NB] = {
+	CFG_DIV(DIV_MPU,	RCC_MPCKDIVR, 0, 4, 0, NULL),
+	CFG_DIV(DIV_AXI,	RCC_AXIDIVR, 0, 3, 0, axi_div_table),
+	CFG_DIV(DIV_MCU,	RCC_MCUDIVR, 0, 4, 0, mcu_div_table),
+	CFG_DIV(DIV_APB1,	RCC_APB1DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB2,	RCC_APB2DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB3,	RCC_APB3DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB4,	RCC_APB4DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB5,	RCC_APB5DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_HSI,	RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL),
+	CFG_DIV(DIV_PLL1DIVP,	RCC_PLL1CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVP,	RCC_PLL2CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVQ,	RCC_PLL2CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVR,	RCC_PLL2CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVP,	RCC_PLL3CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVQ,	RCC_PLL3CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVR,	RCC_PLL3CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVP,	RCC_PLL4CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVQ,	RCC_PLL4CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVR,	RCC_PLL4CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_RTC,	RCC_RTCDIVR, 0, 6, 0, NULL),
+	CFG_DIV(DIV_MCO1,	RCC_MCO1CFGR, 4, 4, 0, NULL),
+	CFG_DIV(DIV_MCO2,	RCC_MCO2CFGR, 4, 4, 0, NULL),
+	CFG_DIV(DIV_TRACE,	RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table),
+	CFG_DIV(DIV_ETHPTP,	RCC_ETHCKSELR, 4, 4, 0, NULL),
+};
+
+struct clk_stm32_clock_data {
+	const struct cs_gate_cfg *gates;
+	const struct cs_mux_cfg *muxes;
+	const struct cs_div_cfg *dividers;
+};
+
+struct clock_summary {
+	struct clk_summary *clocks;
+	int nb_clocks;
+	void __iomem *base;
+	struct clk_stm32_clock_data *clock_data;
+};
+
+struct clk_summary {
+	const char *name;
+	unsigned long rate;
+	int enabled;
+	int nb_parents;
+	int gate_id;
+	int mux_id;
+	int div_id;
+	void *data;
+	unsigned long (*get_rate)(struct clock_summary *cs,
+				  struct clk_summary *c,
+				  unsigned long parent_rate);
+	const char * const *parent_names;
+};
+
+static u8 clk_stm32_get_parent_mux(void __iomem *base,
+				   struct clk_stm32_clock_data *data,
+				   u16 mux_id)
+{
+	const struct cs_mux_cfg *mux = &data->muxes[mux_id];
+	u32 mask = BIT(mux->width) - 1;
+	u32 val;
+
+	val = readl(base + mux->offset) >> mux->shift;
+	val &= mask;
+
+	return val;
+}
+
+static int clk_stm32_is_enabled_gate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 gate_id)
+{
+	const struct cs_gate_cfg *gate = &data->gates[gate_id];
+
+	return (readl(base + gate->offset) & BIT(gate->bit_idx)) != 0;
+}
+
+static unsigned int _get_table_div(const struct clk_div_table *table,
+				   unsigned int val)
+{
+	const struct clk_div_table *clkt;
+
+	for (clkt = table; clkt->div; clkt++)
+		if (clkt->val == val)
+			return clkt->div;
+	return 0;
+}
+
+static unsigned int _get_div(const struct clk_div_table *table,
+			     unsigned int val, unsigned long flags, u8 width)
+{
+	if (flags & CLK_DIVIDER_ONE_BASED)
+		return val;
+	if (flags & CLK_DIVIDER_POWER_OF_TWO)
+		return 1 << val;
+	if (table)
+		return _get_table_div(table, val);
+	return val + 1;
+}
+
+static unsigned long clk_stm32_get_rate_divider(void __iomem *base,
+						struct clk_stm32_clock_data *data,
+						u16 div_id,
+						unsigned long parent_rate)
+{
+	const struct cs_div_cfg *divider = &data->dividers[div_id];
+	unsigned int val;
+	unsigned int div;
+
+	val =  readl(base + divider->offset) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+	div = _get_div(divider->table, val, divider->flags, divider->width);
+
+	if (!div) {
+		WARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),
+		     "%d: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n", div_id);
+		return parent_rate;
+	}
+
+	return DIV_ROUND_UP_ULL((u64)parent_rate, div);
+}
+
+struct cs_pll {
+	u32 offset;
+};
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clock_summary *cs,
+							  struct clk_summary *c,
+							  unsigned long parent_rate)
+{
+	struct cs_pll *pll = (struct cs_pll *)c->data;
+	struct clk_pll_fractional_divider fracdiv;
+	struct clk_pll_fractional_divider *fd = &fracdiv;
+	void __iomem *reg;
+	u32 mmask;
+	u32 nmask;
+	u32 fmask;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	reg = cs->base + pll->offset;
+	fd->mreg = reg + PLL_DIVMN_OFFSET;
+	fd->mshift = PLL_DIVM_SHIFT;
+	fd->mwidth = PLL_DIVM_WIDTH;
+	fd->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->nreg = reg + PLL_DIVMN_OFFSET;
+	fd->nshift = PLL_DIVN_SHIFT;
+	fd->nwidth = PLL_DIVN_WIDTH;
+	fd->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->freg = reg + PLL_FRAC_OFFSET;
+	fd->fshift = PLL_FRAC_SHIFT;
+	fd->fwidth = PLL_FRAC_WIDTH;
+
+	mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
+
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
+
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
+	}
+
+	return rate + frate;
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clock_summary *cs,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	return parent_rate / 2;
+}
+
+static unsigned long clk_summary_osc_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+static unsigned long clk_summary_div_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return clk_stm32_get_rate_divider(cs->base, cs->clock_data, c->div_id, parent_rate);
+}
+
+static unsigned long clk_summary_rtc_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	u8 parent;
+
+	parent = clk_stm32_get_parent_mux(cs->base, cs->clock_data, c->mux_id);
+	if (parent == HSE_RTC)
+		return clk_summary_div_recalc_rate(cs, c, parent_rate);
+
+	return parent_rate;
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = (struct cs_stm32_timer *)c->data;
+	void __iomem *rcc_base = cs->base;
+	u32 prescaler, timpre;
+
+	prescaler = readl(rcc_base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(rcc_base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_osc_recalc_rate,\
+}
+
+#define CS_DIV2(_name, _parent) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_MUX(_name, _parents, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.mux_id		= _mux,\
+	.gate_id	= NO_STM32_GATE,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEDIV(_name, _parent, _gate, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_COMPOSITE(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_RTC(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_rtc_recalc_rate,\
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static struct clk_summary stm32mp15_clock_summary[] = {
+	CS_OSC("ck_hsi", GATE_HSI),
+	CS_OSC("ck_csi", GATE_CSI),
+	CS_OSC("ck_lsi", GATE_LSI),
+	CS_OSC("ck_hse", GATE_HSE),
+	CS_OSC("ck_lse", GATE_LSE),
+	CS_OSC("ck_usbo_48m", NO_STM32_GATE),
+	CS_OSC("i2s_ckin", NO_STM32_GATE),
+	CS_DIV2("clk-hse-div2", "ck_hse"),
+	CS_MUX("ck_per", per_src, MUX_CKPER),
+
+	CS_PLL("pll1", ref12_parents, GATE_PLL1, MUX_PLL12, RCC_PLL1CR),
+	CS_GATEDIV("pll1_p", "pll1", GATE_PLL1_DIVP, DIV_PLL1DIVP),
+
+	CS_DIV("pll1_p_div", "pll1_p", DIV_MPU),
+
+	CS_PLL("pll2", ref12_parents, GATE_PLL2, MUX_PLL12, RCC_PLL2CR),
+	CS_GATEDIV("pll2_p", "pll2", GATE_PLL2_DIVP, DIV_PLL2DIVP),
+	CS_GATEDIV("pll2_q", "pll2", GATE_PLL2_DIVQ, DIV_PLL2DIVQ),
+	CS_GATEDIV("pll2_r", "pll2", GATE_PLL2_DIVR, DIV_PLL2DIVR),
+
+	CS_PLL("pll3", ref3_parents, GATE_PLL3, MUX_PLL3, RCC_PLL3CR),
+	CS_GATEDIV("pll3_p", "pll3", GATE_PLL3_DIVP, DIV_PLL3DIVP),
+	CS_GATEDIV("pll3_q", "pll3", GATE_PLL3_DIVQ, DIV_PLL3DIVQ),
+	CS_GATEDIV("pll3_r", "pll3", GATE_PLL3_DIVR, DIV_PLL3DIVR),
+
+	CS_PLL("pll4", ref4_parents, GATE_PLL4, MUX_PLL4, RCC_PLL4CR),
+	CS_GATEDIV("pll4_p", "pll4", GATE_PLL4_DIVP, DIV_PLL4DIVP),
+	CS_GATEDIV("pll4_q", "pll4", GATE_PLL4_DIVQ, DIV_PLL4DIVQ),
+	CS_GATEDIV("pll4_r", "pll4", GATE_PLL4_DIVR, DIV_PLL4DIVR),
+
+	CS_MUX("ck_mpu", cpu_src, MUX_MPU),
+	CS_COMPOSITE("ck_axi", axi_src, NO_STM32_GATE, MUX_AXI, DIV_AXI),
+	CS_COMPOSITE("ck_mcu", mcu_src, NO_STM32_GATE, MUX_MCU, DIV_MCU),
+
+	CS_DIV("pclk1", "ck_mcu", DIV_APB1),
+	CS_DIV("pclk2", "ck_mcu", DIV_APB2),
+	CS_DIV("pclk3", "ck_mcu", DIV_APB3),
+	CS_DIV("pclk4", "ck_axi", DIV_APB4),
+	CS_DIV("pclk5", "ck_axi", DIV_APB5),
+
+	CS_STM32_TIMER("ck1_tim", "pclk1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("ck2_tim", "pclk2", RCC_APB2DIVR, RCC_TIMG2PRER),
+
+	CS_GATE("tim2_k", "ck1_tim", GATE_TIM2),
+	CS_GATE("tim3_k", "ck1_tim", GATE_TIM3),
+	CS_GATE("tim4_k", "ck1_tim", GATE_TIM4),
+	CS_GATE("tim5_k", "ck1_tim", GATE_TIM5),
+	CS_GATE("tim6_k", "ck1_tim", GATE_TIM6),
+	CS_GATE("tim7_k", "ck1_tim", GATE_TIM7),
+	CS_GATE("tim12_k", "ck1_tim", GATE_TIM12),
+	CS_GATE("tim13_k", "ck1_tim", GATE_TIM13),
+	CS_GATE("tim14_k", "ck1_tim", GATE_TIM14),
+	CS_GATE("tim1_k", "ck2_tim", GATE_TIM1),
+	CS_GATE("tim8_k", "ck2_tim", GATE_TIM8),
+	CS_GATE("tim15_k", "ck2_tim", GATE_TIM15),
+	CS_GATE("tim16_k", "ck2_tim", GATE_TIM16),
+	CS_GATE("tim17_k", "ck2_tim", GATE_TIM17),
+
+	CS_GATE("tim2", "pclk1", GATE_TIM2),
+	CS_GATE("tim3", "pclk1", GATE_TIM3),
+	CS_GATE("tim4", "pclk1", GATE_TIM4),
+	CS_GATE("tim5", "pclk1", GATE_TIM5),
+	CS_GATE("tim6", "pclk1", GATE_TIM6),
+	CS_GATE("tim7", "pclk1", GATE_TIM7),
+	CS_GATE("tim12", "pclk1", GATE_TIM12),
+	CS_GATE("tim13", "pclk1", GATE_TIM13),
+	CS_GATE("tim14", "pclk1", GATE_TIM14),
+	CS_GATE("lptim1", "pclk1", GATE_LPTIM1),
+	CS_GATE("spi2", "pclk1", GATE_SPI2),
+	CS_GATE("spi3", "pclk1", GATE_SPI3),
+	CS_GATE("usart2", "pclk1", GATE_USART2),
+	CS_GATE("usart3", "pclk1", GATE_USART3),
+	CS_GATE("uart4", "pclk1", GATE_UART4),
+	CS_GATE("uart5", "pclk1", GATE_UART5),
+	CS_GATE("uart7", "pclk1", GATE_UART7),
+	CS_GATE("uart8", "pclk1", GATE_UART8),
+	CS_GATE("i2c1", "pclk1", GATE_I2C1),
+	CS_GATE("i2c2", "pclk1", GATE_I2C2),
+	CS_GATE("i2c3", "pclk1", GATE_I2C3),
+	CS_GATE("i2c5", "pclk1", GATE_I2C5),
+	CS_GATE("spdif", "pclk1", GATE_SPDIF),
+	CS_GATE("cec", "pclk1", GATE_CEC),
+	CS_GATE("dac12", "pclk1", GATE_DAC12),
+	CS_GATE("mdio", "pclk1", GATE_MDIO),
+	CS_GATE("tim1", "pclk2", GATE_TIM1),
+	CS_GATE("tim8", "pclk2", GATE_TIM8),
+	CS_GATE("tim15", "pclk2", GATE_TIM15),
+	CS_GATE("tim16", "pclk2", GATE_TIM16),
+	CS_GATE("tim17", "pclk2", GATE_TIM17),
+	CS_GATE("spi1", "pclk2", GATE_SPI1),
+	CS_GATE("spi4", "pclk2", GATE_SPI4),
+	CS_GATE("spi5", "pclk2", GATE_SPI5),
+	CS_GATE("usart6", "pclk2", GATE_USART6),
+	CS_GATE("sai1", "pclk2", GATE_SAI1),
+	CS_GATE("sai2", "pclk2", GATE_SAI2),
+	CS_GATE("sai3", "pclk2", GATE_SAI3),
+	CS_GATE("dfsdm", "pclk2", GATE_DFSDM),
+	CS_GATE("fdcan", "pclk2", GATE_FDCAN),
+	CS_GATE("lptim2", "pclk3", GATE_LPTIM2),
+	CS_GATE("lptim3", "pclk3", GATE_LPTIM3),
+	CS_GATE("lptim4", "pclk3", GATE_LPTIM4),
+	CS_GATE("lptim5", "pclk3", GATE_LPTIM5),
+	CS_GATE("sai4", "pclk3", GATE_SAI4),
+	CS_GATE("syscfg", "pclk3", GATE_SYSCFG),
+	CS_GATE("vref", "pclk3", GATE_VREF),
+	CS_GATE("tmpsens", "pclk3", GATE_TMPSENS),
+	CS_GATE("pmbctrl", "pclk3", GATE_PMBCTRL),
+	CS_GATE("hdp", "pclk3", GATE_HDP),
+	CS_GATE("ltdc", "pclk4", GATE_LTDC),
+	CS_GATE("dsi", "pclk4", GATE_DSI),
+	CS_GATE("iwdg2", "pclk4", GATE_IWDG2),
+	CS_GATE("usbphy", "pclk4", GATE_USBPHY),
+	CS_GATE("stgenro", "pclk4", GATE_STGENRO),
+	CS_GATE("spi6", "pclk5", GATE_SPI6),
+	CS_GATE("i2c4", "pclk5", GATE_I2C4),
+	CS_GATE("i2c6", "pclk5", GATE_I2C6),
+	CS_GATE("usart1", "pclk5", GATE_USART1),
+	CS_GATE("rtcapb", "pclk5", GATE_RTCAPB),
+	CS_GATE("tzc1", "ck_axi", GATE_TZC1),
+	CS_GATE("tzc2", "ck_axi", GATE_TZC2),
+	CS_GATE("tzpc", "pclk5", GATE_TZPC),
+	CS_GATE("iwdg1", "pclk5", GATE_IWDG1),
+	CS_GATE("bsec", "pclk5", GATE_BSEC),
+	CS_GATE("stgen", "pclk5", GATE_STGEN),
+	CS_GATE("dma1", "ck_mcu", GATE_DMA1),
+	CS_GATE("dma2", "ck_mcu", GATE_DMA2),
+	CS_GATE("dmamux", "ck_mcu", GATE_DMAMUX),
+	CS_GATE("adc12", "ck_mcu", GATE_ADC12),
+	CS_GATE("usbo", "ck_mcu", GATE_USBO),
+	CS_GATE("sdmmc3", "ck_mcu", GATE_SDMMC3),
+	CS_GATE("dcmi", "ck_mcu", GATE_DCMI),
+	CS_GATE("cryp2", "ck_mcu", GATE_CRYP2),
+	CS_GATE("hash2", "ck_mcu", GATE_HASH2),
+	CS_GATE("rng2", "ck_mcu", GATE_RNG2),
+	CS_GATE("crc2", "ck_mcu", GATE_CRC2),
+	CS_GATE("hsem", "ck_mcu", GATE_HSEM),
+	CS_GATE("ipcc", "ck_mcu", GATE_IPCC),
+	CS_GATE("gpioa", "ck_mcu", GATE_GPIOA),
+	CS_GATE("gpiob", "ck_mcu", GATE_GPIOB),
+	CS_GATE("gpioc", "ck_mcu", GATE_GPIOC),
+	CS_GATE("gpiod", "ck_mcu", GATE_GPIOD),
+	CS_GATE("gpioe", "ck_mcu", GATE_GPIOE),
+	CS_GATE("gpiof", "ck_mcu", GATE_GPIOF),
+	CS_GATE("gpiog", "ck_mcu", GATE_GPIOG),
+	CS_GATE("gpioh", "ck_mcu", GATE_GPIOH),
+	CS_GATE("gpioi", "ck_mcu", GATE_GPIOI),
+	CS_GATE("gpioj", "ck_mcu", GATE_GPIOJ),
+	CS_GATE("gpiok", "ck_mcu", GATE_GPIOK),
+	CS_GATE("gpioz", "ck_axi", GATE_GPIOZ),
+	CS_GATE("cryp1", "ck_axi", GATE_CRYP1),
+	CS_GATE("hash1", "ck_axi", GATE_HASH1),
+	CS_GATE("rng1", "ck_axi", GATE_RNG1),
+	CS_GATE("bkpsram", "ck_axi", GATE_BKPSRAM),
+	CS_GATE("mdma", "ck_axi", GATE_MDMA),
+	CS_GATE("gpu", "ck_axi", GATE_GPU),
+	CS_GATE("ethtx", "ck_axi", GATE_ETHTX),
+	CS_GATE("ethrx", "ck_axi", GATE_ETHRX),
+	CS_GATE("ethmac", "ck_axi", GATE_ETHMAC),
+	CS_GATE("crc1", "ck_axi", GATE_CRC1),
+	CS_GATE("usbh", "ck_axi", GATE_USBH),
+	CS_GATE("ethstp", "ck_axi", GATE_ETHSTP),
+	CS_GATE("ddrperfm", "pclk4", GATE_DDRPERFM),
+
+	CS_GATEMUX("sdmmc1_k", sdmmc12_src, GATE_SDMMC1, MUX_SDMMC12),
+	CS_GATEMUX("sdmmc2_k", sdmmc12_src, GATE_SDMMC2, MUX_SDMMC12),
+	CS_GATEMUX("sdmmc3_k", sdmmc3_src, GATE_SDMMC3, MUX_SDMMC3),
+	CS_GATEMUX("fmc_k", fmc_src, GATE_FMC, MUX_FMC),
+	CS_GATEMUX("qspi_k", qspi_src, GATE_QSPI, MUX_QSPI),
+	CS_GATEMUX("rng1_k", rng_src, GATE_RNG1, MUX_RNG1),
+	CS_GATEMUX("rng2_k", rng_src, GATE_RNG2, MUX_RNG2),
+	CS_GATEMUX("usbphy_k", usbphy_src, GATE_USBPHY, MUX_USBPHY),
+	CS_GATEMUX("stgen_k", stgen_src, GATE_STGEN, MUX_STGEN),
+	CS_GATEMUX("spdif_k", spdif_src, GATE_SPDIF, MUX_SPDIF),
+	CS_GATEMUX("spi1_k", spi123_src, GATE_SPI1, MUX_SPI1),
+	CS_GATEMUX("spi2_k", spi123_src, GATE_SPI2, MUX_SPI23),
+	CS_GATEMUX("spi3_k", spi123_src, GATE_SPI3, MUX_SPI23),
+	CS_GATEMUX("spi4_k", spi45_src, GATE_SPI4, MUX_SPI45),
+	CS_GATEMUX("spi5_k", spi45_src, GATE_SPI5, MUX_SPI45),
+	CS_GATEMUX("spi6_k", spi6_src, GATE_SPI6, MUX_SPI6),
+	CS_GATEMUX("cec_k", cec_src, GATE_CEC, MUX_CEC),
+	CS_GATEMUX("i2c1_k", i2c12_src, GATE_I2C1, MUX_I2C12),
+	CS_GATEMUX("i2c2_k", i2c12_src, GATE_I2C2, MUX_I2C12),
+	CS_GATEMUX("i2c3_k", i2c35_src, GATE_I2C3, MUX_I2C35),
+	CS_GATEMUX("i2c5_k", i2c35_src, GATE_I2C5, MUX_I2C35),
+	CS_GATEMUX("i2c4_k", i2c46_src, GATE_I2C4, MUX_I2C46),
+	CS_GATEMUX("i2c6_k", i2c46_src, GATE_I2C6, MUX_I2C46),
+	CS_GATEMUX("lptim1_k", lptim1_src, GATE_LPTIM1, MUX_LPTIM1),
+	CS_GATEMUX("lptim2_k", lptim23_src, GATE_LPTIM2, MUX_LPTIM23),
+	CS_GATEMUX("lptim3_k", lptim23_src, GATE_LPTIM3, MUX_LPTIM23),
+	CS_GATEMUX("lptim4_k", lptim45_src, GATE_LPTIM4, MUX_LPTIM45),
+	CS_GATEMUX("lptim5_k", lptim45_src, GATE_LPTIM5, MUX_LPTIM45),
+	CS_GATEMUX("usart1_k", usart1_src, GATE_USART1, MUX_USART1),
+	CS_GATEMUX("usart2_k", usart234578_src, GATE_USART2, MUX_UART24),
+	CS_GATEMUX("usart3_k", usart234578_src, GATE_USART3, MUX_UART35),
+	CS_GATEMUX("uart4_k", usart234578_src, GATE_UART4, MUX_UART24),
+	CS_GATEMUX("uart5_k", usart234578_src, GATE_UART5, MUX_UART35),
+	CS_GATEMUX("uart6_k", usart6_src, GATE_USART6, MUX_USART6),
+	CS_GATEMUX("uart7_k", usart234578_src, GATE_UART7, MUX_UART78),
+	CS_GATEMUX("uart8_k", usart234578_src, GATE_UART8, MUX_UART78),
+	CS_GATEMUX("fdcan_k", fdcan_src, GATE_FDCAN, MUX_FDCAN),
+	CS_GATEMUX("sai1_k", sai_src, GATE_SAI1, MUX_SAI1),
+	CS_GATEMUX("sai2_k", sai2_src, GATE_SAI2, MUX_SAI2),
+	CS_GATEMUX("sai3_k", sai_src, GATE_SAI3, MUX_SAI3),
+	CS_GATEMUX("sai4_k", sai_src, GATE_SAI4, MUX_SAI4),
+	CS_GATEMUX("adc12_k", adc12_src, GATE_ADC12, MUX_ADC12),
+	CS_GATEMUX("dsi_k", dsi_src, GATE_DSI, MUX_DSI),
+	CS_GATEMUX("adfsdm_k", sai_src, GATE_ADFSDM, MUX_SAI1),
+	CS_GATEMUX("usbo_k", usbo_src, GATE_USBO, MUX_USBO),
+	CS_GATEMUX("ethck_k", eth_src, GATE_ETHCK, MUX_ETHCK),
+
+	CS_GATE("dfsdm_k", "ck_mcu", GATE_DFSDM),
+	CS_GATE("dsi_px", "pll4_q", GATE_DSI),
+	CS_GATE("ltdc_px", "pll4_q", GATE_LTDC),
+	CS_GATE("gpu_k", "pll2_q", GATE_GPU),
+	CS_GATE("dac12_k", "ck_lsi", GATE_DAC12),
+
+	CS_COMPOSITE("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1, DIV_MCO1),
+	CS_COMPOSITE("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2, DIV_MCO2),
+	CS_GATE("ck_sys_dbg", "ck_axi", GATE_DBGCK),
+
+	CS_COMPOSITE("ethptp_k", eth_src, NO_STM32_GATE, MUX_ETHCK, DIV_ETHPTP),
+
+	CS_RTC("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC, DIV_RTC),
+
+	CS_GATEDIV("ck_trace", "ck_axi", GATE_TRACECK, DIV_TRACE),
+};
+
+static void rcc_summary_show_one(struct seq_file *s, struct clk_summary *c,
+				 int level)
+{
+	char enabled;
+
+	seq_printf(s, "%*s%-*s %11lu ",
+		   level * 3 + 1, "",
+		   30 - level * 3,
+		   c->name,
+		   c->rate
+		);
+
+	switch (c->enabled) {
+	case 0:
+		enabled = 'N';
+		break;
+	case 1:
+		enabled = 'Y';
+		break;
+	default:
+		enabled = '?';
+		break;
+	}
+
+	seq_printf(s, " %9c\n", enabled);
+}
+
+static int clock_summary_clk_is_enabled(struct clock_summary *cs,
+					struct clk_summary *c)
+{
+	return clk_stm32_is_enabled_gate(cs->base, cs->clock_data, c->gate_id);
+}
+
+static const char *clock_summary_get_parent_name(struct clock_summary *cs,
+						 struct clk_summary *c)
+{
+	int id = 0;
+
+	if (c->nb_parents == 0)
+		return NULL;
+
+	if (c->nb_parents > 1)
+		id = clk_stm32_get_parent_mux(cs->base, cs->clock_data, c->mux_id);
+
+	return c->parent_names[id];
+}
+
+static void rcc_summary_show_subtree(struct seq_file *s, struct clk_summary *c,
+				     unsigned long parent_rate, int level)
+{
+	struct clock_summary *cs = (struct clock_summary *)s->private;
+	int i;
+
+	if (c->get_rate)
+		c->rate = c->get_rate(cs, c, parent_rate);
+	else
+		c->rate = parent_rate;
+
+	c->enabled = -1;
+	if (c->gate_id != NO_STM32_GATE)
+		c->enabled = clock_summary_clk_is_enabled(cs, c);
+
+	rcc_summary_show_one(s, c, level);
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *child = &cs->clocks[i];
+		const char *parent_name = clock_summary_get_parent_name(cs, child);
+
+		if (!parent_name)
+			continue;
+
+		if (!strcmp(c->name, parent_name))
+			rcc_summary_show_subtree(s, child, c->rate, level + 1);
+	}
+}
+
+static int rcc_summary_show(struct seq_file *s, void *data)
+{
+	struct clock_summary *cs = (struct clock_summary *)s->private;
+	int i;
+
+	seq_puts(s, "                                              hardware\n");
+	seq_puts(s, "   clock                               rate     enable\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *c = &cs->clocks[i];
+
+		if (c->nb_parents == 0)
+			rcc_summary_show_subtree(s, c, 0, 0);
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(rcc_summary);
+
+struct clk_stm32_clock_data stm32mp15_clock_data = {
+	.gates		= stm32mp15_gates,
+	.muxes		= stm32mp15_muxes,
+	.dividers	= stm32mp15_dividers,
+};
+
+static struct clock_summary clock_summary_mp15 = {
+	.clocks		= stm32mp15_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp15_clock_summary),
+	.clock_data	= &stm32mp15_clock_data,
+};
+
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base)
+{
+	struct dentry *rootdir = debugfs_lookup("clk", NULL);
+
+	clock_summary_mp15.base = base;
+
+	debugfs_create_file("stm32_clk_summary", 0444, rootdir,
+			    &clock_summary_mp15, &rcc_summary_fops);
+}
+
+#else
+
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base)
+{
+}
+
+#endif
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 57b83665e5c3..ba7d28d852a7 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1934,6 +1934,7 @@ static void clk_reparent(struct clk_core *core, struct clk_core *new_parent)
 	core->parent = new_parent;
 }
 
+static const struct clk_ops clk_nodrv_ops;
 static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 					   struct clk_core *parent)
 {
@@ -1962,7 +1963,8 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 
 	/* enable old_parent & parent if CLK_OPS_PARENT_ENABLE is set */
 	if (core->flags & CLK_OPS_PARENT_ENABLE) {
-		clk_core_prepare_enable(old_parent);
+		if (old_parent && old_parent->ops != &clk_nodrv_ops)
+			clk_core_prepare_enable(old_parent);
 		clk_core_prepare_enable(parent);
 	}
 
@@ -1996,7 +1998,8 @@ static void __clk_set_parent_after(struct clk_core *core,
 	/* re-balance ref counting if CLK_OPS_PARENT_ENABLE is set */
 	if (core->flags & CLK_OPS_PARENT_ENABLE) {
 		clk_core_disable_unprepare(parent);
-		clk_core_disable_unprepare(old_parent);
+		if (old_parent && old_parent->ops != &clk_nodrv_ops)
+			clk_core_disable_unprepare(old_parent);
 	}
 }
 
diff --git a/drivers/clk/stm32/clk-stm32-core.c b/drivers/clk/stm32/clk-stm32-core.c
index 45a279e73779..3933649337d9 100644
--- a/drivers/clk/stm32/clk-stm32-core.c
+++ b/drivers/clk/stm32/clk-stm32-core.c
@@ -19,6 +19,9 @@
 
 static DEFINE_SPINLOCK(rlock);
 
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data);
+
 static int stm32_rcc_clock_init(struct device *dev,
 				const struct of_device_id *match,
 				void __iomem *base)
@@ -28,6 +31,7 @@ static int stm32_rcc_clock_init(struct device *dev,
 	struct device_node *np = dev_of_node(dev);
 	struct clk_hw **hws;
 	int n, max_binding;
+	int ret;
 
 	max_binding =  data->maxbinding;
 
@@ -35,6 +39,8 @@ static int stm32_rcc_clock_init(struct device *dev,
 	if (!clk_data)
 		return -ENOMEM;
 
+	data->clock_data->base = base;
+
 	clk_data->num = max_binding;
 
 	hws = clk_data->hws;
@@ -64,7 +70,14 @@ static int stm32_rcc_clock_init(struct device *dev,
 			hws[cfg_clock->id] = hw;
 	}
 
-	return of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);
+	ret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	if (data->clock_summary)
+		stm32_clk_summary_debugfs_create(dev, data);
+
+	return ret;
 }
 
 int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
@@ -96,9 +109,9 @@ int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
 	return 0;
 }
 
-static u8 stm32_mux_get_parent(void __iomem *base,
-			       struct clk_stm32_clock_data *data,
-			       u16 mux_id)
+u8 stm32_mux_get_parent(void __iomem *base,
+			struct clk_stm32_clock_data *data,
+			u16 mux_id)
 {
 	const struct stm32_mux_cfg *mux = &data->muxes[mux_id];
 	u32 mask = BIT(mux->width) - 1;
@@ -202,10 +215,10 @@ static unsigned int _get_div(const struct clk_div_table *table,
 	return val + 1;
 }
 
-static unsigned long stm32_divider_get_rate(void __iomem *base,
-					    struct clk_stm32_clock_data *data,
-					    u16 div_id,
-					    unsigned long parent_rate)
+unsigned long stm32_divider_get_rate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 div_id,
+				     unsigned long parent_rate)
 {
 	const struct stm32_div_cfg *divider = &data->dividers[div_id];
 	unsigned int val;
@@ -693,3 +706,133 @@ struct clk_hw *clk_stm32_composite_register(struct device *dev,
 
 	return hw;
 }
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+static void rcc_summary_show_one(struct seq_file *s, struct clk_summary *c,
+				 int level)
+{
+	char enabled;
+
+	seq_printf(s, "%*s%-*s %11lu ",
+		   level * 3 + 1, "",
+		   30 - level * 3,
+		   c->name,
+		   c->rate
+		);
+
+	switch (c->enabled) {
+	case 0:
+		enabled = 'N';
+		break;
+	case 1:
+		enabled = 'Y';
+		break;
+	default:
+		enabled = '?';
+		break;
+	}
+
+	seq_printf(s, " %9c\n", enabled);
+}
+
+static int clock_summary_clk_is_enabled(struct clk_stm32_clock_data *data,
+					struct clk_summary *c)
+{
+	return stm32_gate_is_enabled(data->base, data, c->gate_id);
+}
+
+static const char *clock_summary_get_parent_name(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c)
+{
+	int id = 0;
+
+	if (c->nb_parents == 0)
+		return NULL;
+
+	if (c->nb_parents > 1) {
+		if (c->get_parent)
+			id = c->get_parent(data, c);
+		else
+			id = stm32_mux_get_parent(data->base, data, c->mux_id);
+	}
+
+	return c->parent_names[id];
+}
+
+static void rcc_summary_show_subtree(struct seq_file *s, struct clk_summary *c,
+				     unsigned long parent_rate, int level)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clk_stm32_clock_data *data = match_data->clock_data;
+	struct clock_summary *cs = match_data->clock_summary;
+	int i;
+
+	if (c->get_rate)
+		c->rate = c->get_rate(data, c, parent_rate);
+	else
+		c->rate = parent_rate;
+
+	c->enabled = -1;
+
+	if (c->is_enabled)
+		c->enabled = c->is_enabled(data, c);
+
+	else if (c->gate_id != NO_STM32_GATE)
+		c->enabled = clock_summary_clk_is_enabled(data, c);
+
+	rcc_summary_show_one(s, c, level);
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *child = &cs->clocks[i];
+		const char *parent_name = clock_summary_get_parent_name(data, child);
+
+		if (!parent_name)
+			continue;
+
+		if (!strcmp(c->name, parent_name))
+			rcc_summary_show_subtree(s, child, c->rate, level + 1);
+	}
+}
+
+static int rcc_summary_show(struct seq_file *s, void *data)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clock_summary *cs = match_data->clock_summary;
+
+	int i;
+
+	seq_puts(s, "                                              hardware\n");
+	seq_puts(s, "   clock                               rate     enable\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *c = &cs->clocks[i];
+
+		if (c->nb_parents == 0)
+			rcc_summary_show_subtree(s, c, 0, 0);
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(rcc_summary);
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+{
+	struct dentry *rootdir = debugfs_lookup("clk", NULL);
+
+	debugfs_create_file("stm32_clk_summary", 0444, rootdir, (void *)data, &rcc_summary_fops);
+}
+
+#else
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+
+{
+}
+#endif
diff --git a/drivers/clk/stm32/clk-stm32-core.h b/drivers/clk/stm32/clk-stm32-core.h
index 76cffda02308..39b91a8c3419 100644
--- a/drivers/clk/stm32/clk-stm32-core.h
+++ b/drivers/clk/stm32/clk-stm32-core.h
@@ -57,6 +57,7 @@ struct clock_config {
 };
 
 struct clk_stm32_clock_data {
+	void __iomem			*base;
 	u16 *gate_cpt;
 	const struct stm32_gate_cfg	*gates;
 	const struct stm32_mux_cfg	*muxes;
@@ -64,6 +65,31 @@ struct clk_stm32_clock_data {
 	struct clk_hw *(*is_multi_mux)(struct clk_hw *hw);
 };
 
+struct clock_summary {
+	struct clk_summary *clocks;
+	int nb_clocks;
+};
+
+struct clk_summary {
+	const char *name;
+	unsigned long rate;
+	int enabled;
+	int nb_parents;
+	int gate_id;
+	int mux_id;
+	int div_id;
+	void *data;
+
+	bool (*is_enabled)(struct clk_stm32_clock_data *data,
+			   struct clk_summary *c);
+	u8 (*get_parent)(struct clk_stm32_clock_data *data,
+			 struct clk_summary *c);
+	unsigned long (*get_rate)(struct clk_stm32_clock_data *data,
+				  struct clk_summary *c,
+				  unsigned long parent_rate);
+	const char * const *parent_names;
+};
+
 struct stm32_rcc_match_data {
 	struct clk_hw_onecell_data	*hw_clks;
 	unsigned int			num_clocks;
@@ -71,9 +97,12 @@ struct stm32_rcc_match_data {
 	unsigned int			maxbinding;
 	struct clk_stm32_clock_data	*clock_data;
 	u32				clear_offset;
+
 	int (*check_security)(void __iomem *base,
 			      const struct clock_config *cfg);
 	int (*multi_mux)(void __iomem *base, const struct clock_config *cfg);
+	u32				reset_us;
+	struct clock_summary		*clock_summary;
 };
 
 int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
@@ -82,6 +111,15 @@ int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
 int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
 		   void __iomem *base);
 
+unsigned long stm32_divider_get_rate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 div_id,
+				     unsigned long parent_rate);
+
+u8 stm32_mux_get_parent(void __iomem *base,
+			struct clk_stm32_clock_data *data,
+			u16 mux_id);
+
 /* MUX define */
 #define MUX_NO_RDY		0xFF
 #define MUX_SAFE		BIT(7)
diff --git a/drivers/clk/stm32/clk-stm32mp13.c b/drivers/clk/stm32/clk-stm32mp13.c
index 1192eee8abe4..7a5e83457da9 100644
--- a/drivers/clk/stm32/clk-stm32mp13.c
+++ b/drivers/clk/stm32/clk-stm32mp13.c
@@ -16,6 +16,53 @@
 
 /* STM32 Gates definition */
 enum enum_gate_cfg {
+	GATE_LSE,
+	GATE_LSE_RDY,
+	GATE_LSI,
+	GATE_LSI_RDY,
+	GATE_HSI,
+	GATE_HSI_RDY,
+	GATE_CSI,
+	GATE_CSI_RDY,
+	GATE_HSE,
+	GATE_HSE_RDY,
+	GATE_PLL1,
+	GATE_PLL1_RDY,
+	GATE_PLL2,
+	GATE_PLL2_RDY,
+	GATE_PLL3,
+	GATE_PLL3_RDY,
+	GATE_PLL4,
+	GATE_PLL4_RDY,
+	GATE_HSIDIVRDY,
+	GATE_MPUSRCRDY,
+	GATE_AXISSRCRDY,
+	GATE_MCUSSRCRDY,
+	GATE_PLL12SRCRDY,
+	GATE_PLL3SRCRDY,
+	GATE_PLL4SRCRDY,
+	GATE_MPUDIVRDY,
+	GATE_AXIDIVRDY,
+	GATE_MLAHBDIVRDY,
+	GATE_APB1DIVRDY,
+	GATE_APB2DIVRDY,
+	GATE_APB3DIVRDY,
+	GATE_APB4DIVRDY,
+	GATE_APB5DIVRDY,
+	GATE_APB6DIVRDY,
+	GATE_RTCCK,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
 	GATE_MCO1,
 	GATE_MCO2,
 	GATE_DBGCK,
@@ -149,6 +196,53 @@ enum enum_gate_cfg {
 	_CFG_GATE(_id, _offset, _bit_idx, RCC_CLR_OFFSET)
 
 static struct stm32_gate_cfg stm32mp13_gates[] = {
+	CFG_GATE(GATE_LSE,		RCC_BDCR,		0),
+	CFG_GATE(GATE_LSE_RDY,		RCC_BDCR,		2),
+	CFG_GATE(GATE_RTCCK,		RCC_BDCR,		20),
+	CFG_GATE(GATE_LSI,		RCC_RDLSICR,		0),
+	CFG_GATE(GATE_LSI_RDY,		RCC_RDLSICR,		1),
+	CFG_GATE_SETCLR(GATE_HSI,	RCC_OCENSETR,		0),
+	CFG_GATE(GATE_HSI_RDY,		RCC_OCRDYR,		0),
+	CFG_GATE_SETCLR(GATE_CSI,	RCC_OCENSETR,		4),
+	CFG_GATE(GATE_CSI_RDY,		RCC_OCRDYR,		4),
+	CFG_GATE_SETCLR(GATE_HSE,	RCC_OCENSETR,		8),
+	CFG_GATE(GATE_HSE_RDY,		RCC_OCRDYR,		8),
+	CFG_GATE(GATE_HSIDIVRDY,	RCC_OCRDYR,		2),
+	CFG_GATE(GATE_MPUSRCRDY,	RCC_MPCKSELR,		31),
+	CFG_GATE(GATE_AXISSRCRDY,	RCC_ASSCKSELR,		31),
+	CFG_GATE(GATE_MCUSSRCRDY,	RCC_MSSCKSELR,		31),
+	CFG_GATE(GATE_PLL12SRCRDY,	RCC_RCK12SELR,		31),
+	CFG_GATE(GATE_PLL3SRCRDY,	RCC_RCK3SELR,		31),
+	CFG_GATE(GATE_PLL4SRCRDY,	RCC_RCK4SELR,		31),
+	CFG_GATE(GATE_MPUDIVRDY,	RCC_MPCKDIVR,		31),
+	CFG_GATE(GATE_AXIDIVRDY,	RCC_AXIDIVR,		31),
+	CFG_GATE(GATE_MLAHBDIVRDY,	RCC_MLAHBDIVR,		31),
+	CFG_GATE(GATE_APB1DIVRDY,	RCC_APB1DIVR,		31),
+	CFG_GATE(GATE_APB2DIVRDY,	RCC_APB2DIVR,		31),
+	CFG_GATE(GATE_APB3DIVRDY,	RCC_APB3DIVR,		31),
+	CFG_GATE(GATE_APB4DIVRDY,	RCC_APB4DIVR,		31),
+	CFG_GATE(GATE_APB5DIVRDY,	RCC_APB5DIVR,		31),
+	CFG_GATE(GATE_APB6DIVRDY,	RCC_APB6DIVR,		31),
+	CFG_GATE(GATE_PLL1,		RCC_PLL1CR,		0),
+	CFG_GATE(GATE_PLL1_RDY,		RCC_PLL1CR,		1),
+	CFG_GATE(GATE_PLL1_DIVP,	RCC_PLL1CR,		4),
+	CFG_GATE(GATE_PLL1_DIVQ,	RCC_PLL1CR,		5),
+	CFG_GATE(GATE_PLL1_DIVR,	RCC_PLL1CR,		6),
+	CFG_GATE(GATE_PLL2,		RCC_PLL2CR,		0),
+	CFG_GATE(GATE_PLL2_RDY,		RCC_PLL2CR,		1),
+	CFG_GATE(GATE_PLL2_DIVP,	RCC_PLL2CR,		4),
+	CFG_GATE(GATE_PLL2_DIVQ,	RCC_PLL2CR,		5),
+	CFG_GATE(GATE_PLL2_DIVR,	RCC_PLL2CR,		6),
+	CFG_GATE(GATE_PLL3,		RCC_PLL3CR,		0),
+	CFG_GATE(GATE_PLL3_RDY,		RCC_PLL3CR,		1),
+	CFG_GATE(GATE_PLL3_DIVP,	RCC_PLL3CR,		4),
+	CFG_GATE(GATE_PLL3_DIVQ,	RCC_PLL3CR,		5),
+	CFG_GATE(GATE_PLL3_DIVR,	RCC_PLL3CR,		6),
+	CFG_GATE(GATE_PLL4,		RCC_PLL4CR,		0),
+	CFG_GATE(GATE_PLL4_RDY,		RCC_PLL4CR,		1),
+	CFG_GATE(GATE_PLL4_DIVP,	RCC_PLL4CR,		4),
+	CFG_GATE(GATE_PLL4_DIVQ,	RCC_PLL4CR,		5),
+	CFG_GATE(GATE_PLL4_DIVR,	RCC_PLL4CR,		6),
 	CFG_GATE(GATE_MCO1,		RCC_MCO1CFGR,		12),
 	CFG_GATE(GATE_MCO2,		RCC_MCO2CFGR,		12),
 	CFG_GATE(GATE_DBGCK,		RCC_DBGCFGR,		8),
@@ -269,6 +363,25 @@ static struct stm32_gate_cfg stm32mp13_gates[] = {
 
 /* STM32 Divivers definition */
 enum enum_div_cfg {
+	DIV_PLL1DIVP,
+	DIV_PLL2DIVP,
+	DIV_PLL2DIVQ,
+	DIV_PLL2DIVR,
+	DIV_PLL3DIVP,
+	DIV_PLL3DIVQ,
+	DIV_PLL3DIVR,
+	DIV_PLL4DIVP,
+	DIV_PLL4DIVQ,
+	DIV_PLL4DIVR,
+	DIV_MPU,
+	DIV_AXI,
+	DIV_MLAHB,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APB5,
+	DIV_APB6,
 	DIV_RTC,
 	DIV_HSI,
 	DIV_MCO1,
@@ -279,6 +392,26 @@ enum enum_div_cfg {
 	DIV_NB
 };
 
+static const struct clk_div_table axi_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },
+	{ 4, 4 }, { 5, 4 }, { 6, 4 }, { 7, 4 },
+	{ 0 },
+};
+
+static const struct clk_div_table mlahb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 32 }, { 6, 64 }, { 7, 128 },
+	{ 8, 256 }, { 9, 512 }, { 10, 512}, { 11, 512 },
+	{ 12, 512 }, { 13, 512 }, { 14, 512}, { 15, 512 },
+	{ 0 },
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
+	{ 0 },
+};
+
 static const struct clk_div_table ck_trace_div_table[] = {
 	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
 	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
@@ -296,6 +429,28 @@ static const struct clk_div_table ck_trace_div_table[] = {
 	}
 
 static const struct stm32_div_cfg stm32mp13_dividers[DIV_NB] = {
+	CFG_DIV(DIV_MPU, RCC_MPCKDIVR, 0, 4, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_AXI, RCC_AXIDIVR, 0, 3, 0, axi_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_MLAHB, RCC_MLAHBDIVR, 0, 4, 0, mlahb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB1, RCC_APB1DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB2, RCC_APB2DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB3, RCC_APB3DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB4, RCC_APB4DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB5, RCC_APB5DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB6, RCC_APB6DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_HSI, RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL, DIV_NO_RDY),
+
+	CFG_DIV(DIV_PLL1DIVP, RCC_PLL1CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVP, RCC_PLL2CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVQ, RCC_PLL2CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVR, RCC_PLL2CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVP, RCC_PLL3CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVQ, RCC_PLL3CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVR, RCC_PLL3CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVP, RCC_PLL4CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVQ, RCC_PLL4CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVR, RCC_PLL4CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+
 	CFG_DIV(DIV_RTC, RCC_RTCDIVR, 0, 6, 0, NULL, DIV_NO_RDY),
 	CFG_DIV(DIV_MCO1, RCC_MCO1CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
 	CFG_DIV(DIV_MCO2, RCC_MCO2CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
@@ -306,6 +461,14 @@ static const struct stm32_div_cfg stm32mp13_dividers[DIV_NB] = {
 
 /* STM32 Muxes definition */
 enum enum_mux_cfg {
+	MUX_MPU,
+	MUX_AXI,
+	MUX_MLAHB,
+	MUX_PLL12,
+	MUX_PLL3,
+	MUX_PLL4,
+	MUX_RTC,
+	MUX_CKPER,
 	MUX_ADC1,
 	MUX_ADC2,
 	MUX_DCMIPP,
@@ -363,6 +526,14 @@ enum enum_mux_cfg {
 	_CFG_MUX(_id, _offset, _shift, _witdh, MUX_NO_RDY, MUX_SAFE)
 
 static const struct stm32_mux_cfg stm32mp13_muxes[] = {
+	CFG_MUX(MUX_MPU,	RCC_MPCKSELR,		0, 2),
+	CFG_MUX(MUX_AXI,	RCC_ASSCKSELR,		0, 3),
+	CFG_MUX(MUX_MLAHB,	RCC_MSSCKSELR,		0, 2),
+	CFG_MUX(MUX_PLL12,	RCC_RCK12SELR,		0, 2),
+	CFG_MUX(MUX_PLL3,	RCC_RCK3SELR,		0, 2),
+	CFG_MUX(MUX_PLL4,	RCC_RCK4SELR,		0, 2),
+	CFG_MUX(MUX_CKPER,	RCC_CPERCKSELR,		0, 2),
+	CFG_MUX(MUX_RTC,	RCC_BDCR,		16, 2),
 	CFG_MUX(MUX_I2C12,	RCC_I2C12CKSELR,	0, 3),
 	CFG_MUX(MUX_LPTIM45,	RCC_LPTIM45CKSELR,	0, 3),
 	CFG_MUX(MUX_SPI23,	RCC_SPI2S23CKSELR,	0, 3),
@@ -581,7 +752,7 @@ static const char * const qspi_src[] = {
 };
 
 static const char * const rng1_src[] = {
-	"ck_csi", "pll4_r", "ck_lse", "ck_lsi"
+	"ck_csi", "pll4_r", "reserved", "ck_lsi"
 };
 
 static const char * const saes_src[] = {
@@ -712,6 +883,16 @@ static struct clk_stm32_gate tim17_k = {
 };
 
 /* Peripheral clocks */
+static struct clk_stm32_gate spi2 = {
+	.gate_id = GATE_SPI2,
+	.hw.init = CLK_HW_INIT("spi2", "pclk1", &clk_stm32_gate_ops, 0),
+};
+
+static struct clk_stm32_gate spi3 = {
+	.gate_id = GATE_SPI3,
+	.hw.init = CLK_HW_INIT("spi3", "pclk1", &clk_stm32_gate_ops, 0),
+};
+
 static struct clk_stm32_gate sai1 = {
 	.gate_id = GATE_SAI1,
 	.hw.init = CLK_HW_INIT("sai1", "pclk2", &clk_stm32_gate_ops, 0),
@@ -722,6 +903,11 @@ static struct clk_stm32_gate sai2 = {
 	.hw.init = CLK_HW_INIT("sai2", "pclk2", &clk_stm32_gate_ops, 0),
 };
 
+static struct clk_stm32_gate spi1 = {
+	.gate_id = GATE_SPI1,
+	.hw.init = CLK_HW_INIT("spi1", "pclk2", &clk_stm32_gate_ops, 0),
+};
+
 static struct clk_stm32_gate syscfg = {
 	.gate_id = GATE_SYSCFG,
 	.hw.init = CLK_HW_INIT("syscfg", "pclk3", &clk_stm32_gate_ops, 0),
@@ -827,6 +1013,16 @@ static struct clk_stm32_gate bsec = {
 	.hw.init = CLK_HW_INIT("bsec", "pclk5", &clk_stm32_gate_ops, 0),
 };
 
+static struct clk_stm32_gate spi4 = {
+	.gate_id = GATE_SPI4,
+	.hw.init = CLK_HW_INIT("spi4", "pclk6", &clk_stm32_gate_ops, 0),
+};
+
+static struct clk_stm32_gate spi5 = {
+	.gate_id = GATE_SPI5,
+	.hw.init = CLK_HW_INIT("spi5", "pclk6", &clk_stm32_gate_ops, 0),
+};
+
 static struct clk_stm32_gate dma1 = {
 	.gate_id = GATE_DMA1,
 	.hw.init = CLK_HW_INIT("dma1", "ck_mlahb", &clk_stm32_gate_ops, 0),
@@ -1351,6 +1547,11 @@ static const struct clock_config stm32mp13_clock_cfg[] = {
 	STM32_GATE_CFG(TIM17_K, tim17_k, SECF_TIM17),
 
 	/* Peripheral clocks */
+	STM32_GATE_CFG(SPI1, spi1, SECF_NONE),
+	STM32_GATE_CFG(SPI2, spi2, SECF_NONE),
+	STM32_GATE_CFG(SPI3, spi3, SECF_NONE),
+	STM32_GATE_CFG(SPI4, spi4, SECF_SPI4),
+	STM32_GATE_CFG(SPI5, spi5, SECF_SPI5),
 	STM32_GATE_CFG(SAI1, sai1, SECF_NONE),
 	STM32_GATE_CFG(SAI2, sai2, SECF_NONE),
 	STM32_GATE_CFG(SYSCFG, syscfg, SECF_NONE),
@@ -1503,6 +1704,10 @@ static struct clk_hw *stm32mp13_is_multi_mux(struct clk_hw *hw)
 
 static u16 stm32mp13_cpt_gate[GATE_NB];
 
+#ifdef CONFIG_DEBUG_FS
+static struct clock_summary clock_summary_mp13;
+#endif
+
 static struct clk_stm32_clock_data stm32mp13_clock_data = {
 	.gate_cpt	= stm32mp13_cpt_gate,
 	.gates		= stm32mp13_gates,
@@ -1518,6 +1723,10 @@ static const struct stm32_rcc_match_data stm32mp13_data = {
 	.check_security = &stm32mp13_clock_is_provided_by_secure,
 	.maxbinding	= STM32MP1_LAST_CLK,
 	.clear_offset	= RCC_CLR_OFFSET,
+	.reset_us	= 2,
+#ifdef CONFIG_DEBUG_FS
+	.clock_summary	= &clock_summary_mp13,
+#endif
 };
 
 static const struct of_device_id stm32mp13_match_data[] = {
@@ -1618,3 +1827,505 @@ static int __init stm32mp13_clocks_init(void)
 	return platform_driver_register(&stm32mp13_rcc_clocks_driver);
 }
 core_initcall(stm32mp13_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+/* STM32 PLL */
+struct clk_pll_fractional_divider {
+	struct clk_hw hw;
+	void __iomem *mreg;
+	u8 mshift;
+	u8 mwidth;
+	u8 mflags;
+	void __iomem *nreg;
+	u8 nshift;
+	u8 nwidth;
+	u8 nflags;
+	void __iomem *freg;
+	u8 fshift;
+	u8 fwidth;
+
+	/* lock pll enable/disable registers */
+	spinlock_t *lock;
+};
+
+struct cs_pll {
+	u32 offset;
+};
+
+#define PLL_BIT_ON		0
+#define PLL_BIT_RDY		1
+#define PLL_MUX_SHIFT		0
+#define PLL_MUX_MASK		3
+#define PLL_DIVMN_OFFSET	4
+#define PLL_DIVM_SHIFT		16
+#define PLL_DIVM_WIDTH		6
+#define PLL_DIVN_SHIFT		0
+#define PLL_DIVN_WIDTH		9
+#define PLL_FRAC_OFFSET		0xC
+#define PLL_FRAC_SHIFT		3
+#define PLL_FRAC_WIDTH		13
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clk_stm32_clock_data *data,
+							  struct clk_summary *c,
+							  unsigned long parent_rate)
+{
+	struct cs_pll *pll = (struct cs_pll *)c->data;
+	struct clk_pll_fractional_divider fracdiv;
+	struct clk_pll_fractional_divider *fd = &fracdiv;
+	void __iomem *reg;
+	u32 mmask;
+	u32 nmask;
+	u32 fmask;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	reg = data->base + pll->offset;
+	fd->mreg = reg + PLL_DIVMN_OFFSET;
+	fd->mshift = PLL_DIVM_SHIFT;
+	fd->mwidth = PLL_DIVM_WIDTH;
+	fd->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->nreg = reg + PLL_DIVMN_OFFSET;
+	fd->nshift = PLL_DIVN_SHIFT;
+	fd->nwidth = PLL_DIVN_WIDTH;
+	fd->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->freg = reg + PLL_FRAC_OFFSET;
+	fd->fshift = PLL_FRAC_SHIFT;
+	fd->fwidth = PLL_FRAC_WIDTH;
+
+	mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
+
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
+
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
+	}
+
+	return rate + frate;
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clk_stm32_clock_data *data,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	return parent_rate / 2;
+}
+
+static unsigned long clk_summary_osc_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+static unsigned long clk_summary_div_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return stm32_divider_get_rate(data->base, data, c->div_id, parent_rate);
+}
+
+/* The divider of RTC clock concerns only ck_hse clock */
+#define HSE_RTC 3
+
+static unsigned long clk_summary_rtc_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	u8 parent;
+
+	parent = stm32_mux_get_parent(data->base, data, c->mux_id);
+	if (parent == HSE_RTC)
+		return clk_summary_div_recalc_rate(data, c, parent_rate);
+
+	return parent_rate;
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+#define APB_DIV_MASK 0x07
+#define TIM_PRE_MASK 0x01
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = (struct cs_stm32_timer *)c->data;
+	void __iomem *rcc_base = data->base;
+	u32 prescaler, timpre;
+
+	prescaler = readl(rcc_base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(rcc_base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define PARENT(_parent)	((const char *[]) { _parent})
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_osc_recalc_rate,\
+}
+
+#define CS_DIV2(_name, _parent) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_MUX(_name, _parents, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.mux_id		= _mux,\
+	.gate_id	= NO_STM32_GATE,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEDIV(_name, _parent, _gate, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_COMPOSITE(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_RTC(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 4,\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_rtc_recalc_rate,\
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static const char * const ref12_parents[] = {
+	"ck_hsi", "ck_hse"
+};
+
+static const char * const ref3_parents[] = {
+	"ck_hsi", "ck_hse", "ck_csi"
+};
+
+static const char * const ref4_parents[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "i2s_ckin"
+};
+
+static const char * const cpu_src[] = {
+	"ck_hsi", "ck_hse", "pll1_p", "pll1_p_div"
+};
+
+static const char * const axi_src[] = {
+	"ck_hsi", "ck_hse", "pll2_p"
+};
+
+static const char * const mlahb_src[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "pll3_p"
+};
+
+static const char * const per_src[] = {
+	"ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const rtc_src[] = {
+	"off", "ck_lse", "ck_lsi", "ck_hse"
+};
+
+static struct clk_summary stm32mp13_clock_summary[] = {
+	CS_OSC("ck_hsi", GATE_HSI),
+	CS_OSC("ck_csi", GATE_CSI),
+	CS_OSC("ck_lsi", GATE_LSI),
+	CS_OSC("ck_hse", GATE_HSE),
+	CS_OSC("ck_lse", GATE_LSE),
+	CS_OSC("ck_usbo_48m", NO_STM32_GATE),
+	CS_DIV2("clk-hse-div2", "ck_hse"),
+
+	CS_PLL("pll1", ref12_parents, GATE_PLL1, MUX_PLL12, RCC_PLL1CR),
+
+	CS_GATEDIV("pll1_p", "pll1", GATE_PLL1_DIVP, DIV_PLL1DIVP),
+
+	CS_DIV("pll1_p_div", "pll1_p", DIV_MPU),
+
+	CS_PLL("pll2", ref12_parents, GATE_PLL2, MUX_PLL12, RCC_PLL2CR),
+	CS_GATEDIV("pll2_p", "pll2", GATE_PLL2_DIVP, DIV_PLL2DIVP),
+	CS_GATEDIV("pll2_q", "pll2", GATE_PLL2_DIVQ, DIV_PLL2DIVQ),
+	CS_GATEDIV("pll2_r", "pll2", GATE_PLL2_DIVR, DIV_PLL2DIVR),
+
+	CS_PLL("pll3", ref3_parents, GATE_PLL3, MUX_PLL3, RCC_PLL3CR),
+	CS_GATEDIV("pll3_p", "pll3", GATE_PLL3_DIVP, DIV_PLL3DIVP),
+	CS_GATEDIV("pll3_q", "pll3", GATE_PLL3_DIVQ, DIV_PLL3DIVQ),
+	CS_GATEDIV("pll3_r", "pll3", GATE_PLL3_DIVR, DIV_PLL3DIVR),
+
+	CS_PLL("pll4", ref4_parents, GATE_PLL4, MUX_PLL4, RCC_PLL4CR),
+	CS_GATEDIV("pll4_p", "pll4", GATE_PLL4_DIVP, DIV_PLL4DIVP),
+	CS_GATEDIV("pll4_q", "pll4", GATE_PLL4_DIVQ, DIV_PLL4DIVQ),
+	CS_GATEDIV("pll4_r", "pll4", GATE_PLL4_DIVR, DIV_PLL4DIVR),
+
+	CS_MUX("ck_mpu", cpu_src, MUX_MPU),
+	CS_MUX("ck_axi", axi_src, MUX_AXI),
+	CS_MUX("ck_mlahb", mlahb_src, MUX_MLAHB),
+	CS_MUX("ck_per", per_src, MUX_CKPER),
+
+	CS_DIV("pclk1", "ck_mlahb", DIV_APB1),
+	CS_DIV("pclk2", "ck_mlahb", DIV_APB2),
+	CS_DIV("pclk3", "ck_mlahb", DIV_APB3),
+	CS_DIV("pclk4", "ck_axi", DIV_APB4),
+	CS_DIV("pclk5", "ck_axi", DIV_APB5),
+	CS_DIV("pclk6", "ck_mlahb", DIV_APB6),
+
+	CS_STM32_TIMER("timg1_ck", "pclk1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("timg2_ck", "pclk2", RCC_APB2DIVR, RCC_TIMG2PRER),
+	CS_STM32_TIMER("timg3_ck", "pclk1", RCC_APB6DIVR, RCC_TIMG3PRER),
+
+	CS_GATE("tim2_k", "timg1_ck", GATE_TIM2),
+	CS_GATE("tim3_k", "timg1_ck", GATE_TIM3),
+	CS_GATE("tim4_k", "timg1_ck", GATE_TIM4),
+	CS_GATE("tim5_k", "timg1_ck", GATE_TIM5),
+	CS_GATE("tim6_k", "timg1_ck", GATE_TIM6),
+	CS_GATE("tim7_k", "timg1_ck", GATE_TIM7),
+	CS_GATE("tim1_k", "timg2_ck", GATE_TIM1),
+	CS_GATE("tim8_k", "timg2_ck", GATE_TIM8),
+	CS_GATE("tim12_k", "timg3_ck", GATE_TIM12),
+	CS_GATE("tim13_k", "timg3_ck", GATE_TIM13),
+	CS_GATE("tim14_k", "timg3_ck", GATE_TIM14),
+	CS_GATE("tim15_k", "timg3_ck", GATE_TIM15),
+	CS_GATE("tim16_k", "timg3_ck", GATE_TIM16),
+	CS_GATE("tim17_k", "timg3_ck", GATE_TIM17),
+
+	CS_GATE("spi2", "pclk1", GATE_SPI2),
+	CS_GATE("spi3", "pclk1", GATE_SPI3),
+
+	CS_GATE("sai1", "pclk2", GATE_SAI1),
+	CS_GATE("sai2", "pclk2", GATE_SAI2),
+	CS_GATE("spi1", "pclk2", GATE_SPI1),
+
+	CS_GATE("syscfg", "pclk3", GATE_SYSCFG),
+	CS_GATE("vref", "pclk3", GATE_VREF),
+	CS_GATE("dts", "pclk3", GATE_DTS),
+	CS_GATE("pmbctrl", "pclk3", GATE_PMBCTRL),
+	CS_GATE("hdp", "pclk3", GATE_HDP),
+
+	CS_GATE("iwdg2", "pclk4", GATE_IWDG2APB),
+	CS_GATE("stgenro", "pclk4", GATE_STGENRO),
+	CS_GATE("gpioa", "pclk4", GATE_GPIOA),
+	CS_GATE("gpiob", "pclk4", GATE_GPIOB),
+	CS_GATE("gpioc", "pclk4", GATE_GPIOC),
+	CS_GATE("gpiod", "pclk4", GATE_GPIOD),
+	CS_GATE("gpioe", "pclk4", GATE_GPIOE),
+	CS_GATE("gpiof", "pclk4", GATE_GPIOF),
+	CS_GATE("gpiog", "pclk4", GATE_GPIOG),
+	CS_GATE("gpioh", "pclk4", GATE_GPIOH),
+	CS_GATE("gpioi", "pclk4", GATE_GPIOI),
+	CS_GATE("tsc", "pclk4", GATE_TSC),
+	CS_GATE("ddrperfm", "pclk4", GATE_DDRPERFM),
+
+	CS_GATE("tzpc", "pclk5", GATE_TZC),
+	CS_GATE("iwdg1", "pclk5", GATE_IWDG1APB),
+	CS_GATE("bsec", "pclk5", GATE_BSEC),
+
+	CS_GATE("spi4", "pclk6", GATE_SPI4),
+	CS_GATE("spi5", "pclk6", GATE_SPI5),
+
+	CS_GATE("dma1", "ck_mlahb", GATE_DMA1),
+	CS_GATE("dma2", "ck_mlahb", GATE_DMA2),
+	CS_GATE("dmamux1", "ck_mlahb", GATE_DMAMUX1),
+	CS_GATE("dma3", "ck_mlahb", GATE_DMA3),
+	CS_GATE("dmamux2", "ck_mlahb", GATE_DMAMUX2),
+	CS_GATE("adc1", "ck_mlahb", GATE_ADC1),
+	CS_GATE("adc2", "ck_mlahb", GATE_ADC2),
+
+	CS_GATE("pka", "ck_axi", GATE_PKA),
+	CS_GATE("cryp1", "ck_axi", GATE_CRYP1),
+	CS_GATE("hash1", "ck_axi", GATE_HASH1),
+	CS_GATE("bkpsram", "ck_axi", GATE_BKPSRAM),
+	CS_GATE("mdma", "ck_axi", GATE_MDMA),
+	CS_GATE("eth1tx", "ck_axi", GATE_ETH1TX),
+	CS_GATE("eth1rx", "ck_axi", GATE_ETH1RX),
+	CS_GATE("eth1mac", "ck_axi", GATE_ETH1MAC),
+	CS_GATE("eth2tx", "ck_axi", GATE_ETH2TX),
+	CS_GATE("eth2rx", "ck_axi", GATE_ETH2RX),
+	CS_GATE("eth2mac", "ck_axi", GATE_ETH2MAC),
+	CS_GATE("crc1", "ck_axi", GATE_CRC1),
+	CS_GATE("usbh", "ck_axi", GATE_USBH),
+	CS_GATE("eth1stp", "ck_axi", GATE_ETH1STP),
+	CS_GATE("eth2stp", "ck_axi", GATE_ETH2STP),
+
+	CS_GATEMUX("sdmmc1_k", sdmmc12_src, GATE_SDMMC1, MUX_SDMMC1),
+	CS_GATEMUX("sdmmc2_k", sdmmc12_src, GATE_SDMMC2, MUX_SDMMC2),
+	CS_GATEMUX("fmc_k", fmc_src, GATE_FMC, MUX_FMC),
+	CS_GATEMUX("qspi_k", qspi_src, GATE_QSPI, MUX_QSPI),
+	CS_GATEMUX("spi2_k", spi123_src, GATE_SPI2, MUX_SPI23),
+	CS_GATEMUX("spi3_k", spi123_src, GATE_SPI3, MUX_SPI23),
+	CS_GATEMUX("i2c1_k", i2c12_src, GATE_I2C1, MUX_I2C12),
+	CS_GATEMUX("i2c2_k", i2c12_src, GATE_I2C2, MUX_I2C12),
+	CS_GATEMUX("lptim4_k", lptim45_src, GATE_LPTIM4, MUX_LPTIM45),
+	CS_GATEMUX("lptim5_k", lptim45_src, GATE_LPTIM5, MUX_LPTIM45),
+	CS_GATEMUX("usart3_k", usart34578_src, GATE_USART3, MUX_UART35),
+	CS_GATEMUX("uart5_k", usart34578_src, GATE_UART5, MUX_UART35),
+	CS_GATEMUX("uart7_k", usart34578_src, GATE_UART7, MUX_UART78),
+	CS_GATEMUX("uart8_k", usart34578_src, GATE_UART8, MUX_UART78),
+	CS_GATEMUX("sai1_k", sai1_src, GATE_SAI1, MUX_SAI1),
+	CS_GATEMUX("adfsdm_k", sai1_src, GATE_ADFSDM, MUX_SAI1),
+	CS_GATEMUX("sai2_k", sai2_src, GATE_SAI2, MUX_SAI2),
+	CS_GATEMUX("adc1_k", adc12_src, GATE_ADC1, MUX_ADC1),
+	CS_GATEMUX("adc2_k", adc12_src, GATE_ADC2, MUX_ADC2),
+	CS_GATEMUX("rng1_k", rng1_src, GATE_RNG1, MUX_RNG1),
+	CS_GATEMUX("usbphy_k", usbphy_src, GATE_USBPHY, MUX_USBPHY),
+	CS_GATEMUX("stgen_k", stgen_src, GATE_STGENC, MUX_STGEN),
+	CS_GATEMUX("spdif_k", spdif_src, GATE_SPDIF, MUX_SPDIF),
+	CS_GATEMUX("spi1_k", spi123_src, GATE_SPI1, MUX_SPI1),
+	CS_GATEMUX("spi4_k", spi4_src, GATE_SPI4, MUX_SPI4),
+	CS_GATEMUX("spi5_k", spi5_src, GATE_SPI5, MUX_SPI5),
+	CS_GATEMUX("i2c3_k", i2c345_src, GATE_I2C3, MUX_I2C3),
+	CS_GATEMUX("i2c4_k", i2c345_src, GATE_I2C4, MUX_I2C4),
+	CS_GATEMUX("i2c5_k", i2c345_src, GATE_I2C5, MUX_I2C5),
+	CS_GATEMUX("lptim1_k", lptim1_src, GATE_LPTIM1, MUX_LPTIM1),
+	CS_GATEMUX("lptim2_k", lptim23_src, GATE_LPTIM2, MUX_LPTIM2),
+	CS_GATEMUX("lptim3_k", lptim23_src, GATE_LPTIM3, MUX_LPTIM3),
+	CS_GATEMUX("usart1_k", usart12_src, GATE_USART1, MUX_UART1),
+	CS_GATEMUX("usart2_k", usart12_src, GATE_USART2, MUX_UART2),
+	CS_GATEMUX("uart4_k", usart34578_src, GATE_UART4, MUX_UART4),
+	CS_GATEMUX("uart6_k", usart6_src, GATE_USART6, MUX_UART6),
+	CS_GATEMUX("fdcan_k", fdcan_src, GATE_FDCAN, MUX_FDCAN),
+	CS_GATEMUX("dcmipp_k", dcmipp_src, GATE_DCMIPP, MUX_DCMIPP),
+	CS_GATEMUX("usbo_k", usbo_src, GATE_USBO, MUX_USBO),
+	CS_GATEMUX("eth1ck_k", eth12_src, GATE_ETH1CK, MUX_ETH1),
+	CS_GATEMUX("eth2ck_k", eth12_src, GATE_ETH2CK, MUX_ETH2),
+	CS_GATEMUX("saes_k", saes_src, GATE_SAES, MUX_SAES),
+	CS_GATE("dfsdm_k", "ck_mlahb", GATE_DFSDM),
+	CS_GATE("ltdc_px", "pll4_q", GATE_LTDC),
+	CS_COMPOSITE("eth1ptp_k", eth12_src, NO_STM32_GATE, MUX_ETH1, DIV_ETH1PTP),
+	CS_COMPOSITE("eth2ptp_k", eth12_src, NO_STM32_GATE, MUX_ETH2, DIV_ETH2PTP),
+	CS_COMPOSITE("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1, DIV_MCO1),
+	CS_COMPOSITE("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2, DIV_MCO2),
+	CS_GATE("ck_sys_dbg", "ck_axi", GATE_DBGCK),
+	CS_GATEDIV("ck_trace", "ck_axi", GATE_TRACECK, DIV_TRACE),
+	CS_GATE("rtcapb", "pclk5", GATE_RTCAPB),
+	CS_RTC("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC, DIV_RTC),
+};
+
+static struct clock_summary clock_summary_mp13 = {
+	.clocks		= stm32mp13_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp13_clock_summary),
+};
+
+#endif
diff --git a/drivers/clk/stm32/reset-stm32.c b/drivers/clk/stm32/reset-stm32.c
index e89381528af9..76288f71fbc6 100644
--- a/drivers/clk/stm32/reset-stm32.c
+++ b/drivers/clk/stm32/reset-stm32.c
@@ -21,6 +21,7 @@ struct stm32_reset_data {
 	struct reset_controller_dev	rcdev;
 	void __iomem			*membase;
 	u32				clear_offset;
+	unsigned int			reset_us;
 };
 
 static inline struct stm32_reset_data *
@@ -93,9 +94,46 @@ static int stm32_reset_status(struct reset_controller_dev *rcdev,
 	return !!(reg & BIT(offset));
 }
 
+static int stm32_check_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int reg_width = sizeof(u32);
+	int bank = id / (reg_width * BITS_PER_BYTE);
+	int offset = id % (reg_width * BITS_PER_BYTE);
+	u32 reg;
+
+	return readl_poll_timeout(data->membase + (bank * reg_width), reg,
+				  !(reg & BIT(offset)), 10, 10 * USEC_PER_MSEC);
+}
+
+static int stm32_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int ret;
+
+	ret = stm32_reset_assert(rcdev, id);
+	if (ret)
+		return ret;
+
+	if (!data->reset_us)
+		usleep_range(data->reset_us, data->reset_us * 2);
+
+	ret = stm32_reset_deassert(rcdev, id);
+	if (ret)
+		return ret;
+
+	ret = stm32_check_deassert(rcdev, id);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static const struct reset_control_ops stm32_reset_ops = {
 	.assert		= stm32_reset_assert,
 	.deassert	= stm32_reset_deassert,
+	.reset		= stm32_reset,
 	.status		= stm32_reset_status,
 };
 
@@ -118,6 +156,7 @@ int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
 	reset_data->rcdev.of_node = dev_of_node(dev);
 	reset_data->rcdev.nr_resets = STM32_RESET_ID_MASK;
 	reset_data->clear_offset = data->clear_offset;
+	reset_data->reset_us = data->reset_us;
 
 	return reset_controller_register(&reset_data->rcdev);
 }
diff --git a/drivers/clocksource/timer-stm32-lp.c b/drivers/clocksource/timer-stm32-lp.c
index db2841d0beb8..90c10f378df2 100644
--- a/drivers/clocksource/timer-stm32-lp.c
+++ b/drivers/clocksource/timer-stm32-lp.c
@@ -168,9 +168,7 @@ static int stm32_clkevent_lp_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_bool(pdev->dev.parent->of_node, "wakeup-source")) {
-		ret = device_init_wakeup(&pdev->dev, true);
-		if (ret)
-			goto out_clk_disable;
+		device_set_wakeup_capable(&pdev->dev, true);
 
 		ret = dev_pm_set_wake_irq(&pdev->dev, irq);
 		if (ret)
diff --git a/include/dt-bindings/clock/stm32mp1-clks.h b/include/dt-bindings/clock/stm32mp1-clks.h
index 25e8cfd43459..2e23e0384b0a 100644
--- a/include/dt-bindings/clock/stm32mp1-clks.h
+++ b/include/dt-bindings/clock/stm32mp1-clks.h
@@ -179,6 +179,12 @@
 #define DAC12_K		168
 #define ETHPTP_K	169
 
+#define PCLK1		170
+#define PCLK2		171
+#define PCLK3		172
+#define PCLK4		173
+#define PCLK5		174
+
 /* PLL */
 #define PLL1		176
 #define PLL2		177
diff --git a/include/dt-bindings/clock/stm32mp13-clks.h b/include/dt-bindings/clock/stm32mp13-clks.h
index 02befd25edce..2a110340ff2f 100644
--- a/include/dt-bindings/clock/stm32mp13-clks.h
+++ b/include/dt-bindings/clock/stm32mp13-clks.h
@@ -193,7 +193,13 @@
 #define SAI1		160
 #define SAI2		161
 
-#define STM32MP1_LAST_CLK 162
+#define SPI1		162
+#define SPI2		163
+#define SPI3		164
+#define SPI4		165
+#define SPI5		166
+
+#define STM32MP1_LAST_CLK 167
 
 /* SCMI clock identifiers */
 #define CK_SCMI_HSE		0
-- 
2.17.1

