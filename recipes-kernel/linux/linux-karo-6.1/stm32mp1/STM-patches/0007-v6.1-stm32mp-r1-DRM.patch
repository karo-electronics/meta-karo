From 42f4d05e75315542465380c699ea78e4fc6c80e1 Mon Sep 17 00:00:00 2001
From: Romuald Jeanne <romuald.jeanne@st.com>
Date: Tue, 6 Jun 2023 09:32:42 +0200
Subject: [PATCH 07/24] v6.1-stm32mp-r1 DRM

Signed-off-by: Romuald Jeanne <romuald.jeanne@st.com>
---
 drivers/gpu/drm/bridge/sii902x.c              |  86 +++-
 drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c |  12 +-
 drivers/gpu/drm/drm_atomic_uapi.c             |   4 +
 drivers/gpu/drm/drm_connector.c               |  62 +++
 drivers/gpu/drm/panel/Kconfig                 |   9 +
 drivers/gpu/drm/panel/Makefile                |   1 +
 .../gpu/drm/panel/panel-orisetech-otm8009a.c  |  78 +++-
 drivers/gpu/drm/panel/panel-raydium-rm68200.c |  76 +++-
 drivers/gpu/drm/panel/panel-rocktech-hx8394.c | 429 ++++++++++++++++++
 drivers/gpu/drm/panel/panel-simple.c          |  16 +
 drivers/gpu/drm/stm/dw_mipi_dsi-stm.c         |  32 +-
 drivers/gpu/drm/stm/ltdc.c                    |  53 ++-
 drivers/video/backlight/gpio_backlight.c      |   7 +-
 include/drm/drm_connector.h                   |  14 +
 14 files changed, 818 insertions(+), 61 deletions(-)
 create mode 100644 drivers/gpu/drm/panel/panel-rocktech-hx8394.c

diff --git a/drivers/gpu/drm/bridge/sii902x.c b/drivers/gpu/drm/bridge/sii902x.c
index 878fb7d3732b..b78726f3bd28 100644
--- a/drivers/gpu/drm/bridge/sii902x.c
+++ b/drivers/gpu/drm/bridge/sii902x.c
@@ -17,6 +17,7 @@
 #include <linux/i2c.h>
 #include <linux/media-bus-format.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <linux/clk.h>
@@ -163,6 +164,11 @@
 
 #define SII902X_AUDIO_PORT_INDEX		3
 
+/* CEC device */
+#define SII902X_CEC_I2C_ADDR			0x30
+
+#define SII902X_CEC_SETUP			0x8e
+
 struct sii902x {
 	struct i2c_client *i2c;
 	struct regmap *regmap;
@@ -1003,6 +1009,13 @@ static int sii902x_init(struct sii902x *sii902x)
 {
 	struct device *dev = &sii902x->i2c->dev;
 	unsigned int status = 0;
+	unsigned char data[2] = { SII902X_CEC_SETUP, 0};
+	struct i2c_msg msg = {
+		.addr	= SII902X_CEC_I2C_ADDR << 1,
+		.flags	= 0,
+		.len	= 2,
+		.buf	= data,
+	};
 	u8 chipid[4];
 	int ret;
 
@@ -1025,13 +1038,22 @@ static int sii902x_init(struct sii902x *sii902x)
 		return -EINVAL;
 	}
 
+	/*
+	 * By default, CEC must be disabled to allow other CEC devives
+	 * to bypass the bridge.
+	 */
+	ret = i2c_transfer(sii902x->i2c->adapter, &msg, 1);
+	if (ret < 0)
+		dev_warn(&sii902x->i2c->dev, "Failed to disable CEC device!\n");
+
 	/* Clear all pending interrupts */
 	regmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);
 	regmap_write(sii902x->regmap, SII902X_INT_STATUS, status);
 
 	if (sii902x->i2c->irq > 0) {
-		regmap_write(sii902x->regmap, SII902X_INT_ENABLE,
-			     SII902X_HOTPLUG_EVENT);
+		regmap_update_bits(sii902x->regmap, SII902X_INT_ENABLE,
+				   SII902X_HOTPLUG_EVENT,
+				   SII902X_HOTPLUG_EVENT);
 
 		ret = devm_request_threaded_irq(dev, sii902x->i2c->irq, NULL,
 						sii902x_interrupt,
@@ -1156,6 +1178,65 @@ static void sii902x_remove(struct i2c_client *client)
 			       sii902x->supplies);
 }
 
+static int sii902x_pm_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sii902x *sii902x = i2c_get_clientdata(client);
+
+	DRM_DEBUG_DRIVER("\n");
+
+	if (sii902x->reset_gpio)
+		gpiod_set_value(sii902x->reset_gpio, 1);
+
+	regulator_bulk_disable(ARRAY_SIZE(sii902x->supplies),
+			       sii902x->supplies);
+
+	return 0;
+}
+
+static int sii902x_pm_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sii902x *sii902x = i2c_get_clientdata(client);
+	unsigned char data[2] = { SII902X_CEC_SETUP, 0};
+	struct i2c_msg msg = {
+		.addr	= SII902X_CEC_I2C_ADDR << 1,
+		.flags	= 0,
+		.len	= 2,
+		.buf	= data,
+	};
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(sii902x->supplies),
+				    sii902x->supplies);
+	if (ret) {
+		DRM_ERROR("regulator_bulk_enable failed\n");
+		return ret;
+	}
+
+	if (sii902x->reset_gpio)
+		gpiod_set_value(sii902x->reset_gpio, 0);
+
+	regmap_write(sii902x->regmap, SII902X_REG_TPI_RQB, 0x00);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0)
+		DRM_ERROR("Failed to disable CEC device!\n");
+
+	if (client->irq > 0)
+		regmap_update_bits(sii902x->regmap, SII902X_INT_ENABLE,
+				   SII902X_HOTPLUG_EVENT,
+				   SII902X_HOTPLUG_EVENT);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sii902x_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sii902x_pm_suspend, sii902x_pm_resume)
+};
+
 static const struct of_device_id sii902x_dt_ids[] = {
 	{ .compatible = "sil,sii9022", },
 	{ }
@@ -1174,6 +1255,7 @@ static struct i2c_driver sii902x_driver = {
 	.driver = {
 		.name = "sii902x",
 		.of_match_table = sii902x_dt_ids,
+		.pm = &sii902x_pm_ops,
 	},
 	.id_table = sii902x_i2c_ids,
 };
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
index b2efecf7d160..92f125996a5f 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
@@ -851,6 +851,9 @@ static void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 	const struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;
 
+	if (!pm_runtime_active(dsi->dev))
+		return;
+
 	/*
 	 * Switch to command mode before panel-bridge post_disable &
 	 * panel unprepare.
@@ -878,7 +881,6 @@ static void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,
 	}
 	dw_mipi_dsi_disable(dsi);
 
-	clk_disable_unprepare(dsi->pclk);
 	pm_runtime_put(dsi->dev);
 }
 
@@ -904,14 +906,11 @@ static void dw_mipi_dsi_mode_set(struct dw_mipi_dsi *dsi,
 	int ret;
 	u32 lanes = dw_mipi_dsi_get_lanes(dsi);
 
-	clk_prepare_enable(dsi->pclk);
-
 	ret = phy_ops->get_lane_mbps(priv_data, adjusted_mode, dsi->mode_flags,
 				     lanes, dsi->format, &dsi->lane_mbps);
 	if (ret)
 		DRM_DEBUG_DRIVER("Phy get_lane_mbps() failed\n");
 
-	pm_runtime_get_sync(dsi->dev);
 	dw_mipi_dsi_init(dsi);
 	dw_mipi_dsi_dpi_config(dsi, adjusted_mode);
 	dw_mipi_dsi_packet_handler_config(dsi);
@@ -948,6 +947,8 @@ static void dw_mipi_dsi_bridge_mode_set(struct drm_bridge *bridge,
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 
+	pm_runtime_get_sync(dsi->dev);
+
 	dw_mipi_dsi_mode_set(dsi, adjusted_mode);
 	if (dsi->slave)
 		dw_mipi_dsi_mode_set(dsi->slave, adjusted_mode);
@@ -958,6 +959,9 @@ static void dw_mipi_dsi_bridge_atomic_enable(struct drm_bridge *bridge,
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 
+	if (!pm_runtime_active(dsi->dev))
+		return;
+
 	/* Switch to video mode for panel-bridge enable & panel enable */
 	dw_mipi_dsi_set_mode(dsi, MIPI_DSI_MODE_VIDEO);
 	if (dsi->slave)
diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 79730fa1dd8e..423e853d2ade 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
@@ -737,6 +737,8 @@ static int drm_atomic_connector_set_property(struct drm_connector *connector,
 		state->content_type = val;
 	} else if (property == connector->scaling_mode_property) {
 		state->scaling_mode = val;
+	} else if (property == connector->dithering_property) {
+		state->dithering = val;
 	} else if (property == config->content_protection_property) {
 		if (val == DRM_MODE_CONTENT_PROTECTION_ENABLED) {
 			drm_dbg_kms(dev, "only drivers can set CP Enabled\n");
@@ -828,6 +830,8 @@ drm_atomic_connector_get_property(struct drm_connector *connector,
 		*val = state->colorspace;
 	} else if (property == connector->scaling_mode_property) {
 		*val = state->scaling_mode;
+	} else if (property == connector->dithering_property) {
+		*val = state->dithering;
 	} else if (property == config->hdr_output_metadata_property) {
 		*val = state->hdr_output_metadata ?
 			state->hdr_output_metadata->base.id : 0;
diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
index 27de2a97f1d1..76df92391ccb 100644
--- a/drivers/gpu/drm/drm_connector.c
+++ b/drivers/gpu/drm/drm_connector.c
@@ -947,6 +947,12 @@ static const struct drm_prop_enum_list drm_scaling_mode_enum_list[] = {
 	{ DRM_MODE_SCALE_ASPECT, "Full aspect" },
 };
 
+static const struct drm_prop_enum_list drm_dithering_enum_list[] = {
+	{ DRM_MODE_DITHERING_OFF, "Off" },
+	{ DRM_MODE_DITHERING_ON, "On" },
+	{ DRM_MODE_DITHERING_AUTO, "Automatic" },
+};
+
 static const struct drm_prop_enum_list drm_aspect_ratio_enum_list[] = {
 	{ DRM_MODE_PICTURE_ASPECT_NONE, "Automatic" },
 	{ DRM_MODE_PICTURE_ASPECT_4_3, "4:3" },
@@ -1919,6 +1925,62 @@ int drm_connector_attach_scaling_mode_property(struct drm_connector *connector,
 }
 EXPORT_SYMBOL(drm_connector_attach_scaling_mode_property);
 
+/**
+ * drm_connector_attach_dithering_property - attach atomic dithering property
+ * @connector: connector to attach dithering property on.
+ * @dithering_mask: or'ed mask of BIT(%DRM_MODE_DITHERING_\*).
+ *
+ * This is used to add support for dithering to atomic drivers.
+ *
+ * Returns:
+ * Zero on success, negative errno on failure.
+ */
+int drm_connector_attach_dithering_property(struct drm_connector *connector,
+					    u32 dithering_mask)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_property *dithering_property;
+	int i;
+	const unsigned int valid_dithering_mask =
+		(1U << ARRAY_SIZE(drm_dithering_enum_list)) - 1;
+
+	if (WARN_ON(hweight32(dithering_mask) < 2 ||
+		    dithering_mask & ~valid_dithering_mask))
+		return -EINVAL;
+
+	dithering_property =
+		drm_property_create(dev, DRM_MODE_PROP_ENUM, "dithering",
+				    hweight32(dithering_mask));
+
+	if (!dithering_property)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(drm_dithering_enum_list); i++) {
+		int ret;
+
+		if (!(BIT(i) & dithering_mask))
+			continue;
+
+		ret = drm_property_add_enum(dithering_property,
+					    drm_dithering_enum_list[i].type,
+					    drm_dithering_enum_list[i].name);
+
+		if (ret) {
+			drm_property_destroy(dev, dithering_property);
+
+			return ret;
+		}
+	}
+
+	drm_object_attach_property(&connector->base,
+				   dithering_property, 0);
+
+	connector->dithering_property = dithering_property;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_connector_attach_dithering_property);
+
 /**
  * drm_mode_create_aspect_ratio_property - create aspect ratio property
  * @dev: DRM device
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index a582ddd583c2..30f016358b15 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -435,6 +435,15 @@ config DRM_PANEL_RAYDIUM_RM68200
 	  Say Y here if you want to enable support for Raydium RM68200
 	  720x1280 DSI video mode panel.
 
+config DRM_PANEL_ROCKTECH_HX8394
+	tristate "Rocktech HX8394 720x1280 DSI video mode panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for Rocktech HX8394
+	  720x1280 DSI video mode panel.
+
 config DRM_PANEL_RONBO_RB070D30
 	tristate "Ronbo Electronics RB070D30 panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 34e717382dbb..4d0a07e72895 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_DRM_PANEL_EBBG_FT8719) += panel-ebbg-ft8719.o
 obj-$(CONFIG_DRM_PANEL_ELIDA_KD35T133) += panel-elida-kd35t133.o
 obj-$(CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02) += panel-feixin-k101-im2ba02.o
 obj-$(CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D) += panel-feiyang-fy07024di26a30d.o
+obj-$(CONFIG_DRM_PANEL_ROCKTECH_HX8394) += panel-rocktech-hx8394.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_IL9322) += panel-ilitek-ili9322.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9341) += panel-ilitek-ili9341.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9881C) += panel-ilitek-ili9881c.o
diff --git a/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c b/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
index b4729a94c34a..b0fbd7f1ec4d 100644
--- a/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
+++ b/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
@@ -10,6 +10,7 @@
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
 #include <video/mipi_display.h>
@@ -290,16 +291,15 @@ static int otm8009a_disable(struct drm_panel *panel)
 static int otm8009a_unprepare(struct drm_panel *panel)
 {
 	struct otm8009a *ctx = panel_to_otm8009a(panel);
+	int ret;
 
 	if (!ctx->prepared)
 		return 0;
 
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-	}
-
-	regulator_disable(ctx->supply);
+	pm_runtime_mark_last_busy(panel->dev);
+	ret = pm_runtime_put_autosuspend(panel->dev);
+	if (ret < 0)
+		return ret;
 
 	ctx->prepared = false;
 
@@ -314,20 +314,12 @@ static int otm8009a_prepare(struct drm_panel *panel)
 	if (ctx->prepared)
 		return 0;
 
-	ret = regulator_enable(ctx->supply);
+	ret = pm_runtime_get_sync(panel->dev);
 	if (ret < 0) {
-		dev_err(panel->dev, "failed to enable supply: %d\n", ret);
+		pm_runtime_put_autosuspend(panel->dev);
 		return ret;
 	}
 
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-		msleep(100);
-	}
-
 	ret = otm8009a_init_sequence(ctx);
 	if (ret)
 		return ret;
@@ -380,6 +372,8 @@ static int otm8009a_get_modes(struct drm_panel *panel,
 
 	connector->display_info.width_mm = mode->width_mm;
 	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
 
 	return num_modes;
 }
@@ -446,8 +440,10 @@ static int otm8009a_probe(struct mipi_dsi_device *dsi)
 
 	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset_gpio)) {
-		dev_err(dev, "cannot get reset-gpio\n");
-		return PTR_ERR(ctx->reset_gpio);
+		ret = PTR_ERR(ctx->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		return ret;
 	}
 
 	ctx->supply = devm_regulator_get(dev, "power");
@@ -494,6 +490,10 @@ static int otm8009a_probe(struct mipi_dsi_device *dsi)
 		return ret;
 	}
 
+	pm_runtime_enable(ctx->dev);
+	pm_runtime_set_autosuspend_delay(ctx->dev, 1000);
+	pm_runtime_use_autosuspend(ctx->dev);
+
 	return 0;
 }
 
@@ -503,8 +503,49 @@ static void otm8009a_remove(struct mipi_dsi_device *dsi)
 
 	mipi_dsi_detach(dsi);
 	drm_panel_remove(&ctx->panel);
+
+	pm_runtime_dont_use_autosuspend(ctx->dev);
+	pm_runtime_disable(ctx->dev);
+}
+
+static __maybe_unused int orisetech_otm8009a_suspend(struct device *dev)
+{
+	struct otm8009a *ctx = dev_get_drvdata(dev);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+
+	regulator_disable(ctx->supply);
+
+	return 0;
 }
 
+static __maybe_unused int orisetech_otm8009a_resume(struct device *dev)
+{
+	struct otm8009a *ctx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(100);
+
+	return 0;
+}
+
+static const struct dev_pm_ops orisetech_otm8009a_pm_ops = {
+	SET_RUNTIME_PM_OPS(orisetech_otm8009a_suspend, orisetech_otm8009a_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
 static const struct of_device_id orisetech_otm8009a_of_match[] = {
 	{ .compatible = "orisetech,otm8009a" },
 	{ }
@@ -517,6 +558,7 @@ static struct mipi_dsi_driver orisetech_otm8009a_driver = {
 	.driver = {
 		.name = "panel-orisetech-otm8009a",
 		.of_match_table = orisetech_otm8009a_of_match,
+		.pm = &orisetech_otm8009a_pm_ops,
 	},
 };
 module_mipi_dsi_driver(orisetech_otm8009a_driver);
diff --git a/drivers/gpu/drm/panel/panel-raydium-rm68200.c b/drivers/gpu/drm/panel/panel-raydium-rm68200.c
index 5f9b340588fb..387720bed586 100644
--- a/drivers/gpu/drm/panel/panel-raydium-rm68200.c
+++ b/drivers/gpu/drm/panel/panel-raydium-rm68200.c
@@ -10,6 +10,7 @@
 #include <linux/gpio/consumer.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
 #include <video/mipi_display.h>
@@ -91,7 +92,7 @@ static const struct drm_display_mode default_mode = {
 	.vsync_start = 1280 + 12,
 	.vsync_end = 1280 + 12 + 5,
 	.vtotal = 1280 + 12 + 5 + 12,
-	.flags = 0,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	.width_mm = 68,
 	.height_mm = 122,
 };
@@ -260,14 +261,10 @@ static int rm68200_unprepare(struct drm_panel *panel)
 	if (ret)
 		dev_warn(panel->dev, "failed to enter sleep mode: %d\n", ret);
 
-	msleep(120);
-
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-	}
-
-	regulator_disable(ctx->supply);
+	pm_runtime_mark_last_busy(panel->dev);
+	ret = pm_runtime_put_autosuspend(panel->dev);
+	if (ret < 0)
+		return ret;
 
 	ctx->prepared = false;
 
@@ -283,19 +280,12 @@ static int rm68200_prepare(struct drm_panel *panel)
 	if (ctx->prepared)
 		return 0;
 
-	ret = regulator_enable(ctx->supply);
+	ret = pm_runtime_get_sync(panel->dev);
 	if (ret < 0) {
-		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		pm_runtime_put_autosuspend(panel->dev);
 		return ret;
 	}
 
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-		msleep(100);
-	}
-
 	rm68200_init_sequence(ctx);
 
 	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
@@ -347,6 +337,8 @@ static int rm68200_get_modes(struct drm_panel *panel,
 
 	connector->display_info.width_mm = mode->width_mm;
 	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
 
 	return 1;
 }
@@ -372,7 +364,8 @@ static int rm68200_probe(struct mipi_dsi_device *dsi)
 	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset_gpio)) {
 		ret = PTR_ERR(ctx->reset_gpio);
-		dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
 		return ret;
 	}
 
@@ -409,6 +402,10 @@ static int rm68200_probe(struct mipi_dsi_device *dsi)
 		return ret;
 	}
 
+	pm_runtime_enable(ctx->dev);
+	pm_runtime_set_autosuspend_delay(ctx->dev, 1000);
+	pm_runtime_use_autosuspend(ctx->dev);
+
 	return 0;
 }
 
@@ -418,8 +415,48 @@ static void rm68200_remove(struct mipi_dsi_device *dsi)
 
 	mipi_dsi_detach(dsi);
 	drm_panel_remove(&ctx->panel);
+
+	pm_runtime_dont_use_autosuspend(ctx->dev);
+	pm_runtime_disable(ctx->dev);
 }
 
+static __maybe_unused int raydium_rm68200_suspend(struct device *dev)
+{
+	struct rm68200 *ctx = dev_get_drvdata(dev);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static __maybe_unused int raydium_rm68200_resume(struct device *dev)
+{
+	struct rm68200 *ctx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(100);
+
+	return 0;
+}
+
+static const struct dev_pm_ops raydium_rm68200_pm_ops = {
+	SET_RUNTIME_PM_OPS(raydium_rm68200_suspend, raydium_rm68200_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
 static const struct of_device_id raydium_rm68200_of_match[] = {
 	{ .compatible = "raydium,rm68200" },
 	{ }
@@ -432,6 +469,7 @@ static struct mipi_dsi_driver raydium_rm68200_driver = {
 	.driver = {
 		.name = "panel-raydium-rm68200",
 		.of_match_table = raydium_rm68200_of_match,
+		.pm = &raydium_rm68200_pm_ops,
 	},
 };
 module_mipi_dsi_driver(raydium_rm68200_driver);
diff --git a/drivers/gpu/drm/panel/panel-rocktech-hx8394.c b/drivers/gpu/drm/panel/panel-rocktech-hx8394.c
new file mode 100644
index 000000000000..cc71168be292
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-rocktech-hx8394.c
@@ -0,0 +1,429 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics SA 2022
+ *
+ * Author: Yannick Fertre <yannick.fertre@foss.st.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct hx8394 {
+	struct device *dev;
+	struct drm_panel panel;
+	struct gpio_desc *reset_gpio;
+	struct regulator *supply;
+	bool prepared;
+	bool enabled;
+};
+
+static const struct drm_display_mode default_mode = {
+	.clock = 54000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 48,
+	.hsync_end = 720 + 48 + 9,
+	.htotal = 720 + 48 + 9 + 48,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 12,
+	.vsync_end = 1280 + 12 + 5,
+	.vtotal = 1280 + 12 + 5 + 12,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm = 68,
+	.height_mm = 122,
+};
+
+#define MCS_SETPOWER	0xB1
+#define MCS_SETDISP	0xB2
+#define MCS_SETCYC	0xB4
+#define MCS_SETVCOM	0xB6
+#define MCS_SETEXTC	0xB9
+#define MCS_SETMIPI	0xBA
+#define MCS_SET_BANK	0xBD
+#define MCS_NO_DOC1	0xBF
+#define MCS_NO_DOC2	0xC0
+#define MCS_NO_DOC3	0xC6
+#define MCS_NO_DOC4	0xD8
+#define MCS_NO_DOC5	0xD4
+#define MCS_SETPANEL	0xCC
+#define MCS_SETGIP_0	0xD3
+#define MCS_SETGIP_1	0xD5
+#define MCS_SETGIP_2	0xD6
+
+#define MCS_SETGAMMA	0xE0
+#define MCS_READ_ID1	0xDA
+#define MCS_READ_ID2	0xDB
+#define MCS_READ_ID3	0xDC
+
+#define MY	BIT(7)	/* Row Address Order */
+#define MX	BIT(6)	/* Column Address Order */
+#define MV	BIT(5)	/* Row/Column Exchange */
+#define ML	BIT(4)	/* Vertical Refresh Order */
+#define RGB	BIT(3)	/* RGB-BGR Order */
+#define DDL	BIT(2)	/* Display Data Latch Order */
+#define FH	BIT(1)	/* Flip Horizontal */
+#define FV	BIT(0)	/* Flip Vertical */
+
+static inline struct hx8394 *panel_to_hx8394(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394, panel);
+}
+
+#define dcs_write_cmd_seq(c, cmd, seq...)						\
+({											\
+	static const u8 d[] = { seq };							\
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device((c)->dev);			\
+	int err;									\
+	err = mipi_dsi_dcs_write(dsi, cmd, d, ARRAY_SIZE(d));				\
+	if (err < 0)									\
+		dev_err(ctx->dev, "MIPI DSI DCS write failed: %d\n", err);		\
+})
+
+static void hx8394_dcs_write_buf(struct hx8394 *ctx, const void *data,
+				 size_t len)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int err;
+
+	err = mipi_dsi_dcs_write_buffer(dsi, data, len);
+	if (err < 0)
+		dev_err_ratelimited(ctx->dev, "MIPI DSI DCS write buffer failed: %d\n", err);
+}
+
+#define dcs_write_seq(ctx, seq...)				\
+({								\
+	static const u8 d[] = { seq };				\
+								\
+	hx8394_dcs_write_buf(ctx, d, ARRAY_SIZE(d));	\
+})
+
+static void hx8394_init_sequence(struct hx8394 *ctx)
+{
+	dcs_write_cmd_seq(ctx, MCS_SETEXTC, 0xFF, 0x83, 0x94);
+	dcs_write_cmd_seq(ctx, MCS_SETMIPI, 0x61, 0x03, 0x68, 0x6B, 0xB2, 0xC0);
+	dcs_write_seq(ctx, MCS_SETPOWER, 0x48, 0x12, 0x72, 0x09, 0x32, 0x54, 0x71, 0x71, 0x57,
+		      0x47);
+	dcs_write_cmd_seq(ctx, MCS_SETDISP, 0x00, 0x80, 0x64, 0x0C, 0x0D, 0x2F);
+	dcs_write_seq(ctx, MCS_SETCYC, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86, 0x75,
+		      0x00, 0x3F, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86);
+	dcs_write_seq(ctx, MCS_SETGIP_0, 0x00, 0x00, 0x07, 0x07, 0x40, 0x07, 0x0C, 0x00, 0x08, 0x10,
+		      0x08, 0x00, 0x08, 0x54, 0x15, 0x0A, 0x05, 0x0A, 0x02, 0x15, 0x06, 0x05, 0x06,
+		      0x47, 0x44, 0x0A, 0x0A, 0x4B, 0x10, 0x07, 0x07, 0x0C, 0x40);
+	dcs_write_seq(ctx, MCS_SETGIP_1, 0x1C, 0x1C, 0x1D, 0x1D, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
+		      0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x24, 0x25, 0x18, 0x18, 0x26, 0x27, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x20, 0x21, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_seq(ctx, MCS_SETGIP_2, 0x1C, 0x1C, 0x1D, 0x1D, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02,
+		      0x01, 0x00, 0x0B, 0x0A, 0x09, 0x08, 0x21, 0x20, 0x18, 0x18, 0x27, 0x26, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x25, 0x24, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_cmd_seq(ctx, MCS_SETVCOM, 0x92, 0x92);
+	dcs_write_seq(ctx, MCS_SETGAMMA, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24, 0x22, 0x47, 0x56,
+		      0x65, 0x66, 0x6E, 0x82, 0x88, 0x8B, 0x9A, 0x9D, 0x98, 0xA8, 0xB9, 0x5D, 0x5C,
+		      0x61, 0x66, 0x6A, 0x6F, 0x7F, 0x7F, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24,
+		      0x22, 0x47, 0x56, 0x65, 0x65, 0x6E, 0x81, 0x87, 0x8B, 0x98, 0x9D, 0x99, 0xA8,
+		      0xBA, 0x5D, 0x5D, 0x62, 0x67, 0x6B, 0x72, 0x7F,  0x7F);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC2, 0x1F, 0x31);
+	dcs_write_cmd_seq(ctx, MCS_SETPANEL, 0x03);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC5, 0x02);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x02);
+	dcs_write_seq(ctx, MCS_NO_DOC4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		      0xFF, 0xFF);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x01);
+	dcs_write_cmd_seq(ctx, MCS_SETPOWER, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC1, 0x40, 0x81, 0x50, 0x00, 0x1A, 0xFC, 0x01);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC3, 0xED);
+	dcs_write_cmd_seq(ctx, MIPI_DCS_SET_ADDRESS_MODE, FH);
+}
+
+static int hx8394_read_id(struct hx8394 *ctx)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	u8 id1, id2, id3;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID1, &id1, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID1\n");
+		return ret;
+	}
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID2, &id2, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID2\n");
+		return ret;
+	}
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID3, &id3, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID3\n");
+		return ret;
+	}
+
+	dev_info(ctx->dev, "MTP ID manufacturer: %02x version: %02x driver: %02x\n", id1, id2, id3);
+
+	return 0;
+}
+
+static int hx8394_enable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+
+	if (ctx->enabled)
+		return 0;
+
+	ctx->enabled = true;
+
+	return 0;
+}
+
+static int hx8394_disable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+
+	if (!ctx->enabled)
+		return 0;
+
+	ctx->enabled = false;
+
+	return 0;
+}
+
+static int hx8394_prepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = pm_runtime_get_sync(panel->dev);
+	if (ret < 0) {
+		pm_runtime_put_autosuspend(panel->dev);
+		return ret;
+	}
+
+	ret = hx8394_read_id(ctx);
+	if (ret < 0)
+		return ret;
+
+	hx8394_init_sequence(ctx);
+
+	ret = mipi_dsi_dcs_set_tear_off(dsi);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret)
+		return ret;
+
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret)
+		return ret;
+
+	msleep(50);
+
+	ctx->prepared = true;
+
+	return 0;
+}
+
+static int hx8394_unprepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret)
+		dev_warn(panel->dev, "failed to set display off: %d\n", ret);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret)
+		dev_warn(panel->dev, "failed to enter sleep mode: %d\n", ret);
+
+	pm_runtime_mark_last_busy(panel->dev);
+	ret = pm_runtime_put_autosuspend(panel->dev);
+	if (ret < 0)
+		return ret;
+
+	ctx->prepared = false;
+
+	return 0;
+}
+
+static int hx8394_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+			default_mode.hdisplay, default_mode.vdisplay,
+			drm_mode_vrefresh(&default_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs hx8394_drm_funcs = {
+	.disable = hx8394_disable,
+	.unprepare = hx8394_unprepare,
+	.prepare = hx8394_prepare,
+	.enable = hx8394_enable,
+	.get_modes = hx8394_get_modes,
+};
+
+static int hx8394_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset_gpio)) {
+		ret = PTR_ERR(ctx->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get regulator: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	ctx->dev = dev;
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394_drm_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "mipi_dsi_attach() failed: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	pm_runtime_enable(ctx->dev);
+	pm_runtime_set_autosuspend_delay(ctx->dev, 1000);
+	pm_runtime_use_autosuspend(ctx->dev);
+
+	return 0;
+}
+
+static void hx8394_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394 *ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	pm_runtime_dont_use_autosuspend(ctx->dev);
+	pm_runtime_disable(ctx->dev);
+}
+
+static __maybe_unused int rocktech_hx8394_suspend(struct device *dev)
+{
+	struct hx8394 *ctx = dev_get_drvdata(dev);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static __maybe_unused int rocktech_hx8394_resume(struct device *dev)
+{
+	struct hx8394 *ctx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	mdelay(1);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+
+	return 0;
+}
+
+static const struct dev_pm_ops rocktech_hx8394_pm_ops = {
+	SET_RUNTIME_PM_OPS(rocktech_hx8394_suspend, rocktech_hx8394_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
+static const struct of_device_id rocktech_hx8394_of_match[] = {
+	{ .compatible = "rocktech,hx8394" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rocktech_hx8394_of_match);
+
+static struct mipi_dsi_driver rocktech_hx8394_driver = {
+	.probe = hx8394_probe,
+	.remove = hx8394_remove,
+	.driver = {
+		.name = "panel-rocktech-hx8394",
+		.of_match_table = rocktech_hx8394_of_match,
+		.pm = &rocktech_hx8394_pm_ops,
+	},
+};
+module_mipi_dsi_driver(rocktech_hx8394_driver);
+
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@foss.st.com>");
+MODULE_DESCRIPTION("DRM Driver for rocktech HX8394 MIPI DSI panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 8a3b685c2fcc..1ff29d660c96 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -467,6 +467,7 @@ static int panel_dpi_probe(struct device *dev,
 	struct panel_desc *desc;
 	unsigned int bus_flags;
 	struct videomode vm;
+	const char *mapping;
 	int ret;
 
 	np = dev->of_node;
@@ -491,6 +492,21 @@ static int panel_dpi_probe(struct device *dev,
 	of_property_read_u32(np, "width-mm", &desc->size.width);
 	of_property_read_u32(np, "height-mm", &desc->size.height);
 
+	of_property_read_string(np, "data-mapping", &mapping);
+	if (!strcmp(mapping, "rgb24")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+		desc->bpc = 8;
+	} else if (!strcmp(mapping, "rgb565")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB565_1X16;
+		desc->bpc = 6;
+	} else if (!strcmp(mapping, "bgr666")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB666_1X18;
+		desc->bpc = 6;
+	} else if (!strcmp(mapping, "lvds666")) {
+		desc->bus_format = MEDIA_BUS_FMT_RGB666_1X24_CPADHI;
+		desc->bpc = 6;
+	}
+
 	/* Extract bus_flags from display_timing */
 	bus_flags = 0;
 	vm.flags = timing->flags;
diff --git a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
index 89897d5f5c72..6c0f9bd2a61c 100644
--- a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
+++ b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
@@ -11,6 +11,7 @@
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
 #include <video/mipi_display.h>
@@ -77,6 +78,7 @@ enum dsi_color {
 struct dw_mipi_dsi_stm {
 	void __iomem *base;
 	struct clk *pllref_clk;
+	struct clk *pclk;
 	struct dw_mipi_dsi *dsi;
 	u32 hw_version;
 	int lane_min_kbps;
@@ -443,16 +445,13 @@ static int dw_mipi_dsi_stm_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct dw_mipi_dsi_stm *dsi;
-	struct clk *pclk;
-	struct resource *res;
 	int ret;
 
 	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
 	if (!dsi)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dsi->base = devm_ioremap_resource(dev, res);
+	dsi->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(dsi->base)) {
 		ret = PTR_ERR(dsi->base);
 		DRM_ERROR("Unable to get dsi registers %d\n", ret);
@@ -485,21 +484,21 @@ static int dw_mipi_dsi_stm_probe(struct platform_device *pdev)
 		goto err_clk_get;
 	}
 
-	pclk = devm_clk_get(dev, "pclk");
-	if (IS_ERR(pclk)) {
-		ret = PTR_ERR(pclk);
+	dsi->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(dsi->pclk)) {
+		ret = PTR_ERR(dsi->pclk);
 		DRM_ERROR("Unable to get peripheral clock: %d\n", ret);
 		goto err_dsi_probe;
 	}
 
-	ret = clk_prepare_enable(pclk);
+	ret = clk_prepare_enable(dsi->pclk);
 	if (ret) {
 		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
 		goto err_dsi_probe;
 	}
 
 	dsi->hw_version = dsi_read(dsi, DSI_VERSION) & VERSION;
-	clk_disable_unprepare(pclk);
+	clk_disable_unprepare(dsi->pclk);
 
 	if (dsi->hw_version != HWVER_130 && dsi->hw_version != HWVER_131) {
 		ret = -ENODEV;
@@ -555,6 +554,7 @@ static int __maybe_unused dw_mipi_dsi_stm_suspend(struct device *dev)
 	DRM_DEBUG_DRIVER("\n");
 
 	clk_disable_unprepare(dsi->pllref_clk);
+	clk_disable_unprepare(dsi->pclk);
 	regulator_disable(dsi->vdd_supply);
 
 	return 0;
@@ -573,8 +573,16 @@ static int __maybe_unused dw_mipi_dsi_stm_resume(struct device *dev)
 		return ret;
 	}
 
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		regulator_disable(dsi->vdd_supply);
+		DRM_ERROR("Failed to enable pclk: %d\n", ret);
+		return ret;
+	}
+
 	ret = clk_prepare_enable(dsi->pllref_clk);
 	if (ret) {
+		clk_disable_unprepare(dsi->pclk);
 		regulator_disable(dsi->vdd_supply);
 		DRM_ERROR("Failed to enable pllref_clk: %d\n", ret);
 		return ret;
@@ -584,8 +592,10 @@ static int __maybe_unused dw_mipi_dsi_stm_resume(struct device *dev)
 }
 
 static const struct dev_pm_ops dw_mipi_dsi_stm_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(dw_mipi_dsi_stm_suspend,
-				dw_mipi_dsi_stm_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(dw_mipi_dsi_stm_suspend,
+			   dw_mipi_dsi_stm_resume, NULL)
 };
 
 static struct platform_driver dw_mipi_dsi_stm_driver = {
diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index 03c6becda795..c2b17c0407dc 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -776,10 +776,17 @@ static void ltdc_crtc_atomic_enable(struct drm_crtc *crtc,
 {
 	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
 	struct drm_device *ddev = crtc->dev;
+	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
 
-	pm_runtime_get_sync(ddev->dev);
+	if (!pm_runtime_active(ddev->dev)) {
+		ret = pm_runtime_get_sync(ddev->dev);
+		if (ret) {
+			DRM_ERROR("Failed to set mode, cannot get sync\n");
+			return;
+		}
+	}
 
 	/* Sets the background color value */
 	regmap_write(ldev->regmap, LTDC_BCCR, BCCR_BCBLACK);
@@ -817,7 +824,7 @@ static void ltdc_crtc_atomic_disable(struct drm_crtc *crtc,
 	if (!ldev->caps.plane_reg_shadow)
 		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_IMR);
 
-	pm_runtime_put_sync(ddev->dev);
+	pm_runtime_put_sync_suspend(ddev->dev);
 
 	/*  clear interrupt error counters */
 	mutex_lock(&ldev->err_lock);
@@ -978,8 +985,11 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)
 		val |= GCR_PCPOL;
 
+	if (connector && connector->state->dithering == DRM_MODE_DITHERING_ON)
+		val |= GCR_DEN;
+
 	regmap_update_bits(ldev->regmap, LTDC_GCR,
-			   GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL, val);
+			   GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL | GCR_DEN, val);
 
 	/* Set Synchronization size */
 	val = (hsync << 16) | vsync;
@@ -1057,6 +1067,20 @@ static void ltdc_crtc_atomic_flush(struct drm_crtc *crtc,
 	}
 }
 
+static int ltdc_crtc_atomic_check(struct drm_crtc *crtc,
+				  struct drm_atomic_state *state)
+{
+	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
+
+	DRM_DEBUG_ATOMIC("\n");
+
+	/* force a full mode set if active state changed */
+	if (crtc_state->active_changed)
+		crtc_state->mode_changed = true;
+
+	return 0;
+}
+
 static bool ltdc_crtc_get_scanout_position(struct drm_crtc *crtc,
 					   bool in_vblank_irq,
 					   int *vpos, int *hpos,
@@ -1117,6 +1141,7 @@ static const struct drm_crtc_helper_funcs ltdc_crtc_helper_funcs = {
 	.atomic_flush = ltdc_crtc_atomic_flush,
 	.atomic_enable = ltdc_crtc_atomic_enable,
 	.atomic_disable = ltdc_crtc_atomic_disable,
+	.atomic_check = ltdc_crtc_atomic_check,
 	.get_scanout_position = ltdc_crtc_get_scanout_position,
 };
 
@@ -1260,6 +1285,7 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 				     struct drm_atomic_state *state)
 {
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
 	struct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,
 									  plane);
 	struct drm_framebuffer *fb = newstate->fb;
@@ -1290,6 +1316,9 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 			 newstate->crtc_w, newstate->crtc_h,
 			 newstate->crtc_x, newstate->crtc_y);
 
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
 	regmap_read(ldev->regmap, LTDC_BPCR, &bpcr);
 
 	ahbp = (bpcr & BPCR_AHBP) >> 16;
@@ -1508,8 +1537,12 @@ static void ltdc_plane_atomic_disable(struct drm_plane *plane,
 	struct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,
 									  plane);
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
 	u32 lofs = plane->index * LAY_OFS;
 
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
 	/* Disable layer */
 	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_LEN | LXCR_CLUTEN |  LXCR_HMEN, 0);
 
@@ -1658,6 +1691,16 @@ static int ltdc_crtc_init(struct drm_device *ddev, struct drm_crtc *crtc)
 	int supported_rotations = DRM_MODE_ROTATE_0 | DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;
 	unsigned int i;
 	int ret;
+	struct drm_connector *connector = NULL;
+	struct drm_connector_list_iter iter;
+
+	/* Add the dithering property to all connectors */
+	drm_connector_list_iter_begin(ddev, &iter);
+	drm_for_each_connector_iter(connector, &iter)
+		drm_connector_attach_dithering_property(connector,
+							BIT(DRM_MODE_DITHERING_OFF) |
+							BIT(DRM_MODE_DITHERING_ON));
+	drm_connector_list_iter_end(&iter);
 
 	primary = ltdc_plane_create(ddev, DRM_PLANE_TYPE_PRIMARY, 0);
 	if (!primary) {
@@ -1923,7 +1966,6 @@ int ltdc_load(struct drm_device *ddev)
 	struct drm_panel *panel;
 	struct drm_crtc *crtc;
 	struct reset_control *rstc;
-	struct resource *res;
 	int irq, i, nb_endpoints;
 	int ret = -ENODEV;
 
@@ -1990,8 +2032,7 @@ int ltdc_load(struct drm_device *ddev)
 		reset_control_deassert(rstc);
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	ldev->regs = devm_ioremap_resource(dev, res);
+	ldev->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(ldev->regs)) {
 		DRM_ERROR("Unable to get ltdc registers\n");
 		ret = PTR_ERR(ldev->regs);
diff --git a/drivers/video/backlight/gpio_backlight.c b/drivers/video/backlight/gpio_backlight.c
index 6f78d928f054..d3fa3a8bef4d 100644
--- a/drivers/video/backlight/gpio_backlight.c
+++ b/drivers/video/backlight/gpio_backlight.c
@@ -53,6 +53,7 @@ static int gpio_backlight_probe(struct platform_device *pdev)
 	struct backlight_device *bl;
 	struct gpio_backlight *gbl;
 	int ret, init_brightness, def_value;
+	u32 value;
 
 	gbl = devm_kzalloc(dev, sizeof(*gbl), GFP_KERNEL);
 	if (gbl == NULL)
@@ -93,7 +94,11 @@ static int gpio_backlight_probe(struct platform_device *pdev)
 	else
 		bl->props.power = FB_BLANK_UNBLANK;
 
-	bl->props.brightness = 1;
+	ret = device_property_read_u32(dev, "default-brightness-level", &value);
+	if (!ret && value <= props.max_brightness)
+		bl->props.brightness = value;
+	else
+		bl->props.brightness = 1;
 
 	init_brightness = backlight_get_brightness(bl);
 	ret = gpiod_direction_output(gbl->gpiod, init_brightness);
diff --git a/include/drm/drm_connector.h b/include/drm/drm_connector.h
index 4d830fc55a3d..aff22a4ea793 100644
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@ -815,6 +815,12 @@ struct drm_connector_state {
 	 */
 	unsigned int scaling_mode;
 
+	/**
+	 * @dithering: Connector property to control the
+	 * dithering.
+	 */
+	unsigned int dithering;
+
 	/**
 	 * @content_protection: Connector property to request content
 	 * protection. This is most commonly used for HDCP.
@@ -1463,6 +1469,12 @@ struct drm_connector {
 	 */
 	struct drm_property *scaling_mode_property;
 
+	/**
+	 * @dithering_property: Optional atomic property to control the
+	 * dithering.
+	 */
+	struct drm_property *dithering_property;
+
 	/**
 	 * @vrr_capable_property: Optional property to help userspace
 	 * query hardware support for variable refresh rate on a connector.
@@ -1811,6 +1823,8 @@ int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 int drm_connector_attach_content_type_property(struct drm_connector *dev);
 int drm_connector_attach_scaling_mode_property(struct drm_connector *connector,
 					       u32 scaling_mode_mask);
+int drm_connector_attach_dithering_property(struct drm_connector *connector,
+					    u32 dithering_mask);
 int drm_connector_attach_vrr_capable_property(
 		struct drm_connector *connector);
 int drm_connector_attach_colorspace_property(struct drm_connector *connector);
-- 
2.17.1

